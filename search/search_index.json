{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Welcome to Fragcolor documentation! These documents will help you understand, use, and contribute to Fragcolor technologies. You can start from a high-level topic below or use the navigation links at the top. Shards Built-in functions Contributions guides Use the search box if you're looking for something specific. Built on Aug 15, 2022 at 11:10:38 from commit 489ddc2 .","title":"Welcome"},{"location":"#welcome","text":"Welcome to Fragcolor documentation! These documents will help you understand, use, and contribute to Fragcolor technologies. You can start from a high-level topic below or use the navigation links at the top. Shards Built-in functions Contributions guides Use the search box if you're looking for something specific. Built on Aug 15, 2022 at 11:10:38 from commit 489ddc2 .","title":"Welcome"},{"location":"architecture-guides/","text":"Introduction \u00b6 Software architecture guides explain how the software works, at a high level, without getting into code. They describe how it is structured and how it's various components interface and work with each other.","title":"Introduction"},{"location":"architecture-guides/#introduction","text":"Software architecture guides explain how the software works, at a high level, without getting into code. They describe how it is structured and how it's various components interface and work with each other.","title":"Introduction"},{"location":"architecture-guides/shards/","text":"Shards Architecture Guide \u00b6 // TODO // Stateful Functions \u00b6 // TODO //","title":"Shards Architecture Guide"},{"location":"architecture-guides/shards/#shards-architecture-guide","text":"// TODO //","title":"Shards Architecture Guide"},{"location":"architecture-guides/shards/#stateful-functions","text":"// TODO //","title":"Stateful Functions"},{"location":"contribute/","text":"Introduction \u00b6 Fragcolor has a number of interesting projects open to community contributions. This guide will explain how to set up your development environment. And then, it will walk you through your first code or documentation contribution!","title":"Introduction"},{"location":"contribute/#introduction","text":"Fragcolor has a number of interesting projects open to community contributions. This guide will explain how to set up your development environment. And then, it will walk you through your first code or documentation contribution!","title":"Introduction"},{"location":"contribute/code/building-shards/","text":"Building Shards \u00b6 This guide explains how to build Shards from the sources, for Windows and Ubuntu (on WSL). Before you start, ensure you've set up your development environment . Requirements \u00b6 Note We use GCC and Clang a lot; MSVC might work, but it's uncharted territory. For Windows \u00b6 Ensure your system environment PATH variable includess the MinGW bin location. This value can be set from: Settings > Edit environment variables for your account > User variables for 'user' > Path > Edit. This allows you to run MinGW from Powershell, VS Code, etc. The value of this PATH is usually C:\\msys64\\mingw64\\bin . Clone the Shards repo \u00b6 You'd normally clone the Shards repository locally ( git clone ... ), checkout the branch you want to work with ( git checkout ... ), and pull the latest changes to your machine ( git pull ). But since the Shards repository contains submodules (links to external repositories), you also have to pull the latest changes for these submodules (including nested submodules). This can be done with the following command (to be run every time you want to build the project). git submodule update --init --recursive Set up the RUST toolchain \u00b6 Install and switch to the Rust GNU toolchain with the following rustup commands (from any terminal). Command Output # Windows rustup toolchain install nightly rustup default nightly-x86_64-pc-windows-gnu # Ubuntu (WSL) rustup install nightly rustup default nightly C:\\Users\\saten>rustup default nightly-x86_64-pc-windows-gnu info: syncing channel updates for 'nightly-x86_64-pc-windows-gnu' info: latest update on 2022-01-20, rust version 1.58.1 (db9d1b20b 2022-01-20) info: downloading component 'cargo' info: downloading component 'clippy' info: downloading component 'rust-docs' 18.8 MiB / 18.8 MiB (100 %) 9.4 MiB/s in 2s ETA: 0s . . . info: installing component 'rustfmt' info: default toolchain set to 'nightly-x86_64-pc-windows-gnu' nightly-x86_64-pc-windows-gnu installed - rust 1.58.1 (db9d1b20b 2022-01-20) C:\\Users\\saten> When adding rust targets, ensure they're installed for nightly toolchain. For example to add the target x86_64-pc-windows-gnu run the following command. Command Output # Windows rustup +nightly target add x86_64-pc-windows-gnu # Ubuntu (WSL) rustup target add wasm32-unknown-unknown --toolchain nightly info: downloading component 'rust-std' for 'x86_64-pc-windows-gnu' info: installing component 'rust-std' for 'x86_64-pc-windows-gnu' 24.5 MiB / 24.5 MiB (100 %) 6.0 MiB/s in 4s ETA: 0s Update system packages \u00b6 You should update your system packages frequently and preferably every time you want to build the project. Windows \u00b6 You'll need to run these commands in a MinGW terminal. To get to this terminal go to the Windows start menu, search for 'MSYS2 MinGW' and click the version appropriate for your machine (x86 or x64). Update the Rust packages with rustup (works with Windows, Mac, and Linux). rustup update Next, update other packages with pacman . Note pacman comes preinstalled as part of MSYS2 on Windows. For Mac you can get it here or use the pre-installed package manager, Homebrew . Sync, refresh, and update all local packages that have a newer version available. Command Output pacman -Syu --noconfirm $ pacman -Syu :: Synchronizing package databases... mingw32 805.0 KiB mingw32.sig 438.0 B mingw64 807.9 KiB mingw64.sig 438.0 B msys 289.3 KiB msys.sig 438.0 B :: Starting core system upgrade... . . . Restart the MinGW terminal (if needed) and install the required build dependencies with this command (replace the w64-x86_64 as appropriate for your target OS/machine). Command Output pacman -Sy --needed --noconfirm base-devel mingw-w64-x86_64-toolchain mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang mingw-w64-x86_64-lld wget :: Synchronizing package databases... warning: base-devel-2022.01-1 is up to date -- skipping warning: mingw-w64-x86_64-binutils-2.37-4 is up to date -- skipping warning: mingw-w64-x86_64-crt-git-9.0.0.6373.5be8fcd83-1 is up to date -- skipping . . . (13/15) upgrading mingw-w64-x86_64-clang [#####################] 100% (14/15) upgrading mingw-w64-x86_64-lld [#####################] 100% (15/15) upgrading wget [#####################] 100% :: Running post-transaction hooks... (1/1) Updating the info directory file... Ubuntu (WSL) \u00b6 Update the Rust packages with rustup (works with Windows, Mac, and Linux). rustup update Next, update packages and install dependencies. Command sudo apt update sudo apt install -y build-essential git cmake g++ wget clang ninja-build valgrind xorg-dev libdbus-1-dev libssl-dev lcov ca-certificates Build & run the project \u00b6 Bootstrap the project \u00b6 Continuing with the MinGW terminal (or any terminal on Linux), navigate to Shards root directory, and run the bootstrap shell script (to be run only once, when you build the project for the first time). Windows Mac/Linux Output ./bootstrap bash bootstrap # or ./bootstrap Using SHARDS_ROOT=/c/Users/saten/Desktop/code/shards /c/Users/saten/Desktop/code/shards/deps /c/Users/saten/Desktop/code/shards Setting up dependencies /c/Users/saten/Desktop/code/shards Setting up tools /c/Users/saten/Desktop/code/shards/src/tools /c/Users/saten/Desktop/code/shards -- Build spdlog: 1.8.5 -- Build type: Release -- Configuring done -- Generating done -- Build files have been written to: C:/Users/saten/Desktop/code/shards/src/tools/build [1/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/stdout_sinks.cpp.obj [2/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/color_sinks.cpp.obj [3/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/fmt.cpp.obj [4/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/spdlog.cpp.obj [5/6] Linking CXX static library deps\\spdlog\\libspdlog.a [6/6] Linking CXX executable bin\\bin2c.exe /c/Users/saten/Desktop/code/shards Build the project \u00b6 Go to Shards root and create a build directory (if it doesn't already exist) and navigate into it. mkdir build cd build You need to run the following two commands every time you want to build the project. Configure the build with cmake , # Windows and Linux (WSL) cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug .. Release mode build In case you need less verbose script execution logs, build Shards in release mode (instead of the debug mode) by using the option -DCMAKE_BUILD_TYPE=Release .. then build the target with ninja ninja shards Build with formatting (useful for pull requests) Formatting the source is required when raising a PR (for contributing a change). You can do it simply by running ninja format; ninja shards The build ends with a successful linking of the Shards executable (shards.exe). Fix build errors If your build fails due to target/file errors navigate out of the build folder, run cargo clean , then cd build , followed by ninja clean , and/or delete the target folder and then rebuild. The build can also fail if your software packages or repository submodules ( /shards/deps/ ) are out-of-date. To resolve this update the specific software package as given here and pull the submodules again via git submodule update --init --recursive . Note When generating the Rust bindings during compilation, the file rust/src/shardsc.rs might be updated automatically. These changes should not be pushed upstream unless you're modifying certain core files for build-target architecture changes (which is very rare). Hence, use the git command git update-index --skip-worktree rust/src/shardsc.rs to let git ignore changes to this file. Verify build and run \u00b6 To verify your build was successful create an empty script file ( .edn) in the /build folder, populate it with the Script code , and execute the Run command * from the /build folder. Script code Run command Script result (defmesh main) (defloop test (Msg \"Hello World\")) (schedule main test) (run main 1 1) ./shards <script-filename.edn> [info] [2022-05-24 06:09:39.293] [T-3196] [logging.cpp::98] [test] Hello World If you see Hello World printed on your screen (the Script result ) your build was successful. You can also configure the Run Code button on VS Code (arrow/triangle on the top right-hand corner of the code-editor) to run Shards scripts. Install the VS Code code-runner extension Locate the code-runner.executorMap parameter to open in settings.json (VS Code > File > Preferences > Settings > search for code-runner.executorMap > click 'Edit in settings.json') In the settings.json file set the value of the code-runner.excutorMap to point to build\\\\shards.exe for clojure . You can also add a second entry setting code-runner.runInTerminal to true if you want the script output displayed in the Terminal tab of your terminal (instead of in the Output tab, which is the default). \"code-runner.executorMap\": { \"clojure\": \"build\\\\shards.exe\" \"code-runner.runInTerminal\": true }, Now open your Shards script file and click the Run Code button. The script will be executed and you should see the script's result in your terminal. Build for Web Assembly \u00b6 To create a Web Assembly (WASM) build, first clone the Emscripten SDK repo. git clone https://github.com/emscripten-core/emsdk.git Use a mingw64.exe terminal to navigate to the emsdk directory, cd emsdk and then do a git pull to get the latest tools from GitHub (not required the first time you clone the git repository). git pull Update the SDK tools to the latest version. Windows Mac/Linux emsdk install latest ./emsdk install latest Activate the latest SDK for the current user. Windows Mac/Linux emsdk activate latest ./emsdk activate latest Activate the PATH/ environment variables for the current terminal session. Windows Mac/Linux emsdk_env.bat source emsdk_env.sh Open a Windows or VS Code terminal and navigate to the Shards directory. Run the following commands in sequence to create and link the Web Assembly build. mkdir build-wasm cd build-wasm cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=$EMSDK/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake .. ninja format; ninja shards Refer to the official Emscripten SDK documentation for more details on building for Web Assembly. Appendix A - Valid cmake targets \u00b6 You may also build for targets other than shards . This section gives the complete list of supported cmake targets. Build Targets \u00b6 shards - Builds shards. the runtime + lisp interpreter. shards-dll - Builds shards as a dynamic library. shards-static - Builds shards as a static library. shards-core-shared - Builds the shards runtime as a dynamic library. shards-core-static - Builds the shards runtime as a static library. shards-extra - Builds the shards-extra library containing the shards inside src/extra. cargo-shards-rust - Builds the rust project inside the rust folder. Formatting targets \u00b6 format - Runs clang-format on a list of files defined in cmake/Tidy.cmake. tidy - Runs clang-tidy on a list of files defined in cmake/Tidy.cmake. Test targets \u00b6 These contain tests written in c++ for shards (separate from the edn scripts). test_extra - C++ Tests for extra shards. test_gfx - C++ Tests for graphics/rendering. test_runtime - C++ Tests for the shards runtime. Graphics targets \u00b6 gfx - The graphics library. gfx-sandbox - Graphics test environment. gfx_imgui - ImGui backend library. gfx_texture_file - Texture loading utilities. cargo-wgpu-native - Builds the rust project inside src/gfx/wgpu-native.","title":"Building Shards"},{"location":"contribute/code/building-shards/#building-shards","text":"This guide explains how to build Shards from the sources, for Windows and Ubuntu (on WSL). Before you start, ensure you've set up your development environment .","title":"Building Shards"},{"location":"contribute/code/building-shards/#requirements","text":"Note We use GCC and Clang a lot; MSVC might work, but it's uncharted territory.","title":"Requirements"},{"location":"contribute/code/building-shards/#for-windows","text":"Ensure your system environment PATH variable includess the MinGW bin location. This value can be set from: Settings > Edit environment variables for your account > User variables for 'user' > Path > Edit. This allows you to run MinGW from Powershell, VS Code, etc. The value of this PATH is usually C:\\msys64\\mingw64\\bin .","title":"For Windows"},{"location":"contribute/code/building-shards/#clone-the-shards-repo","text":"You'd normally clone the Shards repository locally ( git clone ... ), checkout the branch you want to work with ( git checkout ... ), and pull the latest changes to your machine ( git pull ). But since the Shards repository contains submodules (links to external repositories), you also have to pull the latest changes for these submodules (including nested submodules). This can be done with the following command (to be run every time you want to build the project). git submodule update --init --recursive","title":"Clone the Shards repo"},{"location":"contribute/code/building-shards/#set-up-the-rust-toolchain","text":"Install and switch to the Rust GNU toolchain with the following rustup commands (from any terminal). Command Output # Windows rustup toolchain install nightly rustup default nightly-x86_64-pc-windows-gnu # Ubuntu (WSL) rustup install nightly rustup default nightly C:\\Users\\saten>rustup default nightly-x86_64-pc-windows-gnu info: syncing channel updates for 'nightly-x86_64-pc-windows-gnu' info: latest update on 2022-01-20, rust version 1.58.1 (db9d1b20b 2022-01-20) info: downloading component 'cargo' info: downloading component 'clippy' info: downloading component 'rust-docs' 18.8 MiB / 18.8 MiB (100 %) 9.4 MiB/s in 2s ETA: 0s . . . info: installing component 'rustfmt' info: default toolchain set to 'nightly-x86_64-pc-windows-gnu' nightly-x86_64-pc-windows-gnu installed - rust 1.58.1 (db9d1b20b 2022-01-20) C:\\Users\\saten> When adding rust targets, ensure they're installed for nightly toolchain. For example to add the target x86_64-pc-windows-gnu run the following command. Command Output # Windows rustup +nightly target add x86_64-pc-windows-gnu # Ubuntu (WSL) rustup target add wasm32-unknown-unknown --toolchain nightly info: downloading component 'rust-std' for 'x86_64-pc-windows-gnu' info: installing component 'rust-std' for 'x86_64-pc-windows-gnu' 24.5 MiB / 24.5 MiB (100 %) 6.0 MiB/s in 4s ETA: 0s","title":"Set up the RUST toolchain"},{"location":"contribute/code/building-shards/#update-system-packages","text":"You should update your system packages frequently and preferably every time you want to build the project.","title":"Update system packages"},{"location":"contribute/code/building-shards/#windows","text":"You'll need to run these commands in a MinGW terminal. To get to this terminal go to the Windows start menu, search for 'MSYS2 MinGW' and click the version appropriate for your machine (x86 or x64). Update the Rust packages with rustup (works with Windows, Mac, and Linux). rustup update Next, update other packages with pacman . Note pacman comes preinstalled as part of MSYS2 on Windows. For Mac you can get it here or use the pre-installed package manager, Homebrew . Sync, refresh, and update all local packages that have a newer version available. Command Output pacman -Syu --noconfirm $ pacman -Syu :: Synchronizing package databases... mingw32 805.0 KiB mingw32.sig 438.0 B mingw64 807.9 KiB mingw64.sig 438.0 B msys 289.3 KiB msys.sig 438.0 B :: Starting core system upgrade... . . . Restart the MinGW terminal (if needed) and install the required build dependencies with this command (replace the w64-x86_64 as appropriate for your target OS/machine). Command Output pacman -Sy --needed --noconfirm base-devel mingw-w64-x86_64-toolchain mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang mingw-w64-x86_64-lld wget :: Synchronizing package databases... warning: base-devel-2022.01-1 is up to date -- skipping warning: mingw-w64-x86_64-binutils-2.37-4 is up to date -- skipping warning: mingw-w64-x86_64-crt-git-9.0.0.6373.5be8fcd83-1 is up to date -- skipping . . . (13/15) upgrading mingw-w64-x86_64-clang [#####################] 100% (14/15) upgrading mingw-w64-x86_64-lld [#####################] 100% (15/15) upgrading wget [#####################] 100% :: Running post-transaction hooks... (1/1) Updating the info directory file...","title":"Windows"},{"location":"contribute/code/building-shards/#ubuntu-wsl","text":"Update the Rust packages with rustup (works with Windows, Mac, and Linux). rustup update Next, update packages and install dependencies. Command sudo apt update sudo apt install -y build-essential git cmake g++ wget clang ninja-build valgrind xorg-dev libdbus-1-dev libssl-dev lcov ca-certificates","title":"Ubuntu (WSL)"},{"location":"contribute/code/building-shards/#build-run-the-project","text":"","title":"Build &amp; run the project"},{"location":"contribute/code/building-shards/#bootstrap-the-project","text":"Continuing with the MinGW terminal (or any terminal on Linux), navigate to Shards root directory, and run the bootstrap shell script (to be run only once, when you build the project for the first time). Windows Mac/Linux Output ./bootstrap bash bootstrap # or ./bootstrap Using SHARDS_ROOT=/c/Users/saten/Desktop/code/shards /c/Users/saten/Desktop/code/shards/deps /c/Users/saten/Desktop/code/shards Setting up dependencies /c/Users/saten/Desktop/code/shards Setting up tools /c/Users/saten/Desktop/code/shards/src/tools /c/Users/saten/Desktop/code/shards -- Build spdlog: 1.8.5 -- Build type: Release -- Configuring done -- Generating done -- Build files have been written to: C:/Users/saten/Desktop/code/shards/src/tools/build [1/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/stdout_sinks.cpp.obj [2/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/color_sinks.cpp.obj [3/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/fmt.cpp.obj [4/6] Building CXX object deps/spdlog/CMakeFiles/spdlog.dir/src/spdlog.cpp.obj [5/6] Linking CXX static library deps\\spdlog\\libspdlog.a [6/6] Linking CXX executable bin\\bin2c.exe /c/Users/saten/Desktop/code/shards","title":"Bootstrap the project"},{"location":"contribute/code/building-shards/#build-the-project","text":"Go to Shards root and create a build directory (if it doesn't already exist) and navigate into it. mkdir build cd build You need to run the following two commands every time you want to build the project. Configure the build with cmake , # Windows and Linux (WSL) cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug .. Release mode build In case you need less verbose script execution logs, build Shards in release mode (instead of the debug mode) by using the option -DCMAKE_BUILD_TYPE=Release .. then build the target with ninja ninja shards Build with formatting (useful for pull requests) Formatting the source is required when raising a PR (for contributing a change). You can do it simply by running ninja format; ninja shards The build ends with a successful linking of the Shards executable (shards.exe). Fix build errors If your build fails due to target/file errors navigate out of the build folder, run cargo clean , then cd build , followed by ninja clean , and/or delete the target folder and then rebuild. The build can also fail if your software packages or repository submodules ( /shards/deps/ ) are out-of-date. To resolve this update the specific software package as given here and pull the submodules again via git submodule update --init --recursive . Note When generating the Rust bindings during compilation, the file rust/src/shardsc.rs might be updated automatically. These changes should not be pushed upstream unless you're modifying certain core files for build-target architecture changes (which is very rare). Hence, use the git command git update-index --skip-worktree rust/src/shardsc.rs to let git ignore changes to this file.","title":"Build the project"},{"location":"contribute/code/building-shards/#verify-build-and-run","text":"To verify your build was successful create an empty script file ( .edn) in the /build folder, populate it with the Script code , and execute the Run command * from the /build folder. Script code Run command Script result (defmesh main) (defloop test (Msg \"Hello World\")) (schedule main test) (run main 1 1) ./shards <script-filename.edn> [info] [2022-05-24 06:09:39.293] [T-3196] [logging.cpp::98] [test] Hello World If you see Hello World printed on your screen (the Script result ) your build was successful. You can also configure the Run Code button on VS Code (arrow/triangle on the top right-hand corner of the code-editor) to run Shards scripts. Install the VS Code code-runner extension Locate the code-runner.executorMap parameter to open in settings.json (VS Code > File > Preferences > Settings > search for code-runner.executorMap > click 'Edit in settings.json') In the settings.json file set the value of the code-runner.excutorMap to point to build\\\\shards.exe for clojure . You can also add a second entry setting code-runner.runInTerminal to true if you want the script output displayed in the Terminal tab of your terminal (instead of in the Output tab, which is the default). \"code-runner.executorMap\": { \"clojure\": \"build\\\\shards.exe\" \"code-runner.runInTerminal\": true }, Now open your Shards script file and click the Run Code button. The script will be executed and you should see the script's result in your terminal.","title":"Verify build and run"},{"location":"contribute/code/building-shards/#build-for-web-assembly","text":"To create a Web Assembly (WASM) build, first clone the Emscripten SDK repo. git clone https://github.com/emscripten-core/emsdk.git Use a mingw64.exe terminal to navigate to the emsdk directory, cd emsdk and then do a git pull to get the latest tools from GitHub (not required the first time you clone the git repository). git pull Update the SDK tools to the latest version. Windows Mac/Linux emsdk install latest ./emsdk install latest Activate the latest SDK for the current user. Windows Mac/Linux emsdk activate latest ./emsdk activate latest Activate the PATH/ environment variables for the current terminal session. Windows Mac/Linux emsdk_env.bat source emsdk_env.sh Open a Windows or VS Code terminal and navigate to the Shards directory. Run the following commands in sequence to create and link the Web Assembly build. mkdir build-wasm cd build-wasm cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=$EMSDK/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake .. ninja format; ninja shards Refer to the official Emscripten SDK documentation for more details on building for Web Assembly.","title":"Build for Web Assembly"},{"location":"contribute/code/building-shards/#appendix-a-valid-cmake-targets","text":"You may also build for targets other than shards . This section gives the complete list of supported cmake targets.","title":"Appendix A - Valid cmake targets"},{"location":"contribute/code/building-shards/#build-targets","text":"shards - Builds shards. the runtime + lisp interpreter. shards-dll - Builds shards as a dynamic library. shards-static - Builds shards as a static library. shards-core-shared - Builds the shards runtime as a dynamic library. shards-core-static - Builds the shards runtime as a static library. shards-extra - Builds the shards-extra library containing the shards inside src/extra. cargo-shards-rust - Builds the rust project inside the rust folder.","title":"Build Targets"},{"location":"contribute/code/building-shards/#formatting-targets","text":"format - Runs clang-format on a list of files defined in cmake/Tidy.cmake. tidy - Runs clang-tidy on a list of files defined in cmake/Tidy.cmake.","title":"Formatting targets"},{"location":"contribute/code/building-shards/#test-targets","text":"These contain tests written in c++ for shards (separate from the edn scripts). test_extra - C++ Tests for extra shards. test_gfx - C++ Tests for graphics/rendering. test_runtime - C++ Tests for the shards runtime.","title":"Test targets"},{"location":"contribute/code/building-shards/#graphics-targets","text":"gfx - The graphics library. gfx-sandbox - Graphics test environment. gfx_imgui - ImGui backend library. gfx_texture_file - Texture loading utilities. cargo-wgpu-native - Builds the rust project inside src/gfx/wgpu-native.","title":"Graphics targets"},{"location":"contribute/code/getting-started/","text":"Getting started \u00b6 Stack components \u00b6 The Fragcolor ecosystem has a few primary components. Shards open-scripting programming language Hasten creativity engine (to build apps, games, and open worlds) Clamor protocol and networking stack To contribute code to any of the above projects, you'll first need to set up a development environment. Development environment \u00b6 Setup git & GitHub \u00b6 To install git on your machine (for Windows, Linux, and Mac), refer to the git installation section. You can download/ clone the code repository via the HTTPS protocol. But you'll need an active GitHub account to fork the repository or contribute to it. Note If you're new to git or GitHub read the Contributing changes section. This section covers these topics and applies to both code and documentation contributions. Get a code editor \u00b6 Although you can use any code editor, we recommend Visual Studio Code (VS Code). You can download and install it from here . Download the appropriate installation file for your platform and follow the on-screen instructions. Install & setup C++ \u00b6 If you're using VS Code, you can set up C++ (and the appropriate compiler for your operating system) by referring to Microsoft's official documentation. C++ and GCC (MinGW) for Windows C++ and GCC for Linux C++ and Clang/ LLVM for Mac Other code editors For other code editors, refer to the official C++ installation documentation . Install & setup Rust \u00b6 Refer to the official Rust documentation to install Rust on your machine. After installation, you can set up Rust to work with VS Code for Windows , Linux , or Mac , as needed. Before attempting to build a Rust project, ensure that you've covered the following development dependencies: Get latest package information sudo apt-get update Install the rust gcc toolchain sudo apt install build-essential Install clang sudo apt install clang Install the rust wasm toolchain rustup target add wasm32-unknown-unknown --toolchain nightly In our projects we use the nightly version of the Rust tools. Since the nightly build is updated every week, you should run the following update command weekly as well: rustup update To switch from the stable build to the nightly build, use: rustup default nightly And to switch back to the stable build, use: rustup default stable WSL for Windows If you're using Windows you might want to check out WSL for a Linux-like development experience. Get VS Code extensions \u00b6 Here are a few VS Code extensions that we recommend you should check out: C/C++ by Microsoft Better TOML by bungcip Calva by Better than Tomorrow CMake by twxs CMake Tools by Microsoft YAML by Red Hat Build a project from sources \u00b6 Now you can pick up a project you'd like to contribute to and build it from the sources. For example, Building Shards . Note For more details refer to the relevant project's README file.","title":"Getting started"},{"location":"contribute/code/getting-started/#getting-started","text":"","title":"Getting started"},{"location":"contribute/code/getting-started/#stack-components","text":"The Fragcolor ecosystem has a few primary components. Shards open-scripting programming language Hasten creativity engine (to build apps, games, and open worlds) Clamor protocol and networking stack To contribute code to any of the above projects, you'll first need to set up a development environment.","title":"Stack components"},{"location":"contribute/code/getting-started/#development-environment","text":"","title":"Development environment"},{"location":"contribute/code/getting-started/#setup-git-github","text":"To install git on your machine (for Windows, Linux, and Mac), refer to the git installation section. You can download/ clone the code repository via the HTTPS protocol. But you'll need an active GitHub account to fork the repository or contribute to it. Note If you're new to git or GitHub read the Contributing changes section. This section covers these topics and applies to both code and documentation contributions.","title":"Setup git &amp; GitHub"},{"location":"contribute/code/getting-started/#get-a-code-editor","text":"Although you can use any code editor, we recommend Visual Studio Code (VS Code). You can download and install it from here . Download the appropriate installation file for your platform and follow the on-screen instructions.","title":"Get a code editor"},{"location":"contribute/code/getting-started/#install-setup-c","text":"If you're using VS Code, you can set up C++ (and the appropriate compiler for your operating system) by referring to Microsoft's official documentation. C++ and GCC (MinGW) for Windows C++ and GCC for Linux C++ and Clang/ LLVM for Mac Other code editors For other code editors, refer to the official C++ installation documentation .","title":"Install &amp; setup C++"},{"location":"contribute/code/getting-started/#install-setup-rust","text":"Refer to the official Rust documentation to install Rust on your machine. After installation, you can set up Rust to work with VS Code for Windows , Linux , or Mac , as needed. Before attempting to build a Rust project, ensure that you've covered the following development dependencies: Get latest package information sudo apt-get update Install the rust gcc toolchain sudo apt install build-essential Install clang sudo apt install clang Install the rust wasm toolchain rustup target add wasm32-unknown-unknown --toolchain nightly In our projects we use the nightly version of the Rust tools. Since the nightly build is updated every week, you should run the following update command weekly as well: rustup update To switch from the stable build to the nightly build, use: rustup default nightly And to switch back to the stable build, use: rustup default stable WSL for Windows If you're using Windows you might want to check out WSL for a Linux-like development experience.","title":"Install &amp; setup Rust"},{"location":"contribute/code/getting-started/#get-vs-code-extensions","text":"Here are a few VS Code extensions that we recommend you should check out: C/C++ by Microsoft Better TOML by bungcip Calva by Better than Tomorrow CMake by twxs CMake Tools by Microsoft YAML by Red Hat","title":"Get VS Code extensions"},{"location":"contribute/code/getting-started/#build-a-project-from-sources","text":"Now you can pick up a project you'd like to contribute to and build it from the sources. For example, Building Shards . Note For more details refer to the relevant project's README file.","title":"Build a project from sources"},{"location":"contribute/docs/contributing-changes/","text":"Contributing changes \u00b6 Fragcolor documentation exists under the /docs folder of the Shards repository. This guide will get you started with contributing documentation changes to Fragcolor projects. We'll use the GitHub Desktop (GD) to deal with git as GD is easier to use than the git command line. Also, all these steps are valid for code contributions too. For comprehensive coverage of git/ GitHub workflow, check out GitHub's excellent Quickstart Tutorial . Clone the Repo \u00b6 To begin, you'll need a copy of the project's repository on your local machine. Go to the repository's GitHub page. Click the 'Code' button on the right, select HTTPS (under the heading 'Clone'), and copy the git repository path. Open GD and choose the option 'Clone a repository from the Internet...' Choose the 3rd tab (URL) on the window that opens, and paste the copied git repository URL in the first input box. The second input box is the local path where git will clone your repository. You can change this as desired. Cloning might take a couple of minutes (depending on the size of the repository). After it completes, you'll be able to view the repository files on your local system. Create a branch \u00b6 You will need to create a new branch from the main/ default branch to hold your changes. Never work on the main branch of the repository; always create a new branch for your changes. You can create a new branch using GD. Click the 'Current Branch' dropdown to show the available branches for this repository. Now click on 'New Branch' button on the right-hand side. A modal will pop up asking for the new branch's name. This modal also explains on what branch is this new branch based. Ensure that the source branch is the default branch of the repository. In this case, it's 'develop'. Click on 'Create Branch'. Publish this local branch to the project's remote (from where we cloned the repository). If you don't have write access to a project repository, you can't push your changes to it. So, GD will ask you to fork (create a copy of) the target repository instead. Forking will put a copy of the original repository in your GitHub account. You can now push your local branch/ changes to this fork repository in your GitHub account. Fork the repository. After forking, choose 'To contribute to the parent project' option. Publish the new branch to your fork repository. On GD, you will now be able to see uncommitted changes (if any) in your local branch. Make & test changes \u00b6 Run all terminal commands from the project folder that contains MkDocs.yml . For the Shards repository, this folder is ...shards/docs ). MkDocs can build and serve the documentation website locally while you're making changes. The served pages reflect your documentation changes in real-time (also called hot reloading). Before starting the MkDocs live-preview server, we need to install the required plugins. MkDocs plugins get registered in the MkDocs.yml file against the keyword 'plugins'. Here, we have only one plugin: awesome-pages . Install MkDocs plugins using the pip install mkdocs-awesome-pages-plugin command from the terminal. Command Start the MkDocs live-preview server with the mkdocs serve command. Once the server is running, the terminal will display the locally served website's URL path. Command Result Navigate to this path in your local browser to access the served site. Now we're ready to make some changes! As an exercise, let's change the case of the header's title text. Change 'Fragcolor documentation' (sentence case) to 'Fragcolor Documentation' (title case). Save the edit. Before the change: After the change: And now, let's go to our local URL to preview this change. Commit & push changes \u00b6 GD will now show a summary of changes in this new local branch. Pink color highlights (marked with - ) denote deleted lines. Blue color highlights (marked with + ) denote added lines. Commit (save) your changes to the local repository branch. To commit, click the 'Commit to LOCAL-REPO-NAME' in the bottom left-hand corner of GD. GD will ask you to add a summary (commit message) and a description of the changes. Add the commit message summary/ description and click on the 'Commit to ...' button below these fields. This commit saves the changes to your new branch locally (in your fork). Now, click on the 'Push origin' button on the right-hand side. This action pushes your branch's local commits to your fork on GitHub (i.e., the origin remote). At this point, GD will show that no local changes exist. This is because there are no outstanding changes on our local that need to be pushed to remote origin. GD will now prompt you to raise a Pull Request. You'll see the same message/ prompt on the GitHub page of your (forked) remote origin repository. You can start the process of raising a PR from either GD or GitHub website. In either case, you'll end up on the GitHub website's PR page, as explained in the next section. Raise a pull request \u00b6 A Pull Request (or PR) merges/ combines the changes of the PR branch into the target (main) branch. PRs may be raised between branches of the same repository from a fork to the original repository. Here we are dealing with the latter. Raise a PR by clicking 'Create Pull Request' in GD. Or, you can click 'Compare & pull request' on your branch/ repository's GitHub page. In both cases, you'll end up on the 'Open a pull request' page on GitHub. Fill in the PR title and message. Then click the 'Create pull request' button on the bottom right-hand corner. This action will create a Pull Request and route it to a reviewer. Every PR gets a unique URL. This URL tracks the review discussion between the contributor and the reviewer(s). It also has details like files changed, commit messages, etc. Every PR gets routed to a reviewer or a maintainer (of that repository) for a review. If the reviewer agrees with the changes, they'll approve and merge the PR into the target branch. If they need further changes, they will discuss via the comments section in the PR. It's a good practice to delete your branches for merged/ closed PRs.","title":"Contributing changes"},{"location":"contribute/docs/contributing-changes/#contributing-changes","text":"Fragcolor documentation exists under the /docs folder of the Shards repository. This guide will get you started with contributing documentation changes to Fragcolor projects. We'll use the GitHub Desktop (GD) to deal with git as GD is easier to use than the git command line. Also, all these steps are valid for code contributions too. For comprehensive coverage of git/ GitHub workflow, check out GitHub's excellent Quickstart Tutorial .","title":"Contributing changes"},{"location":"contribute/docs/contributing-changes/#clone-the-repo","text":"To begin, you'll need a copy of the project's repository on your local machine. Go to the repository's GitHub page. Click the 'Code' button on the right, select HTTPS (under the heading 'Clone'), and copy the git repository path. Open GD and choose the option 'Clone a repository from the Internet...' Choose the 3rd tab (URL) on the window that opens, and paste the copied git repository URL in the first input box. The second input box is the local path where git will clone your repository. You can change this as desired. Cloning might take a couple of minutes (depending on the size of the repository). After it completes, you'll be able to view the repository files on your local system.","title":"Clone the Repo"},{"location":"contribute/docs/contributing-changes/#create-a-branch","text":"You will need to create a new branch from the main/ default branch to hold your changes. Never work on the main branch of the repository; always create a new branch for your changes. You can create a new branch using GD. Click the 'Current Branch' dropdown to show the available branches for this repository. Now click on 'New Branch' button on the right-hand side. A modal will pop up asking for the new branch's name. This modal also explains on what branch is this new branch based. Ensure that the source branch is the default branch of the repository. In this case, it's 'develop'. Click on 'Create Branch'. Publish this local branch to the project's remote (from where we cloned the repository). If you don't have write access to a project repository, you can't push your changes to it. So, GD will ask you to fork (create a copy of) the target repository instead. Forking will put a copy of the original repository in your GitHub account. You can now push your local branch/ changes to this fork repository in your GitHub account. Fork the repository. After forking, choose 'To contribute to the parent project' option. Publish the new branch to your fork repository. On GD, you will now be able to see uncommitted changes (if any) in your local branch.","title":"Create a branch"},{"location":"contribute/docs/contributing-changes/#make-test-changes","text":"Run all terminal commands from the project folder that contains MkDocs.yml . For the Shards repository, this folder is ...shards/docs ). MkDocs can build and serve the documentation website locally while you're making changes. The served pages reflect your documentation changes in real-time (also called hot reloading). Before starting the MkDocs live-preview server, we need to install the required plugins. MkDocs plugins get registered in the MkDocs.yml file against the keyword 'plugins'. Here, we have only one plugin: awesome-pages . Install MkDocs plugins using the pip install mkdocs-awesome-pages-plugin command from the terminal. Command Start the MkDocs live-preview server with the mkdocs serve command. Once the server is running, the terminal will display the locally served website's URL path. Command Result Navigate to this path in your local browser to access the served site. Now we're ready to make some changes! As an exercise, let's change the case of the header's title text. Change 'Fragcolor documentation' (sentence case) to 'Fragcolor Documentation' (title case). Save the edit. Before the change: After the change: And now, let's go to our local URL to preview this change.","title":"Make &amp; test changes"},{"location":"contribute/docs/contributing-changes/#commit-push-changes","text":"GD will now show a summary of changes in this new local branch. Pink color highlights (marked with - ) denote deleted lines. Blue color highlights (marked with + ) denote added lines. Commit (save) your changes to the local repository branch. To commit, click the 'Commit to LOCAL-REPO-NAME' in the bottom left-hand corner of GD. GD will ask you to add a summary (commit message) and a description of the changes. Add the commit message summary/ description and click on the 'Commit to ...' button below these fields. This commit saves the changes to your new branch locally (in your fork). Now, click on the 'Push origin' button on the right-hand side. This action pushes your branch's local commits to your fork on GitHub (i.e., the origin remote). At this point, GD will show that no local changes exist. This is because there are no outstanding changes on our local that need to be pushed to remote origin. GD will now prompt you to raise a Pull Request. You'll see the same message/ prompt on the GitHub page of your (forked) remote origin repository. You can start the process of raising a PR from either GD or GitHub website. In either case, you'll end up on the GitHub website's PR page, as explained in the next section.","title":"Commit &amp; push changes"},{"location":"contribute/docs/contributing-changes/#raise-a-pull-request","text":"A Pull Request (or PR) merges/ combines the changes of the PR branch into the target (main) branch. PRs may be raised between branches of the same repository from a fork to the original repository. Here we are dealing with the latter. Raise a PR by clicking 'Create Pull Request' in GD. Or, you can click 'Compare & pull request' on your branch/ repository's GitHub page. In both cases, you'll end up on the 'Open a pull request' page on GitHub. Fill in the PR title and message. Then click the 'Create pull request' button on the bottom right-hand corner. This action will create a Pull Request and route it to a reviewer. Every PR gets a unique URL. This URL tracks the review discussion between the contributor and the reviewer(s). It also has details like files changed, commit messages, etc. Every PR gets routed to a reviewer or a maintainer (of that repository) for a review. If the reviewer agrees with the changes, they'll approve and merge the PR into the target branch. If they need further changes, they will discuss via the comments section in the PR. It's a good practice to delete your branches for merged/ closed PRs.","title":"Raise a pull request"},{"location":"contribute/docs/documenting-the-api/","text":"Documenting the API \u00b6 Note that as of 2021/10/25, the API Documentation for the shards is extracted from the shards binary using the infos-docs.edn script. ./src/build/shards src/tests/infos-docs.edn","title":"Documenting the API"},{"location":"contribute/docs/documenting-the-api/#documenting-the-api","text":"Note that as of 2021/10/25, the API Documentation for the shards is extracted from the shards binary using the infos-docs.edn script. ./src/build/shards src/tests/infos-docs.edn","title":"Documenting the API"},{"location":"contribute/docs/getting-started/","text":"Getting started \u00b6 Documentation requirements \u00b6 At Fragcolor, we use the following to generate and maintain the documentation website . MkDocs & MkDocs Material - Documentation static site generator Python - Prerequisite for MkDocs & MkDocs Material git & GitHub - Document version control & contribution workflow VS Code - Code & document editor We follow the Microsoft Style Guide to standardize our documentation. Documentation build environment \u00b6 Git & GitHub \u00b6 Git is a version control system that we can use to track and manage changes to our markdown files. Git comes pre-installed on most Mac & Linux machines. If it's not on your machine, you can get the relevant git package here . For Windows, download and install git from here . Choose your favorite editor as the default git editor. Git will use this editor when there's a need to resolve merge conflicts. Keep the other installation defaults. You'll can download/ clone the documentation repository via the HTTPS protocol. But you'll need an active GitHub account to fork the documentation repository or contribute to it. Python \u00b6 Python is a pre-requisite for both MkDocs and MkDocs Material. Python comes pre-installed on most Mac & Linux machines. If it's not on your machine you can get the relevant Python package here . For windows, you can grab the latest Python release installer here . Download the installer and follow the on-screen instructions after starting the installation. Remember to add Python to Path during the installation. Disable the Path Length Limit so that your installation can use nested paths. Keep the other default installation settings. Type Python or Py in the terminal to confirm Python installation and version. Command Result Python Type where py in the terminal to see the Python installation path. Command Result where py Type pip to confirm PIP installation and version. PIP is Python Installation Package and installs as part of Python. Command Result pip For more details, refer to the official Python installation documentation . MkDocs \u00b6 MkDocs allows you to write documentation in markdown and then serve it as a static site. Install MkDocs using the pip tool. Command Result pip install mkdocs Then you can check the version of MkDocs installation by using the following command. Command Result mkdocs --version For more details, refer to the official MkDocs installation documentation . MkDocs Material \u00b6 MkDocs Material is a Material Design theme for MkDocs. Install MkDocs Material using the 'pip tool. Command Result pip install mkdocs-material For more details, refer to the official MkDocs getting-started documentation .","title":"Getting started"},{"location":"contribute/docs/getting-started/#getting-started","text":"","title":"Getting started"},{"location":"contribute/docs/getting-started/#documentation-requirements","text":"At Fragcolor, we use the following to generate and maintain the documentation website . MkDocs & MkDocs Material - Documentation static site generator Python - Prerequisite for MkDocs & MkDocs Material git & GitHub - Document version control & contribution workflow VS Code - Code & document editor We follow the Microsoft Style Guide to standardize our documentation.","title":"Documentation requirements"},{"location":"contribute/docs/getting-started/#documentation-build-environment","text":"","title":"Documentation build environment"},{"location":"contribute/docs/getting-started/#git-github","text":"Git is a version control system that we can use to track and manage changes to our markdown files. Git comes pre-installed on most Mac & Linux machines. If it's not on your machine, you can get the relevant git package here . For Windows, download and install git from here . Choose your favorite editor as the default git editor. Git will use this editor when there's a need to resolve merge conflicts. Keep the other installation defaults. You'll can download/ clone the documentation repository via the HTTPS protocol. But you'll need an active GitHub account to fork the documentation repository or contribute to it.","title":"Git &amp; GitHub"},{"location":"contribute/docs/getting-started/#python","text":"Python is a pre-requisite for both MkDocs and MkDocs Material. Python comes pre-installed on most Mac & Linux machines. If it's not on your machine you can get the relevant Python package here . For windows, you can grab the latest Python release installer here . Download the installer and follow the on-screen instructions after starting the installation. Remember to add Python to Path during the installation. Disable the Path Length Limit so that your installation can use nested paths. Keep the other default installation settings. Type Python or Py in the terminal to confirm Python installation and version. Command Result Python Type where py in the terminal to see the Python installation path. Command Result where py Type pip to confirm PIP installation and version. PIP is Python Installation Package and installs as part of Python. Command Result pip For more details, refer to the official Python installation documentation .","title":"Python"},{"location":"contribute/docs/getting-started/#mkdocs","text":"MkDocs allows you to write documentation in markdown and then serve it as a static site. Install MkDocs using the pip tool. Command Result pip install mkdocs Then you can check the version of MkDocs installation by using the following command. Command Result mkdocs --version For more details, refer to the official MkDocs installation documentation .","title":"MkDocs"},{"location":"contribute/docs/getting-started/#mkdocs-material","text":"MkDocs Material is a Material Design theme for MkDocs. Install MkDocs Material using the 'pip tool. Command Result pip install mkdocs-material For more details, refer to the official MkDocs getting-started documentation .","title":"MkDocs Material"},{"location":"contribute/wiki/","text":"Contributing to the wiki \u00b6 A wiki houses community-contributed knowledge, such as code recipes, etc. You can access a project's wiki by suffixing '/wiki' to the URL of that project's code repository. For example, the Shards wiki is at https://github.com/fragcolor-xyz/shards/wiki . Request collaborator access \u00b6 To edit a project's wiki, you'll need collaborator access to that project's repository. Open an issue in the repository and tag the project maintainer to request this access. Once you have access, you'll see the Edit and New Page buttons on the upper right-hand side of the wiki page. Edit page \u00b6 Use the right-hand side Table Of Contents to select a page you want to edit. Click the Edit button to start editing the page. You can change the Edit mode by clicking the Markdown dropdown. The Preview tab shows you what your formatted document would look like. Under the Edit message field, there's an option to add a commit-message (something that explains your changes). New page \u00b6 Click the New Page button to add your content. Editing and saving changes work just as they do for an existing page.","title":"Contributing to the wiki"},{"location":"contribute/wiki/#contributing-to-the-wiki","text":"A wiki houses community-contributed knowledge, such as code recipes, etc. You can access a project's wiki by suffixing '/wiki' to the URL of that project's code repository. For example, the Shards wiki is at https://github.com/fragcolor-xyz/shards/wiki .","title":"Contributing to the wiki"},{"location":"contribute/wiki/#request-collaborator-access","text":"To edit a project's wiki, you'll need collaborator access to that project's repository. Open an issue in the repository and tag the project maintainer to request this access. Once you have access, you'll see the Edit and New Page buttons on the upper right-hand side of the wiki page.","title":"Request collaborator access"},{"location":"contribute/wiki/#edit-page","text":"Use the right-hand side Table Of Contents to select a page you want to edit. Click the Edit button to start editing the page. You can change the Edit mode by clicking the Markdown dropdown. The Preview tab shows you what your formatted document would look like. Under the Edit message field, there's an option to add a commit-message (something that explains your changes).","title":"Edit page"},{"location":"contribute/wiki/#new-page","text":"Click the New Page button to add your content. Editing and saving changes work just as they do for an existing page.","title":"New page"},{"location":"functions/","text":"About built-in functions \u00b6 Collections Macros Operators Standard Output Strings Values","title":"About built-in functions"},{"location":"functions/#about-built-in-functions","text":"Collections Macros Operators Standard Output Strings Values","title":"About built-in functions"},{"location":"functions/collections/","text":"Collections \u00b6 assoc \u00b6 Code 1 2 3 4 ( def _args ( eval ( quasiquote ( assoc {} ~@ *command-line-args* )))) concat \u00b6 Code 1 conj \u00b6 Code 1 cons \u00b6 Constructs a list recursively using the pattern (cons element rest-of-list) . Code Result 1 ( cons 1 ( cons 2 ( cons 3 nil ))) (1 2 3) contains? \u00b6 Checks whether a hashmap contains a record with the given key. Code 1 2 3 ( if ( contains? _args \"--file\" ) ( get _args \"--file\" ) \"\" ) count \u00b6 Counts the number of elements in a list, sequence or vector. Code 1 2 3 ( if ( > ( count parameters ) 0 ) \"at least one parameter\" \"no parameters\" ) dissoc \u00b6 Code 1 empty? \u00b6 Checks whether a list, sequence or vector has no elements. Code 1 2 3 ( if ( empty? parameters ) \"no parameters\" \"at least one parameter\" ) get \u00b6 Gets the value represented by the given key, or nil if not found. Code 1 2 3 ( if ( contains? _args \"--file\" ) ( get _args \"--file\" ) \"\" ) first \u00b6 Code 1 keys \u00b6 Gets a list of all the keys from a hashmap. Code 1 list \u00b6 Code 1 hash-map \u00b6 Code 1 map \u00b6 Code 1 nth \u00b6 Code 1 rest \u00b6 Code 1 reverse \u00b6 Creates a new sequence with the elements in reverse order. Code 1 seq \u00b6 Code 1 vals \u00b6 Gets a list of all the values from a hashmap. Code 1 vector \u00b6 Code 1","title":"Collections"},{"location":"functions/collections/#collections","text":"","title":"Collections"},{"location":"functions/collections/#assoc","text":"Code 1 2 3 4 ( def _args ( eval ( quasiquote ( assoc {} ~@ *command-line-args* ))))","title":"assoc"},{"location":"functions/collections/#concat","text":"Code 1","title":"concat"},{"location":"functions/collections/#conj","text":"Code 1","title":"conj"},{"location":"functions/collections/#cons","text":"Constructs a list recursively using the pattern (cons element rest-of-list) . Code Result 1 ( cons 1 ( cons 2 ( cons 3 nil ))) (1 2 3)","title":"cons"},{"location":"functions/collections/#contains","text":"Checks whether a hashmap contains a record with the given key. Code 1 2 3 ( if ( contains? _args \"--file\" ) ( get _args \"--file\" ) \"\" )","title":"contains?"},{"location":"functions/collections/#count","text":"Counts the number of elements in a list, sequence or vector. Code 1 2 3 ( if ( > ( count parameters ) 0 ) \"at least one parameter\" \"no parameters\" )","title":"count"},{"location":"functions/collections/#dissoc","text":"Code 1","title":"dissoc"},{"location":"functions/collections/#empty","text":"Checks whether a list, sequence or vector has no elements. Code 1 2 3 ( if ( empty? parameters ) \"no parameters\" \"at least one parameter\" )","title":"empty?"},{"location":"functions/collections/#get","text":"Gets the value represented by the given key, or nil if not found. Code 1 2 3 ( if ( contains? _args \"--file\" ) ( get _args \"--file\" ) \"\" )","title":"get"},{"location":"functions/collections/#first","text":"Code 1","title":"first"},{"location":"functions/collections/#keys","text":"Gets a list of all the keys from a hashmap. Code 1","title":"keys"},{"location":"functions/collections/#list","text":"Code 1","title":"list"},{"location":"functions/collections/#hash-map","text":"Code 1","title":"hash-map"},{"location":"functions/collections/#map","text":"Code 1","title":"map"},{"location":"functions/collections/#nth","text":"Code 1","title":"nth"},{"location":"functions/collections/#rest","text":"Code 1","title":"rest"},{"location":"functions/collections/#reverse","text":"Creates a new sequence with the elements in reverse order. Code 1","title":"reverse"},{"location":"functions/collections/#seq","text":"Code 1","title":"seq"},{"location":"functions/collections/#vals","text":"Gets a list of all the values from a hashmap. Code 1","title":"vals"},{"location":"functions/collections/#vector","text":"Code 1","title":"vector"},{"location":"functions/macros/","text":"Macros \u00b6 def \u00b6 Defines an alias for a value. This value may be data, the result of an expression, or the return value of a shard. Code 1 2 3 4 5 6 7 8 9 10 11 12 ;; define an alias for data ( def sequence1 [ 2 4 6 8 ]) ( def string1 \"I'm a string\" ) ;; define an alias for an evaluated expression result ( def xresult ( * 2 4 )) ;; define an alias for a shard's return value ( def my-wire ( Wire \"my-wire\" )) ( def my-looped-wire ( Wire \"my-looped-wire\" :Looped )) ( def Root ( Mesh )) ( def - Math.Subtract ) See also defwire defloop defmesh def! \u00b6 Defines an alias. Code 1 defshards \u00b6 Defines new shards that can be grouped together and inserted into an existing wire program. Note What's a shard ? A defshards shard looks structurally similar to a function (see defn ), but unlike a defn , it can contain multiple shards in its body without needing to use -> . During the execution phase defshards is physically replaced by it's inner shards wherever it's invoked. Code 1 2 3 ( defshards MsgParms [ input ] ( Msg \"My name is\" ) ( Msg input )) Just like a function a defshards shard can be invoked by name and can process input parameters. Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ( defshards MsgParms [ input ] ( Msg \"My name is\" ) ( Msg input )) ( defwire mywire ( MsgParms \"Shards\" )) ( schedule main mywire ) ( run main ) [info] [2022-05-13 15:31:09.231] [T-4796] [logging.cpp::98] [mywire] My name is [info] [2022-05-13 15:31:09.232] [T-4796] [logging.cpp::98] [mywire] Shards (defshards) can be used in place of a (defn) (function declaration) plus (->) (shard-container). See the last two code examples in (defn) for a comparison of these use cases. defwire \u00b6 Defines a new non-looped wire. Code 1 2 3 4 ;; defwire ( defwire my-wire ;; shards here ) Note What's a wire ? (defwire <wire-name>) is actually a shorthand for the more verbose non-looped wire definition: def <wire-name> + Wire \"wire-name\" . Code 1 2 3 4 5 ;; def + Wire ( def my-wire ( Wire \"my-wire\" ;; shards here )) To run a wire you must first schedule it on a mesh. When you run this mesh, all the wires scheduled on it are executed (in the order of scheduling). A mesh will execute a non-looped wire only once (even though the mesh itself may continue running). Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; define a mesh (main) ( defmesh main ) ;; define a non-looped wire (wire-hello) ( defwire wire-hello ( Msg \"Hello World!\" )) ;; define another non-looped wire (wire-bye) ( defwire wire-bye ( Msg \"Goodbye World\" )) ;; schedule the non-looped wires on the mesh ( schedule main wire-hello ) ( schedule main wire-bye ) ;; run all the scheduled wires on the mesh ( run main ) [info] [2022-03-07 20:45:35.681] [T-9044] [logging.cpp::94] [wire-hello] Hello World! [info] [2022-03-07 20:45:35.678] [T-9044] [logging.cpp::94] [wire-bye] Goodbye World defwire can also parse and save the wire's input into a variable. Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ( defwire mywire = .wirevar ;; save mywire input to wirevar .wirevar ( Log \"wire input\" )) ;; log mywire input to screen ( defwire mainwire \"shards\" ( Do mywire )) ;; invoke mywire with an input ( schedule main mainwire ) ( run main ) [trace] [2022-05-12 21:25:49.714] [T-17336] [runtime.cpp::1998] wire mainwire starting [info] [2022-05-12 21:25:49.715] [T-17336] [logging.cpp::53] [mywire] wire input: shards [debug] [2022-05-12 21:25:49.716] [T-17336] [runtime.cpp::2741] Running cleanup on wire: mainwire users count: 0 See also def defloop defn \u00b6 Defines a new function. Code 1 2 3 ( defn fn-name [ fn-params ] ;; function-name followed by input parameters in '[]' ( Msg fn-params ) ;; function body that returns a value ) The function definition consists of the function name followed by its input parameters ( fn-params ), in [] . If there are no input parameters the [] remains empty. Multiple input parameters may be passed as a sequence. The processing statements (value/expression/shards) following the [] is the function's body and its evaluation is the function's return value. A function may return a single or none at all. A function can be invoked by calling it by name and passing its required parameters. Function with no input parameters: Code Result 1 2 3 4 5 6 7 ( defmesh main ) ( defn func [] ( Msg \"I got no parameters\" )) ;; prints string text to screen ( defwire mywire ( func )) ;; function invoked without any parameters ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:04:22.268] [T-1204] [logging.cpp::98] [mywire] I got no parameters Function with one input parameter: Code Result 1 2 3 4 5 6 7 ( defmesh main ) ( defn func [ param ] ( Msg param )) ;; prints the parameter to screen ( defwire mywire ( func \"The only parameter\" )) ;; function invoked with a single parameter ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:03:58.125] [T-21336] [logging.cpp::98] [mywire] The only parameter Function with multiple input parameters: Code Result 1 2 3 4 5 6 7 ( defmesh main ) ( defn func [ param1 param2 ] ( Msg param2 )) ;; prints the 2nd parameter to screen ( defwire mywire ( func \"1st parameter\" \"2nd parameter\" )) ;; function invoked with multiple parameters ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:03:38.570] [T-11468] [logging.cpp::98] [mywire] 2nd parameter A function cannot return multiple values. So if you need to process multiple shards in the function's body then you'll have to either use (defshards) instead of (defn) , Code Result 1 2 3 4 5 6 7 8 9 10 ( defmesh main ) ( defshards MsgParams [ input ] ;; defshards groups multiple shards for processing ( Msg \"name is:\" ) ( Msg input )) ( defn letslog [ name ] ( MsgParams name )) ;; defshards takes function input and returns single value ( defwire mywire ( letslog \"shards\" )) ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:44:51.293] [T-16928] [logging.cpp::98] [mywire] name is: [info] [2022-05-13 14:44:51.294] [T-16928] [logging.cpp::98] [mywire] shards or use (->) to group and process the multiple shards inside the (defn) : Code Result 1 2 3 4 5 6 7 8 9 10 11 ( defmesh main ) ( defn letslog [ name ] ( -> ;; defshards replaced with `->` ( Msg \"name is:\" ) ;; multiple shards can now be written down sequentially ( Msg name ) ) ) ( defwire mywire ( letslog \"shards\" )) ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:47:44.543] [T-21048] [logging.cpp::98] [mywire] name is: [info] [2022-05-13 14:47:44.544] [T-21048] [logging.cpp::98] [mywire] shards See also defshards defmacro! \u00b6 Defines a new macro. Code 1 defmesh \u00b6 Defines a new mesh on which wires can be scheduled and then run. Note What's a mesh ? Code 1 2 ;; defmesh ( defmesh main ) ;; define a mesh named 'main' (defmesh <mesh-name>) is actually a shorthand for the more verbose mesh definition: def <mesh-name> (Mesh) . Code 1 2 ;; def + Mesh ( def main ( Mesh )) ;; define a mesh named 'main' Here's an example that schedules a looped and a non-looped wire on a mesh. Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ;; define a mesh (main) ( defloop wire-hi ;; define a looped wire ( Msg \"Hello World!\" )) ( defwire wire-bye ;; define a non-looped wire ( Msg \"Goodbye World\" )) ( schedule main wire-hi ) ;; schedule looped wire (wire-hi) on this mesh ( schedule main wire-bye ) ;; schedule non-looped wire (wire-hi) on this mesh ( run main ) ;; run all the scheduled wires on this mesh [info] [2022-03-07 22:14:51.730] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.731] [T-14836] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 22:14:51.760] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.776] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.791] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.823] [T-14836] [logging.cpp::94] [wire-hi] Hello World! . . . See also def defloop \u00b6 Defines a new looped wire. Code 1 2 3 4 ;; defloop ( defloop my-loop ;; define a looped wire ;; shards here ) Note What's a wire ? (defloop <looped wire-name) is actually a shorthand for the more verbose looped wire definition: def <looped wire-name> + Wire \"looped wire-name\" . Code 1 2 3 4 5 ;; def + Wire ( def my-loop ( Wire \"my-loop\" :Looped ;; shards here )) For a wire to be executed, it must first be scheduled on a mesh and then that that mesh needs to run. Code Result 1 2 3 4 5 ( defmesh main ) ;; define a mesh ( defloop my-loop ;; define a looped wire ( Msg \"Hello World!\" )) ( schedule main my-loop ) ;; ( run main ) ;; run wires scheduled on this mesh [info] [2022-05-13 09:48:01.692] [T-15068] [logging.cpp::98] [my-loop] Hello World! [info] [2022-05-13 09:48:01.693] [T-15068] [logging.cpp::98] [my-loop] Hello World! [info] [2022-05-13 09:48:01.694] [T-15068] [logging.cpp::98] [my-loop] Hello World! . . . A mesh will continue executing a looped wire till the mesh itself stops running (or the wire execution is stopped via a logic condition). Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ;; define a mesh ( defloop wire-hi ;; define a looped wire (wire-hello) ( Msg \"Hello World!\" )) ( defloop wire-bye ;; define another looped wire (wire-bye) ( Msg \"Goodbye World\" )) ( schedule main wire-hi ) ;; schedule the wire (wire-hi) on the mesh ( schedule main wire-bye ) ;; schedule the wire (wire-bye) on the mesh ( run main ) ;; run all the wires scheduled on this mesh [info] [2022-03-07 22:28:54.682] [T-8432] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:28:54.682] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 22:28:54.715] [T-8432] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:28:54.715] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 22:28:54.731] [T-8432] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:28:54.732] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World . . . See also def defwire","title":"Macros"},{"location":"functions/macros/#macros","text":"","title":"Macros"},{"location":"functions/macros/#def","text":"Defines an alias for a value. This value may be data, the result of an expression, or the return value of a shard. Code 1 2 3 4 5 6 7 8 9 10 11 12 ;; define an alias for data ( def sequence1 [ 2 4 6 8 ]) ( def string1 \"I'm a string\" ) ;; define an alias for an evaluated expression result ( def xresult ( * 2 4 )) ;; define an alias for a shard's return value ( def my-wire ( Wire \"my-wire\" )) ( def my-looped-wire ( Wire \"my-looped-wire\" :Looped )) ( def Root ( Mesh )) ( def - Math.Subtract ) See also defwire defloop defmesh","title":"def"},{"location":"functions/macros/#def_1","text":"Defines an alias. Code 1","title":"def!"},{"location":"functions/macros/#defshards","text":"Defines new shards that can be grouped together and inserted into an existing wire program. Note What's a shard ? A defshards shard looks structurally similar to a function (see defn ), but unlike a defn , it can contain multiple shards in its body without needing to use -> . During the execution phase defshards is physically replaced by it's inner shards wherever it's invoked. Code 1 2 3 ( defshards MsgParms [ input ] ( Msg \"My name is\" ) ( Msg input )) Just like a function a defshards shard can be invoked by name and can process input parameters. Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ( defshards MsgParms [ input ] ( Msg \"My name is\" ) ( Msg input )) ( defwire mywire ( MsgParms \"Shards\" )) ( schedule main mywire ) ( run main ) [info] [2022-05-13 15:31:09.231] [T-4796] [logging.cpp::98] [mywire] My name is [info] [2022-05-13 15:31:09.232] [T-4796] [logging.cpp::98] [mywire] Shards (defshards) can be used in place of a (defn) (function declaration) plus (->) (shard-container). See the last two code examples in (defn) for a comparison of these use cases.","title":"defshards"},{"location":"functions/macros/#defwire","text":"Defines a new non-looped wire. Code 1 2 3 4 ;; defwire ( defwire my-wire ;; shards here ) Note What's a wire ? (defwire <wire-name>) is actually a shorthand for the more verbose non-looped wire definition: def <wire-name> + Wire \"wire-name\" . Code 1 2 3 4 5 ;; def + Wire ( def my-wire ( Wire \"my-wire\" ;; shards here )) To run a wire you must first schedule it on a mesh. When you run this mesh, all the wires scheduled on it are executed (in the order of scheduling). A mesh will execute a non-looped wire only once (even though the mesh itself may continue running). Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; define a mesh (main) ( defmesh main ) ;; define a non-looped wire (wire-hello) ( defwire wire-hello ( Msg \"Hello World!\" )) ;; define another non-looped wire (wire-bye) ( defwire wire-bye ( Msg \"Goodbye World\" )) ;; schedule the non-looped wires on the mesh ( schedule main wire-hello ) ( schedule main wire-bye ) ;; run all the scheduled wires on the mesh ( run main ) [info] [2022-03-07 20:45:35.681] [T-9044] [logging.cpp::94] [wire-hello] Hello World! [info] [2022-03-07 20:45:35.678] [T-9044] [logging.cpp::94] [wire-bye] Goodbye World defwire can also parse and save the wire's input into a variable. Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ( defwire mywire = .wirevar ;; save mywire input to wirevar .wirevar ( Log \"wire input\" )) ;; log mywire input to screen ( defwire mainwire \"shards\" ( Do mywire )) ;; invoke mywire with an input ( schedule main mainwire ) ( run main ) [trace] [2022-05-12 21:25:49.714] [T-17336] [runtime.cpp::1998] wire mainwire starting [info] [2022-05-12 21:25:49.715] [T-17336] [logging.cpp::53] [mywire] wire input: shards [debug] [2022-05-12 21:25:49.716] [T-17336] [runtime.cpp::2741] Running cleanup on wire: mainwire users count: 0 See also def defloop","title":"defwire"},{"location":"functions/macros/#defn","text":"Defines a new function. Code 1 2 3 ( defn fn-name [ fn-params ] ;; function-name followed by input parameters in '[]' ( Msg fn-params ) ;; function body that returns a value ) The function definition consists of the function name followed by its input parameters ( fn-params ), in [] . If there are no input parameters the [] remains empty. Multiple input parameters may be passed as a sequence. The processing statements (value/expression/shards) following the [] is the function's body and its evaluation is the function's return value. A function may return a single or none at all. A function can be invoked by calling it by name and passing its required parameters. Function with no input parameters: Code Result 1 2 3 4 5 6 7 ( defmesh main ) ( defn func [] ( Msg \"I got no parameters\" )) ;; prints string text to screen ( defwire mywire ( func )) ;; function invoked without any parameters ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:04:22.268] [T-1204] [logging.cpp::98] [mywire] I got no parameters Function with one input parameter: Code Result 1 2 3 4 5 6 7 ( defmesh main ) ( defn func [ param ] ( Msg param )) ;; prints the parameter to screen ( defwire mywire ( func \"The only parameter\" )) ;; function invoked with a single parameter ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:03:58.125] [T-21336] [logging.cpp::98] [mywire] The only parameter Function with multiple input parameters: Code Result 1 2 3 4 5 6 7 ( defmesh main ) ( defn func [ param1 param2 ] ( Msg param2 )) ;; prints the 2nd parameter to screen ( defwire mywire ( func \"1st parameter\" \"2nd parameter\" )) ;; function invoked with multiple parameters ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:03:38.570] [T-11468] [logging.cpp::98] [mywire] 2nd parameter A function cannot return multiple values. So if you need to process multiple shards in the function's body then you'll have to either use (defshards) instead of (defn) , Code Result 1 2 3 4 5 6 7 8 9 10 ( defmesh main ) ( defshards MsgParams [ input ] ;; defshards groups multiple shards for processing ( Msg \"name is:\" ) ( Msg input )) ( defn letslog [ name ] ( MsgParams name )) ;; defshards takes function input and returns single value ( defwire mywire ( letslog \"shards\" )) ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:44:51.293] [T-16928] [logging.cpp::98] [mywire] name is: [info] [2022-05-13 14:44:51.294] [T-16928] [logging.cpp::98] [mywire] shards or use (->) to group and process the multiple shards inside the (defn) : Code Result 1 2 3 4 5 6 7 8 9 10 11 ( defmesh main ) ( defn letslog [ name ] ( -> ;; defshards replaced with `->` ( Msg \"name is:\" ) ;; multiple shards can now be written down sequentially ( Msg name ) ) ) ( defwire mywire ( letslog \"shards\" )) ( schedule main mywire ) ( run main ) [info] [2022-05-13 14:47:44.543] [T-21048] [logging.cpp::98] [mywire] name is: [info] [2022-05-13 14:47:44.544] [T-21048] [logging.cpp::98] [mywire] shards See also defshards","title":"defn"},{"location":"functions/macros/#defmacro","text":"Defines a new macro. Code 1","title":"defmacro!"},{"location":"functions/macros/#defmesh","text":"Defines a new mesh on which wires can be scheduled and then run. Note What's a mesh ? Code 1 2 ;; defmesh ( defmesh main ) ;; define a mesh named 'main' (defmesh <mesh-name>) is actually a shorthand for the more verbose mesh definition: def <mesh-name> (Mesh) . Code 1 2 ;; def + Mesh ( def main ( Mesh )) ;; define a mesh named 'main' Here's an example that schedules a looped and a non-looped wire on a mesh. Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ;; define a mesh (main) ( defloop wire-hi ;; define a looped wire ( Msg \"Hello World!\" )) ( defwire wire-bye ;; define a non-looped wire ( Msg \"Goodbye World\" )) ( schedule main wire-hi ) ;; schedule looped wire (wire-hi) on this mesh ( schedule main wire-bye ) ;; schedule non-looped wire (wire-hi) on this mesh ( run main ) ;; run all the scheduled wires on this mesh [info] [2022-03-07 22:14:51.730] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.731] [T-14836] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 22:14:51.760] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.776] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.791] [T-14836] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:14:51.823] [T-14836] [logging.cpp::94] [wire-hi] Hello World! . . . See also def","title":"defmesh"},{"location":"functions/macros/#defloop","text":"Defines a new looped wire. Code 1 2 3 4 ;; defloop ( defloop my-loop ;; define a looped wire ;; shards here ) Note What's a wire ? (defloop <looped wire-name) is actually a shorthand for the more verbose looped wire definition: def <looped wire-name> + Wire \"looped wire-name\" . Code 1 2 3 4 5 ;; def + Wire ( def my-loop ( Wire \"my-loop\" :Looped ;; shards here )) For a wire to be executed, it must first be scheduled on a mesh and then that that mesh needs to run. Code Result 1 2 3 4 5 ( defmesh main ) ;; define a mesh ( defloop my-loop ;; define a looped wire ( Msg \"Hello World!\" )) ( schedule main my-loop ) ;; ( run main ) ;; run wires scheduled on this mesh [info] [2022-05-13 09:48:01.692] [T-15068] [logging.cpp::98] [my-loop] Hello World! [info] [2022-05-13 09:48:01.693] [T-15068] [logging.cpp::98] [my-loop] Hello World! [info] [2022-05-13 09:48:01.694] [T-15068] [logging.cpp::98] [my-loop] Hello World! . . . A mesh will continue executing a looped wire till the mesh itself stops running (or the wire execution is stopped via a logic condition). Code Result 1 2 3 4 5 6 7 8 ( defmesh main ) ;; define a mesh ( defloop wire-hi ;; define a looped wire (wire-hello) ( Msg \"Hello World!\" )) ( defloop wire-bye ;; define another looped wire (wire-bye) ( Msg \"Goodbye World\" )) ( schedule main wire-hi ) ;; schedule the wire (wire-hi) on the mesh ( schedule main wire-bye ) ;; schedule the wire (wire-bye) on the mesh ( run main ) ;; run all the wires scheduled on this mesh [info] [2022-03-07 22:28:54.682] [T-8432] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:28:54.682] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 22:28:54.715] [T-8432] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:28:54.715] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 22:28:54.731] [T-8432] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 22:28:54.732] [T-8432] [logging.cpp::94] [wire-bye] Goodbye World . . . See also def defwire","title":"defloop"},{"location":"functions/misc/","text":"Miscellaneous functions \u00b6 Uncategorized This page references all other functions that don't fit in the previous categories. Overtime, they might be moved to a different or new category. -> \u00b6 Groups multiple shards together (as if they were a single shard). Also called shard-container. This is useful for cases where you need multiple shards (to transform your data) but are allowed to have only one: for example, as the return value of a function (see function print-messages below). Code Result 1 2 3 4 5 ( defn print-messages [] ( -> ( Msg \"Hello World!\" ) ( Msg \"Hello Universe!\" ) )) [info] [2022-07-06 14:14:43.056] [T-2168] [logging.cpp::98] [main] Hello World! [info] [2022-07-06 14:14:43.058] [T-2168] [logging.cpp::98] [main] Hello Universe! apply \u00b6 1 atom \u00b6 1 deref \u00b6 1 fn? \u00b6 1 hex \u00b6 1 keyword \u00b6 1 macro? \u00b6 1 meta \u00b6 1 read-string \u00b6 1 readline \u00b6 1 reset! \u00b6 1 run \u00b6 Executes all the wires that have been scheduled on a given mesh . (run <params>) takes two arguments: name of the mesh, and mesh iteration interval (no. of seconds between two mesh iterations). An optional 3rd argument defines the maximum mesh iterations to run. This argument is a debug parameter - do not use for production. Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; define a mesh (main) ( defmesh main ) ;; define a looped wire ( defloop wire-hi ( Msg \"Hello World!\" )) ;; define a non-looped wire ( defwire wire-bye ( Msg \"Goodbye World\" )) ;; schedule both the wires on this mesh ( schedule main wire-hi ) ( schedule main wire-bye ) ;; run the mesh to execute scheduled wires ;; time between mesh iterations - 0.02 secs ;; max mesh iterations allowed - 5 ( run main 0.02 5 ) ;; The last two args may also be passed as mathematical expressions ;; (run main (/ 1 50) (+ 2 3)) [info] [2022-03-07 21:42:12.324] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.325] [T-18096] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 21:42:12.351] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.367] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.397] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.413] [T-18096] [logging.cpp::94] [wire-hi] Hello World! schedule \u00b6 Queues a wire for execution on a given mesh. Multiple wires can be scheduled on the same mesh . When a mesh is run, all the wires on it are executed. Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; define a mesh (main) ( defmesh main ) ;; define a looped wire ( defloop wire-hi ( Msg \"Hello World!\" )) ;; define a non-looped wire ( defwire wire-bye ( Msg \"Goodbye World\" )) ;; schedule both the wires on this mesh ( schedule main wire-hi ) ( schedule main wire-bye ) ;; run all the scheduled wires on this mesh (main) ( run main ) [info] [2022-03-07 21:42:12.324] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.325] [T-18096] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 21:42:12.351] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.367] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.397] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.413] [T-18096] [logging.cpp::94] [wire-hi] Hello World! swap! \u00b6 1 symbol \u00b6 1 throw \u00b6 1 time-ms \u00b6 1 with-meta \u00b6 1","title":"Miscellaneous functions"},{"location":"functions/misc/#miscellaneous-functions","text":"Uncategorized This page references all other functions that don't fit in the previous categories. Overtime, they might be moved to a different or new category.","title":"Miscellaneous functions"},{"location":"functions/misc/#-","text":"Groups multiple shards together (as if they were a single shard). Also called shard-container. This is useful for cases where you need multiple shards (to transform your data) but are allowed to have only one: for example, as the return value of a function (see function print-messages below). Code Result 1 2 3 4 5 ( defn print-messages [] ( -> ( Msg \"Hello World!\" ) ( Msg \"Hello Universe!\" ) )) [info] [2022-07-06 14:14:43.056] [T-2168] [logging.cpp::98] [main] Hello World! [info] [2022-07-06 14:14:43.058] [T-2168] [logging.cpp::98] [main] Hello Universe!","title":"-&gt;"},{"location":"functions/misc/#apply","text":"1","title":"apply"},{"location":"functions/misc/#atom","text":"1","title":"atom"},{"location":"functions/misc/#deref","text":"1","title":"deref"},{"location":"functions/misc/#fn","text":"1","title":"fn?"},{"location":"functions/misc/#hex","text":"1","title":"hex"},{"location":"functions/misc/#keyword","text":"1","title":"keyword"},{"location":"functions/misc/#macro","text":"1","title":"macro?"},{"location":"functions/misc/#meta","text":"1","title":"meta"},{"location":"functions/misc/#read-string","text":"1","title":"read-string"},{"location":"functions/misc/#readline","text":"1","title":"readline"},{"location":"functions/misc/#reset","text":"1","title":"reset!"},{"location":"functions/misc/#run","text":"Executes all the wires that have been scheduled on a given mesh . (run <params>) takes two arguments: name of the mesh, and mesh iteration interval (no. of seconds between two mesh iterations). An optional 3rd argument defines the maximum mesh iterations to run. This argument is a debug parameter - do not use for production. Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; define a mesh (main) ( defmesh main ) ;; define a looped wire ( defloop wire-hi ( Msg \"Hello World!\" )) ;; define a non-looped wire ( defwire wire-bye ( Msg \"Goodbye World\" )) ;; schedule both the wires on this mesh ( schedule main wire-hi ) ( schedule main wire-bye ) ;; run the mesh to execute scheduled wires ;; time between mesh iterations - 0.02 secs ;; max mesh iterations allowed - 5 ( run main 0.02 5 ) ;; The last two args may also be passed as mathematical expressions ;; (run main (/ 1 50) (+ 2 3)) [info] [2022-03-07 21:42:12.324] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.325] [T-18096] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 21:42:12.351] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.367] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.397] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.413] [T-18096] [logging.cpp::94] [wire-hi] Hello World!","title":"run"},{"location":"functions/misc/#schedule","text":"Queues a wire for execution on a given mesh. Multiple wires can be scheduled on the same mesh . When a mesh is run, all the wires on it are executed. Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; define a mesh (main) ( defmesh main ) ;; define a looped wire ( defloop wire-hi ( Msg \"Hello World!\" )) ;; define a non-looped wire ( defwire wire-bye ( Msg \"Goodbye World\" )) ;; schedule both the wires on this mesh ( schedule main wire-hi ) ( schedule main wire-bye ) ;; run all the scheduled wires on this mesh (main) ( run main ) [info] [2022-03-07 21:42:12.324] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.325] [T-18096] [logging.cpp::94] [wire-bye] Goodbye World [info] [2022-03-07 21:42:12.351] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.367] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.397] [T-18096] [logging.cpp::94] [wire-hi] Hello World! [info] [2022-03-07 21:42:12.413] [T-18096] [logging.cpp::94] [wire-hi] Hello World!","title":"schedule"},{"location":"functions/misc/#swap","text":"1","title":"swap!"},{"location":"functions/misc/#symbol","text":"1","title":"symbol"},{"location":"functions/misc/#throw","text":"1","title":"throw"},{"location":"functions/misc/#time-ms","text":"1","title":"time-ms"},{"location":"functions/misc/#with-meta","text":"1","title":"with-meta"},{"location":"functions/operators/","text":"Operators \u00b6 Danger These operators only works on numerical values. Comparing with a string or any other type will produce an error. = \u00b6 Equality operator. Checks whether two values are equal. Code Result 1 2 3 4 5 6 7 ( = 4 5 ) ( = \"5\" 5 ) ( = 5 5 ) ( = 5 5.0 ) false Error: \"5\" is not a malNumber, line: 3 true true < \u00b6 Comparison operator. Checks whether the first value is lesser than the second value. Code Result 1 2 3 4 5 ( < 4 5 ) ( < 5 4 ) ( < 5 5 ) true false false > \u00b6 Comparison operator. Checks whether the first value is greater than the second value. Code Result 1 2 3 4 5 ( > 4 5 ) ( > 5 4 ) ( > 5 5 ) false true false <= \u00b6 Comparison operator. Checks whether the first value is lesser than or equal to the second value. Code Result 1 2 3 4 5 ( <= 4 5 ) ( <= 5 4 ) ( <= 5 5 ) true false true >= \u00b6 Comparison operator. Checks whether the first value is greater than or equal to the second value. Code Result 1 2 3 4 5 ( >= 4 5 ) ( >= 5 4 ) ( >= 5 5 ) false true true","title":"Operators"},{"location":"functions/operators/#operators","text":"Danger These operators only works on numerical values. Comparing with a string or any other type will produce an error.","title":"Operators"},{"location":"functions/operators/#_1","text":"Equality operator. Checks whether two values are equal. Code Result 1 2 3 4 5 6 7 ( = 4 5 ) ( = \"5\" 5 ) ( = 5 5 ) ( = 5 5.0 ) false Error: \"5\" is not a malNumber, line: 3 true true","title":"="},{"location":"functions/operators/#_2","text":"Comparison operator. Checks whether the first value is lesser than the second value. Code Result 1 2 3 4 5 ( < 4 5 ) ( < 5 4 ) ( < 5 5 ) true false false","title":"&lt;"},{"location":"functions/operators/#_3","text":"Comparison operator. Checks whether the first value is greater than the second value. Code Result 1 2 3 4 5 ( > 4 5 ) ( > 5 4 ) ( > 5 5 ) false true false","title":"&gt;"},{"location":"functions/operators/#_4","text":"Comparison operator. Checks whether the first value is lesser than or equal to the second value. Code Result 1 2 3 4 5 ( <= 4 5 ) ( <= 5 4 ) ( <= 5 5 ) true false true","title":"&lt;="},{"location":"functions/operators/#_5","text":"Comparison operator. Checks whether the first value is greater than or equal to the second value. Code Result 1 2 3 4 5 ( >= 4 5 ) ( >= 5 4 ) ( >= 5 5 ) false true true","title":"&gt;="},{"location":"functions/standard-output/","text":"Standard output \u00b6 println \u00b6 Prints a variable number of values into a the standard output, separated by a whitespace. Each collection type follows its own printing rule. Code Output 1 2 3 4 5 6 7 8 9 10 11 ( println \"hello\" \"world\" ) ( println [ 1 2 3 4 ]) ( println ( vector 1 2 3 4 )) ( println ( list 1 2 3 4 )) ( println { \"key\" \"value\" }) ( println ( hash-map \"key\" \"value\" )) ( println { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) hello world [1 2 3 4] [1 2 3 4] (1 2 3 4) {\"key\" value} {\"key\" value} {:key1 [1 2 3]} {:key2 (1 2 3 4)} See also prn pr-str str prn \u00b6 Prints a variable number of values into a the standard output, separated by a whitespace. Each collection type follows its own printing rule. In addition, strings are escaped. Code Output 1 2 3 4 5 6 7 8 9 10 11 ( prn \"hello\" \"world\" ) ( prn [ 1 2 3 4 ]) ( prn ( vector 1 2 3 4 )) ( prn ( list 1 2 3 4 )) ( prn { \"key\" \"value\" }) ( prn ( hash-map \"key\" \"value\" )) ( prn { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) \"hello\" \"world\" [1 2 3 4] [1 2 3 4] (1 2 3 4) {\"key\" \"value\"} {\"key\" \"value\"} {:key1 [1 2 3]} {:key2 (1 2 3 4)} See also println pr-str str","title":"Standard output"},{"location":"functions/standard-output/#standard-output","text":"","title":"Standard output"},{"location":"functions/standard-output/#println","text":"Prints a variable number of values into a the standard output, separated by a whitespace. Each collection type follows its own printing rule. Code Output 1 2 3 4 5 6 7 8 9 10 11 ( println \"hello\" \"world\" ) ( println [ 1 2 3 4 ]) ( println ( vector 1 2 3 4 )) ( println ( list 1 2 3 4 )) ( println { \"key\" \"value\" }) ( println ( hash-map \"key\" \"value\" )) ( println { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) hello world [1 2 3 4] [1 2 3 4] (1 2 3 4) {\"key\" value} {\"key\" value} {:key1 [1 2 3]} {:key2 (1 2 3 4)} See also prn pr-str str","title":"println"},{"location":"functions/standard-output/#prn","text":"Prints a variable number of values into a the standard output, separated by a whitespace. Each collection type follows its own printing rule. In addition, strings are escaped. Code Output 1 2 3 4 5 6 7 8 9 10 11 ( prn \"hello\" \"world\" ) ( prn [ 1 2 3 4 ]) ( prn ( vector 1 2 3 4 )) ( prn ( list 1 2 3 4 )) ( prn { \"key\" \"value\" }) ( prn ( hash-map \"key\" \"value\" )) ( prn { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) \"hello\" \"world\" [1 2 3 4] [1 2 3 4] (1 2 3 4) {\"key\" \"value\"} {\"key\" \"value\"} {:key1 [1 2 3]} {:key2 (1 2 3 4)} See also println pr-str str","title":"prn"},{"location":"functions/strings/","text":"Strings \u00b6 pr-str \u00b6 Prints a variable number of values into a string, separated by a whitespace. Each collection type follows its own printing rule. In addition, strings are escaped. Code Result 1 2 3 4 5 6 7 8 9 10 11 ( pr-str \"hello\" \"world\" ) ( pr-str [ 1 2 3 4 ]) ( pr-str ( vector 1 2 3 4 )) ( pr-str ( list 1 2 3 4 )) ( pr-str { \"key\" \"value\" }) ( pr-str ( hash-map \"key\" \"value\" )) ( pr-str { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) \"\"hello\" \"world\"\" \"[1 2 3 4]\" \"[1 2 3 4]\" \"(1 2 3 4)\" \"{\"key\" \"value\"}\" \"{\"key\" \"value\"}\" \"{:key1 [1 2 3]} {:key2 (1 2 3 4)}\" See also println prn str slurp \u00b6 Reads the content of a file into a string. The path can be absolute or relative to the script. Code ( slurp \"file.txt\" ) str \u00b6 Prints a variable number of values into a string, without whitespace separation. Each collection type follows its own printing rule. Code Result 1 2 3 4 5 6 7 8 9 10 11 ( str \"hello\" \"world\" ) ( str [ 1 2 3 4 ]) ( str ( vector 1 2 3 4 )) ( str ( list 1 2 3 4 )) ( str { \"key\" \"value\" }) ( str ( hash-map \"key\" \"value\" )) ( str { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) \"helloworld\" \"[1 2 3 4]\" \"[1 2 3 4]\" \"(1 2 3 4)\" \"{\"key\" value}\" \"{\"key\" value}\" \"{:key1 [1 2 3]}{:key2 (1 2 3 4)}\" See also println pr-str prn","title":"Strings"},{"location":"functions/strings/#strings","text":"","title":"Strings"},{"location":"functions/strings/#pr-str","text":"Prints a variable number of values into a string, separated by a whitespace. Each collection type follows its own printing rule. In addition, strings are escaped. Code Result 1 2 3 4 5 6 7 8 9 10 11 ( pr-str \"hello\" \"world\" ) ( pr-str [ 1 2 3 4 ]) ( pr-str ( vector 1 2 3 4 )) ( pr-str ( list 1 2 3 4 )) ( pr-str { \"key\" \"value\" }) ( pr-str ( hash-map \"key\" \"value\" )) ( pr-str { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) \"\"hello\" \"world\"\" \"[1 2 3 4]\" \"[1 2 3 4]\" \"(1 2 3 4)\" \"{\"key\" \"value\"}\" \"{\"key\" \"value\"}\" \"{:key1 [1 2 3]} {:key2 (1 2 3 4)}\" See also println prn str","title":"pr-str"},{"location":"functions/strings/#slurp","text":"Reads the content of a file into a string. The path can be absolute or relative to the script. Code ( slurp \"file.txt\" )","title":"slurp"},{"location":"functions/strings/#str","text":"Prints a variable number of values into a string, without whitespace separation. Each collection type follows its own printing rule. Code Result 1 2 3 4 5 6 7 8 9 10 11 ( str \"hello\" \"world\" ) ( str [ 1 2 3 4 ]) ( str ( vector 1 2 3 4 )) ( str ( list 1 2 3 4 )) ( str { \"key\" \"value\" }) ( str ( hash-map \"key\" \"value\" )) ( str { :key1 ( vector 1 2 3 )} { :key2 ( list 1 2 3 4 )}) \"helloworld\" \"[1 2 3 4]\" \"[1 2 3 4]\" \"(1 2 3 4)\" \"{\"key\" value}\" \"{\"key\" value}\" \"{:key1 [1 2 3]}{:key2 (1 2 3 4)}\" See also println pr-str prn","title":"str"},{"location":"functions/values/","text":"Values \u00b6 Info All these functions have an alias starting with an uppercase character. In other words, (int 42) and (Int 42) are both valid, and represent the same value. bytes \u00b6 Represents the raw bytes value of a string. Code 1 ( bytes \"string\" ) color \u00b6 Represents a RGBA color where each component is within the [0, 255] range. Code 1 ( color 255 255 255 255 ) context-var \u00b6 Creates a contextual variable with the given name. Note The uppercase alias for this function is (ContextVar) . Code 1 ( context-var \"myVar\" ) float \u00b6 Represents a floating point number. Code 1 ( float 3.14 ) float2 \u00b6 Represents a vector of 2 floating point numbers. Code 1 ( float2 -1.0 1.0 ) float3 \u00b6 Represents a vector of 3 floating point numbers. Code 1 ( float3 -1.0 0.0 1.0 ) float4 \u00b6 Represents a vector of 4 floating point numbers. Code 1 ( float4 1.0 1.0 1.0 0.0 ) int \u00b6 Represents a signed integer. Code 1 ( int 1 ) int2 \u00b6 Represents a vector of 2 signed integers. Code 1 ( int2 1 -2 ) int3 \u00b6 Represents a vector of 3 signed integers. Code 1 ( int3 1 2 3 ) int4 \u00b6 Represents a vector of 4 signed integers. Code 1 ( int4 1 2 3 4 ) string \u00b6 Represents a string. Code 1 ( string \"Hello World!\" )","title":"Values"},{"location":"functions/values/#values","text":"Info All these functions have an alias starting with an uppercase character. In other words, (int 42) and (Int 42) are both valid, and represent the same value.","title":"Values"},{"location":"functions/values/#bytes","text":"Represents the raw bytes value of a string. Code 1 ( bytes \"string\" )","title":"bytes"},{"location":"functions/values/#color","text":"Represents a RGBA color where each component is within the [0, 255] range. Code 1 ( color 255 255 255 255 )","title":"color"},{"location":"functions/values/#context-var","text":"Creates a contextual variable with the given name. Note The uppercase alias for this function is (ContextVar) . Code 1 ( context-var \"myVar\" )","title":"context-var"},{"location":"functions/values/#float","text":"Represents a floating point number. Code 1 ( float 3.14 )","title":"float"},{"location":"functions/values/#float2","text":"Represents a vector of 2 floating point numbers. Code 1 ( float2 -1.0 1.0 )","title":"float2"},{"location":"functions/values/#float3","text":"Represents a vector of 3 floating point numbers. Code 1 ( float3 -1.0 0.0 1.0 )","title":"float3"},{"location":"functions/values/#float4","text":"Represents a vector of 4 floating point numbers. Code 1 ( float4 1.0 1.0 1.0 0.0 )","title":"float4"},{"location":"functions/values/#int","text":"Represents a signed integer. Code 1 ( int 1 )","title":"int"},{"location":"functions/values/#int2","text":"Represents a vector of 2 signed integers. Code 1 ( int2 1 -2 )","title":"int2"},{"location":"functions/values/#int3","text":"Represents a vector of 3 signed integers. Code 1 ( int3 1 2 3 )","title":"int3"},{"location":"functions/values/#int4","text":"Represents a vector of 4 signed integers. Code 1 ( int4 1 2 3 4 )","title":"int4"},{"location":"functions/values/#string","text":"Represents a string. Code 1 ( string \"Hello World!\" )","title":"string"},{"location":"how-to/","text":"Introduction \u00b6 How-to guides explain, in simple steps, how to complete a task or achieve an objective.","title":"Introduction"},{"location":"how-to/#introduction","text":"How-to guides explain, in simple steps, how to complete a task or achieve an objective.","title":"Introduction"},{"location":"how-to/contributing-tutorials/","text":"Contributing tutorials \u00b6 How-to contribute Shards example game codes and tutorials. // TODO //","title":"Contributing tutorials"},{"location":"how-to/contributing-tutorials/#contributing-tutorials","text":"How-to contribute Shards example game codes and tutorials. // TODO //","title":"Contributing tutorials"},{"location":"how-to/shards-primer/","text":"Shards primer \u00b6 How-to program in Shards. // TODO // Stateful Functions \u00b6 // TODO //","title":"Shards primer"},{"location":"how-to/shards-primer/#shards-primer","text":"How-to program in Shards. // TODO //","title":"Shards primer"},{"location":"how-to/shards-primer/#stateful-functions","text":"// TODO //","title":"Stateful Functions"},{"location":"shards/","text":"Introduction \u00b6 Shards aims to be a meta language or a visual language rather then a pure programming language. To nicely describe wires and the data they contain, we adopt a simple language based on EDN and Clojure. Notice that in theory any language can be used, this was just a pragmatic choice. In fact you will also find wires written in C++ digging the Shards codebase. One can think of it as a comprehensible JSON on steroids that can be evaluated or the Ansible of general programming. The execution of Shards scripts is meant to be fast: the scripting language is just a description of the computational graph. The runtime itself is completely detached. Running code samples Many shard code samples (like for the shard Take ) do not include the wire/mesh context they need to run. To run these samples you need to navigate to ../shards/docs/samples/ and use the following command to provide the necessary boilerplate code to these samples. cd docs/samples ../../build/shards.exe run-sample.edn --file \"<relative-path-of-sample.edn>\" Some examples \u00b6 Super simple example \u00b6 Code Output 1 2 3 4 5 6 7 8 9 ; define a mesh ( defmesh main ) ; define a simple hello world looped wire ( defloop hello-world ( Msg \"Hello world\" )) ; schedule the wire for exection ( schedule main hello-world ) ; run the mesh at 1 second intervals ( run main 1.0 ) ; <-- execution will block here [info] [2021-04-04 16:43:22.290] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:23.299] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:24.291] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:25.289] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:26.291] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:27.299] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:28.296] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:29.292] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:30.295] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:31.298] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:32.298] [T-148944] [logging.cpp::94] [hello-world] Hello world Another example \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; define a mesh ( defmesh main ) ; define a simple counter looped wire ( defloop counter ; Setup runs only once at wire start ( Setup 0 >= .counter ) ; get counter variable and print .counter ( Log ) ; increase the counter ( Math.Inc .counter ) ; notice that Math.Inc will passthrough the value ; so the value will be before increment ; if we wanted to pick up the increment uncomment the next line ; .counter ( When ( Is 10 ) ( Stop ))) ; schedule the wire for exection ( schedule main counter ) ; run the mesh at 1 second intervals ( run main 1.0 ) ; <-- execution will block here [info] [2021-04-04 19:00:43.045] [T-244992] [logging.cpp::53] [counter] 0 [info] [2021-04-04 19:00:44.055] [T-244992] [logging.cpp::53] [counter] 1 [info] [2021-04-04 19:00:45.058] [T-244992] [logging.cpp::53] [counter] 2 [info] [2021-04-04 19:00:46.057] [T-244992] [logging.cpp::53] [counter] 3 [info] [2021-04-04 19:00:47.049] [T-244992] [logging.cpp::53] [counter] 4 [info] [2021-04-04 19:00:48.057] [T-244992] [logging.cpp::53] [counter] 5 [info] [2021-04-04 19:00:49.046] [T-244992] [logging.cpp::53] [counter] 6 [info] [2021-04-04 19:00:50.049] [T-244992] [logging.cpp::53] [counter] 7 [info] [2021-04-04 19:00:51.058] [T-244992] [logging.cpp::53] [counter] 8 [info] [2021-04-04 19:00:52.054] [T-244992] [logging.cpp::53] [counter] 9 [info] [2021-04-04 19:00:53.055] [T-244992] [logging.cpp::53] [counter] 10 A more complex example \u00b6 Showing how we mix the Clojure-like language as a template language Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; define a mesh ( defmesh main ) ; define a counter template ( defn make-counter [ start ] ; this time we use the Wire symbol as we want to make a function ( Wire ; customize the wire's name ( str \"counter-\" start ) :Looped ; Setup runs only once at wire start ( Setup ; set start with the start function argument start >= .counter ) ; get counter variable and print .counter ( Log ) ; increase the counter ( Math.Inc .counter ) ; notice that Math.Inc will passthrough the value ; so the value will be before increment ; if we wanted to pick up the increment uncomment the next line ; .counter ; also at wire definition time compute the end value ; (+) is not a shard, it will be evaluated only once when composing the wire ( When ( Is ( + start 10 )) ( Stop )))) ; schedule 2 wires for exection ( schedule main ( make-counter 0 )) ( schedule main ( make-counter 10 )) ; run the mesh at 1 second intervals ( run main 1.0 ) ; <-- execution will block here [info] [2021-04-04 21:05:40.121] [T-285088] [logging.cpp::53] [counter-0] 0 [info] [2021-04-04 21:05:40.122] [T-285088] [logging.cpp::53] [counter-10] 10 [info] [2021-04-04 21:05:41.133] [T-285088] [logging.cpp::53] [counter-0] 1 [info] [2021-04-04 21:05:41.133] [T-285088] [logging.cpp::53] [counter-10] 11 [info] [2021-04-04 21:05:42.130] [T-285088] [logging.cpp::53] [counter-0] 2 [info] [2021-04-04 21:05:42.130] [T-285088] [logging.cpp::53] [counter-10] 12 [info] [2021-04-04 21:05:43.129] [T-285088] [logging.cpp::53] [counter-0] 3 [info] [2021-04-04 21:05:43.129] [T-285088] [logging.cpp::53] [counter-10] 13 [info] [2021-04-04 21:05:44.135] [T-285088] [logging.cpp::53] [counter-0] 4 [info] [2021-04-04 21:05:44.135] [T-285088] [logging.cpp::53] [counter-10] 14 [info] [2021-04-04 21:05:45.133] [T-285088] [logging.cpp::53] [counter-0] 5 [info] [2021-04-04 21:05:45.133] [T-285088] [logging.cpp::53] [counter-10] 15 [info] [2021-04-04 21:05:46.128] [T-285088] [logging.cpp::53] [counter-0] 6 [info] [2021-04-04 21:05:46.128] [T-285088] [logging.cpp::53] [counter-10] 16 [info] [2021-04-04 21:05:47.135] [T-285088] [logging.cpp::53] [counter-0] 7 [info] [2021-04-04 21:05:47.135] [T-285088] [logging.cpp::53] [counter-10] 17 [info] [2021-04-04 21:05:48.133] [T-285088] [logging.cpp::53] [counter-0] 8 [info] [2021-04-04 21:05:48.133] [T-285088] [logging.cpp::53] [counter-10] 18 [info] [2021-04-04 21:05:49.134] [T-285088] [logging.cpp::53] [counter-0] 9 [info] [2021-04-04 21:05:49.134] [T-285088] [logging.cpp::53] [counter-10] 19 [info] [2021-04-04 21:05:50.121] [T-285088] [logging.cpp::53] [counter-0] 10 [info] [2021-04-04 21:05:50.123] [T-285088] [logging.cpp::53] [counter-10] 20","title":"Introduction"},{"location":"shards/#introduction","text":"Shards aims to be a meta language or a visual language rather then a pure programming language. To nicely describe wires and the data they contain, we adopt a simple language based on EDN and Clojure. Notice that in theory any language can be used, this was just a pragmatic choice. In fact you will also find wires written in C++ digging the Shards codebase. One can think of it as a comprehensible JSON on steroids that can be evaluated or the Ansible of general programming. The execution of Shards scripts is meant to be fast: the scripting language is just a description of the computational graph. The runtime itself is completely detached. Running code samples Many shard code samples (like for the shard Take ) do not include the wire/mesh context they need to run. To run these samples you need to navigate to ../shards/docs/samples/ and use the following command to provide the necessary boilerplate code to these samples. cd docs/samples ../../build/shards.exe run-sample.edn --file \"<relative-path-of-sample.edn>\"","title":"Introduction"},{"location":"shards/#some-examples","text":"","title":"Some examples"},{"location":"shards/#super-simple-example","text":"Code Output 1 2 3 4 5 6 7 8 9 ; define a mesh ( defmesh main ) ; define a simple hello world looped wire ( defloop hello-world ( Msg \"Hello world\" )) ; schedule the wire for exection ( schedule main hello-world ) ; run the mesh at 1 second intervals ( run main 1.0 ) ; <-- execution will block here [info] [2021-04-04 16:43:22.290] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:23.299] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:24.291] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:25.289] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:26.291] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:27.299] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:28.296] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:29.292] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:30.295] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:31.298] [T-148944] [logging.cpp::94] [hello-world] Hello world [info] [2021-04-04 16:43:32.298] [T-148944] [logging.cpp::94] [hello-world] Hello world","title":"Super simple example"},{"location":"shards/#another-example","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; define a mesh ( defmesh main ) ; define a simple counter looped wire ( defloop counter ; Setup runs only once at wire start ( Setup 0 >= .counter ) ; get counter variable and print .counter ( Log ) ; increase the counter ( Math.Inc .counter ) ; notice that Math.Inc will passthrough the value ; so the value will be before increment ; if we wanted to pick up the increment uncomment the next line ; .counter ( When ( Is 10 ) ( Stop ))) ; schedule the wire for exection ( schedule main counter ) ; run the mesh at 1 second intervals ( run main 1.0 ) ; <-- execution will block here [info] [2021-04-04 19:00:43.045] [T-244992] [logging.cpp::53] [counter] 0 [info] [2021-04-04 19:00:44.055] [T-244992] [logging.cpp::53] [counter] 1 [info] [2021-04-04 19:00:45.058] [T-244992] [logging.cpp::53] [counter] 2 [info] [2021-04-04 19:00:46.057] [T-244992] [logging.cpp::53] [counter] 3 [info] [2021-04-04 19:00:47.049] [T-244992] [logging.cpp::53] [counter] 4 [info] [2021-04-04 19:00:48.057] [T-244992] [logging.cpp::53] [counter] 5 [info] [2021-04-04 19:00:49.046] [T-244992] [logging.cpp::53] [counter] 6 [info] [2021-04-04 19:00:50.049] [T-244992] [logging.cpp::53] [counter] 7 [info] [2021-04-04 19:00:51.058] [T-244992] [logging.cpp::53] [counter] 8 [info] [2021-04-04 19:00:52.054] [T-244992] [logging.cpp::53] [counter] 9 [info] [2021-04-04 19:00:53.055] [T-244992] [logging.cpp::53] [counter] 10","title":"Another example"},{"location":"shards/#a-more-complex-example","text":"Showing how we mix the Clojure-like language as a template language Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; define a mesh ( defmesh main ) ; define a counter template ( defn make-counter [ start ] ; this time we use the Wire symbol as we want to make a function ( Wire ; customize the wire's name ( str \"counter-\" start ) :Looped ; Setup runs only once at wire start ( Setup ; set start with the start function argument start >= .counter ) ; get counter variable and print .counter ( Log ) ; increase the counter ( Math.Inc .counter ) ; notice that Math.Inc will passthrough the value ; so the value will be before increment ; if we wanted to pick up the increment uncomment the next line ; .counter ; also at wire definition time compute the end value ; (+) is not a shard, it will be evaluated only once when composing the wire ( When ( Is ( + start 10 )) ( Stop )))) ; schedule 2 wires for exection ( schedule main ( make-counter 0 )) ( schedule main ( make-counter 10 )) ; run the mesh at 1 second intervals ( run main 1.0 ) ; <-- execution will block here [info] [2021-04-04 21:05:40.121] [T-285088] [logging.cpp::53] [counter-0] 0 [info] [2021-04-04 21:05:40.122] [T-285088] [logging.cpp::53] [counter-10] 10 [info] [2021-04-04 21:05:41.133] [T-285088] [logging.cpp::53] [counter-0] 1 [info] [2021-04-04 21:05:41.133] [T-285088] [logging.cpp::53] [counter-10] 11 [info] [2021-04-04 21:05:42.130] [T-285088] [logging.cpp::53] [counter-0] 2 [info] [2021-04-04 21:05:42.130] [T-285088] [logging.cpp::53] [counter-10] 12 [info] [2021-04-04 21:05:43.129] [T-285088] [logging.cpp::53] [counter-0] 3 [info] [2021-04-04 21:05:43.129] [T-285088] [logging.cpp::53] [counter-10] 13 [info] [2021-04-04 21:05:44.135] [T-285088] [logging.cpp::53] [counter-0] 4 [info] [2021-04-04 21:05:44.135] [T-285088] [logging.cpp::53] [counter-10] 14 [info] [2021-04-04 21:05:45.133] [T-285088] [logging.cpp::53] [counter-0] 5 [info] [2021-04-04 21:05:45.133] [T-285088] [logging.cpp::53] [counter-10] 15 [info] [2021-04-04 21:05:46.128] [T-285088] [logging.cpp::53] [counter-0] 6 [info] [2021-04-04 21:05:46.128] [T-285088] [logging.cpp::53] [counter-10] 16 [info] [2021-04-04 21:05:47.135] [T-285088] [logging.cpp::53] [counter-0] 7 [info] [2021-04-04 21:05:47.135] [T-285088] [logging.cpp::53] [counter-10] 17 [info] [2021-04-04 21:05:48.133] [T-285088] [logging.cpp::53] [counter-0] 8 [info] [2021-04-04 21:05:48.133] [T-285088] [logging.cpp::53] [counter-10] 18 [info] [2021-04-04 21:05:49.134] [T-285088] [logging.cpp::53] [counter-0] 9 [info] [2021-04-04 21:05:49.134] [T-285088] [logging.cpp::53] [counter-10] 19 [info] [2021-04-04 21:05:50.121] [T-285088] [logging.cpp::53] [counter-0] 10 [info] [2021-04-04 21:05:50.123] [T-285088] [logging.cpp::53] [counter-10] 20","title":"A more complex example"},{"location":"shards/types/","text":"Types \u00b6 This section documents all the valid data types that are accepted by various shards either as their input value or as their parameter values. These data types also apply to the output created by any shard. Valid data types for every shard are listed under the Type column of their Parameters, Input, and Output sections (types are enclosed within parentheses and if multiple types apply then they are separated by a space). Compound types While this section lists the simple (or primitive) data types, you can combine these to create compound data types. For example, combining Int , String , and Seq , can give you a sequence of sequences ( (Seq [(Seq)]) ), a sequence of integers and strings ( (Seq [(Int)] [(String)]) ), and so on. Why types? Types are helpful as they reduce errors in programming. They are also very useful in visual programming as type-matching can be used to reduce the dropdown options when prompting a user on what shard to use next (depending on which shard's input type matches with the current shard's output type). Note While all the following types are available internally to various shards, only a few are currently accessible in the Shards scripting environment. Consequently, only these types have keywords/aliases. Any \u00b6 Type Any indicates that all valid data types are allowed. For example, Any as the allowed data type for input and :Value parameter of shard (All) means that (All) accepts and compares across all data types. 1 2 3 ( All :Value [( Any )] ) (All) compares the input and :Value parameter values and returns true only if both the value and data type of these entities is equal/same. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [ 4 5 6 ] ( All :Value [ 4 5 6 ]) ( Log ) ;; value and type match => true \"I'm a string\" >= .var1 \"I'm a string\" >= .var2 .var1 ( All :Value .var2 ) ( Log ) ;; value and type match => true \"I'm a string\" >= .var3 \"I'm a different string\" >= .var4 .var3 ( All :Value .var4 ) ( Log ) ;; value mismatch => false ( Float 4.0 ) >= .var5 ( Int 4 ) >= .var6 .var5 ( All :Value .var6 ) ( Log ) ;; type mismatch => false [info] [2022-07-22 13:05:25.848] [T-18072] [logging.cpp::55] [mywire] true [info] [2022-07-22 13:05:25.861] [T-18072] [logging.cpp::55] [mywire] true [info] [2022-07-22 13:05:25.862] [T-18072] [logging.cpp::55] [mywire] false [info] [2022-07-22 13:05:25.864] [T-18072] [logging.cpp::55] [mywire] false Array \u00b6 Type Array is a collection of values that can be accessed directly via indexes (since items are indexed by contiguous integers). Also called a vector. Looks exactly like the Seq type, but an Array type's items are accessible by index (and hence accessible randomly). Example of an Array type would be: [43 6 1] . Audio \u00b6 Type Audio is uncompressed audio data. Examples of shards that use this type are (Audio.Oscillator) , (Audio.ReadFile) , and (Audio.WriteFile) all of which generate Audio type data as their output. Supported formats Shards supports the audio formats WAV, MP3, OGG, and FLAC. Bool \u00b6 Type Bool allows only two values - true or false . In that sense it can be thought of as a special case of an Enum data type. Consider the shard (Is) . This shard compares its input and the value in the :Value parameter for equality. After the comparison it needs to communicate its result in a yes/no format (yes values are equal; no values are not equal). 1 2 3 ( Is :Value [( Any )] ) To allow the shard to do this its output type is defined as a Bool . If the values are equal this shard emits true as its output, if the values are inequal it emits false . No other output is allowed. Code Output 1 2 3 4 5 100 ( Is :Value ( * 10 10 )) ( Log ) ;; Is equal => true [ 20 ] ( Is :Value 20 ) ( Log ) ;; Is not equal => false [info] [2022-07-22 18:38:24.383] [T-25360] [logging.cpp::55] [mywire] true [info] [2022-07-22 18:38:24.395] [T-25360] [logging.cpp::55] [mywire] false Bytes \u00b6 Type Bytes represents binary data. Note Has keyword bytes and alias Bytes . A byte is made up of 8 bits (for example, 10111010 ) and a Bytes type is an array of such bytes: [11110001 10110111 10000111] Bits and Bytes Bits are how data is stored in a computer at the level of ectrical circuits. A bit can have only two values (1 or 0, representing the circuit is on or off) - hence the name binary data. A group of eight bits make a byte: 11111111 , 10101010 , etc. Since a bit can have only two values, a Byte can represent a total of 256 numbers (2^8): 0 to 255. Shards like (ToBytes) , (BytesToString) , (BytesToInts) , etc. all use the type Bytes either for their input or their output. Color \u00b6 Type Color represents an RGBA color format and is constructed from four unsigned 8 bit integers (one each for the R, G, B, and A values). Note Has keyword color and alias Color . Each of the R, G, B, and A values range from 0 to 255. R, G, and B stand for red, blue, and green components of the color. A represents the alpha channel property (how opaqe a pixel is - 0 is fully transparent, 255 is fully opaque). The shard (ToColor) converts its input into a Color type. Code Output 1 2 3 4 5 6 7 8 ( int4 255 10 10 257 ) ( ToColor ) ( Log ) ;; if input > 255, 256 is subtracted from it => 255, 10, 10, 1 [ 23 45 56 78 ] ( ToColor ) ( Log ) ;; input in range 0-255 so => 23, 45, 56, 78 \"Hello\" ( ToColor ) ( Log ) ;; non-numeric input so => 0, 0, 0, 0 [info] [2022-07-26 19:08:24.520] [T-24408] [logging.cpp::55] [mywire] 255, 10, 10, 1 [info] [2022-07-26 19:08:24.533] [T-24408] [logging.cpp::55] [mywire] 23, 45, 56, 78 [info] [2022-07-26 19:08:24.534] [T-24408] [logging.cpp::55] [mywire] 0, 0, 0, 0 ContextVar \u00b6 Type ContextVar represents a contextual variable (i.e., a variable that is in scope for the shard processing this data). Note Has keyword context-var and alias ContextVar . The shard (Math.Inc) accepts only ContextVar type numeric data (i.e., a variable that holds numeric data) into its :Value parameter, and increments it by 1. Code Output 1 2 3 4 5 6 7 11 >= .intvar ;; .intvar is of type `ContextVar` ( Math.Inc .intvar ) .intvar ( Log ) ;; => 12 ( Float2 4.5 5.7 ) >= .floatvar ;; .floatvar is of type `ContextVar` ( Math.Inc .floatvar ) .floatvar ( Log ) ;; => (5.5, 6.7) [info] [2022-07-26 19:30:22.837] [T-27800] [logging.cpp::55] [mywire] 12 [info] [2022-07-26 19:30:22.843] [T-27800] [logging.cpp::55] [mywire] (5.5, 6.7) Enum \u00b6 Enum stands for enumerated data type. Note Has keyword enum and alias Enum . The value that you pass to an enumerated variable can only take certain 'states' or named constant values. For example, in (Math.Mean) the value for :Kind parameter needs to be of type Enum . 1 2 3 ( Math.Mean :Kind [( Enum )] ) (Math.Mean) computes the mean of a sequence of floating-point numbers. But there are three kinds of means - Arithmetic mean, Geometric mean, and Harmonic mean. So the parameter :Kind is defined as an enum variable with these three fixed states : :Kind = {Arithmtic mean, Geometric mean, Harmonic mean} And hence :Kind expects a value that matches one of its possible states. In other words the value you pass in for :Kind needs to be an enumerated data type. In simple terms it just means that you pass in one of the allowed named constant values. Anything else will fail validation. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [ 2.0 10.0 ] ( Math.Mean :Kind Mean.Arithmetic ) ( Log ) ;; AM => 6 [ 2.0 10.0 ] ( Math.Mean :Kind Mean.Geometric ) ( Log ) ;; GM => 4.47214 [ 2.0 10.0 ] ( Math.Mean :Kind Mean.Harmonic ) ( Log ) ;; HM => 3.33333 [ 2.0 10.0 ] ( Math.Mean ;; AM is default, anything else will throw error ;; :Kind 123 ) ( Log ) ;; AM => 6 [info] [2022-07-22 15:35:00.868] [T-15316] [logging.cpp::55] [mywire] 6 [info] [2022-07-22 15:35:00.881] [T-15316] [logging.cpp::55] [mywire] 4.47214 [info] [2022-07-22 15:35:00.882] [T-15316] [logging.cpp::55] [mywire] 3.33333 [info] [2022-07-22 15:35:00.883] [T-15316] [logging.cpp::55] [mywire] 6 Float \u00b6 Type Float defines a 64-bit signed floating point number. Note Has keyword float and alias Float . Floating point means it has the capability to store a decimal point and hence supports decimal numbers. 64 bits of memory allows this data type to support a very large range of positive and negative decimal numbers (16 significant decimal digits and an exponent range of \u2212383 to +384). A Float value looks like this: (float 2.53) . It may also be represented without the keyword float , with just the floating-point value: 2.53 . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 4 5 ( float 2.4 ) ( Math.Add ( float 1.43 )) ( Log ) ;; float output => 3.83 2.4 ( Math.Add 1.43 ) ( Log ) ;; float output => 3.83 [info] [2022-07-22 22:06:32.856] [T-20204] [logging.cpp::55] [mywire] 3.83 [info] [2022-07-22 22:06:32.873] [T-20204] [logging.cpp::55] [mywire] 3.83 Float2 \u00b6 Type Float2 defines a vector of two Float type numbers. Note Has keyword float2 and alias Float2 . A vector can be thought of as a group or list of items that are considered together for processing. A Float2 type value looks like this: (float2 3.4 -5.0) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( float2 4.1 5.0 ) ( Math.Add ( float2 6.3 9.2 )) ( Log ) ;; float2 output => (10.4, 14.2) ``` [info] [2022-07-22 22:10:00.688] [T-24616] [logging.cpp::55] [mywire] (10.4, 14.2) ``` Float3 \u00b6 Type Float3 defines a vector of three 32-bit signed floating point numbers. Note Has keyword float3 and alias Float3 . Floating point means it has the capability to store a decimal point and hence supports decimal numbers. 32 bits of memory allows this data type to support a large range of positive and negative decimal numbers (7 significant decimal digits and an exponent range of \u2212101 to +90). A Float3 type value looks like this: (float3 2.9 -4.23 7.83) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( float3 1.2 3.4 5.6 ) ( Math.Add ( float3 6.5 4.3 2.1 )) ( Log ) ;; float3 output => (7.7, 7.7, 7.7) [info] [2022-07-22 22:19:36.923] [T-16128] [logging.cpp::55] [mywire] (7.7, 7.7, 7.7) Float4 \u00b6 Type Float4 is like type Float3 but is a vector of four 32-bit signed floating point numbers instead. Note Has keyword float4 and alias Float4 . A Float4 type value looks like this: (float4 -8.84 38.2 4.7 0.4) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 ( float4 3.1 6.4 9.2 4.6 ) ( Math.Add ( float4 6.8 3.5 0.9 5.3 )) ( Log ) ;; Int4 output => (9.9, 9.9, 9.9, 9.9) [info] [2022-07-22 22:23:24.076] [T-25152] [logging.cpp::55] [mywire] (9.9, 9.9, 10.1, 9.9) Image \u00b6 Type Image is uncompressed image data. A shard that uses this type is (StripAlpha) . This takes an Image type input, strips out its alpha (transparency) channel, and outputs an Image type (transformed image). Supported formats Shards supports the image formats PNG and SVG. Int \u00b6 Type Int defines a 64-bit signed integer. Note Has keyword int and alias Int . 64 bits of memory allows this data type to store integer values ranging from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807 (no decimals). An Int value looks like this: (int 2) . It may also be represented without the keyword int , with just the integer value: 2 . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 4 5 ( int 3 ) ( Math.Add ( int 2 )) ( Log ) ;; int output => 5 3 ( Math.Add 2 ) ( Log ) ;; int output => 5 [info] [2022-07-22 21:20:18.771] [T-4568] [logging.cpp::55] [mywire] 5 [info] [2022-07-22 21:20:18.782] [T-4568] [logging.cpp::55] [mywire] 5 Int2 \u00b6 Type Int2 defines a vector of two Int type numbers. Note Has keyword int2 and alias Int2 . A vector can be thought of as a group or list of items that are considered together for processing. An Int2 type value looks like this: (int2 3 -5) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( int2 4 5 ) ( Math.Add ( int2 6 9 )) ( Log ) ;; int2 output => (10, 14) [info] [2022-07-22 21:22:26.381] [T-17748] [logging.cpp::55] [mywire] (10, 14) Int3 \u00b6 Type Int3 defines a vector of three 32-bit signed integers. Note Has keyword int3 and alias Int3 . 32 bits of memory for each number allows this data type to store integer values ranging from -2147483648 to +2147483647 (no decimals). An Int3 type value looks like this: (int3 2 4 -4) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( int3 1 10 99 ) ( Math.Add ( int3 99 90 1 )) ( Log ) ;; int3 output => (100, 100, 100) [info] [2022-07-22 21:24:38.132] [T-25580] [logging.cpp::55] [mywire] (100, 100, 100) Int4 \u00b6 Type Int4 is like type Int3 but is a vector of four 32-bit signed integers instead. Note Has keyword int4 and alias Int4 . An Int4 type value looks like this: (int4 1 -4 0 3) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 ( int4 3 6 9 4 ) ( Math.Add ( int4 6 3 0 5 )) ( Log ) ;; int4 output => (9, 9, 9, 9) [info] [2022-07-22 21:27:58.115] [T-20884] [logging.cpp::55] [mywire] (9, 9, 9, 9) Int8 \u00b6 Type Int8 defines a vector of eight 16-bit signed integers. 16 bits of memory for each number allows this data type to store integer values ranging from \u221232,768 to +32,767 (no decimals). The shard (Math.Add) accepts Int8 as input and as its :Operand . The shard adds these up outputs the sum as another vector of 8 integers or Int8 data type. Int16 \u00b6 Type Int16 defines a vector of sixteen 8-bit signed integers. 8 bits of memory for each number allows this data type to store integer values ranging from \u2212128 to +127 (no decimals). The shard (Math.Add) accepts Int16 as input and as its :Operand . The shard adds these up outputs the sum as another vector of 16 integers or Int16 data type. None \u00b6 Type None indicates that no data type is expected. This implies that no value is expected. For example, None as one of the valid data types for :Max parameter in shard (RandomInt) means that setting a value for this parameter is not mandatory. 1 2 3 ( RandomInt :Max [( None ) ( Int ) ( ContextVar [( Int )])] ) (RandomInt) generates a random integer and the :Max parameter is the upper limit (not inclusive) of the value that can be generated. So it makes sense to have None as one of the valid types for this :Max parameter for cases when you do not want an upper limit on the random integer (though in this case the system will inherently set the upper limit to the maximum value a 64-bit signed integer can hold: 9,223,372,036,854,775,807). Code Output 1 2 3 4 5 ( RandomInt 8 ) ( Log ) ;; max int that can be generated is 7 ( RandomInt ) ( Log ) ;; now upper limit subject to max capacity of a 64-bit signed integer [info] [2022-07-22 13:45:03.282] [T-19992] [logging.cpp::55] [mywire] 4 [info] [2022-07-22 13:45:03.293] [T-19992] [logging.cpp::55] [mywire] 311828859 Object \u00b6 Type Object is an opaque data type in Shards. Opacity in a data type means that the structure of this kind of data is not defined in an interface and is visible only to shards that use this type. What this also implies is that the internal structure of this data type will vary from shard to shard. For example, the :Socket parameter object of (WS.ReadString) is different from the output object of (GFX.DrawQueue) , even though both are of type Object . Path \u00b6 Type Path is String type data that is expected to contain a valid path (your operating system or local machine) for loading resources like script files, images, audio files etc. Note Has keyword path and alias Path . A valid Path type data string would look like this: \"../../external/sample-models/Avocado.glb\" Note For shards this type is the same as String type as far as type validations are concerned (when you execute your script Shards first checks the types before running your code). However,if the path-string passed is invalid, malformed, or missing the resource to be loaded, the shard will complain with an error message at runtime (i.e., when your code actually runs). A shard that uses this type is (Process.Run) . This shard takes a Path type in its :Executable parameter. Set \u00b6 Type Set is a collection of unique values. It's different from other collections like Seq and Array , both of which can contain non-unique or duplicate items. An example of a Set type data would be (22 3 378 4) . Seq \u00b6 Type Seq is a collection of values that can be accessed sequentially (i.e., they're iterable). Note Has keyword seq . Also called a sequence. An example of Seq type would be [7 2 54 42] . The shard (Take) works on this type. This shard can access Seq elements by their position. Code Output 1 2 [ 7 2 54 42 ] ( Take 2 ) ( Log ) ;; print the 2nd element => 54 [info] [2022-07-26 22:24:48.918] [T-20928] [logging.cpp::55] [mywire] 54 ShardRef \u00b6 Type ShardRef (also called type Shard ) represents a shard being passed as data. This type is an important aspect of the homoiconicity feature (i.e., code/data interchangeability) in Shards. Note What's a shard ? The shard (ForEach) expects type ShardRef for its :Apply parameter (the other option being a sequence of ShardRef type values, i.e., a Wire type). (ForEach) then applies this shard (or sequence of shards) on its input to transform it into its output. String \u00b6 Type String represents string data (any data enclosed within double quotes). Note Has keyword string and alias String . A String value looks like this: (string \"Hello @Tom!\") . It may also be represented without the keyword string , with just the data within double quotes: \"Hello @Tom!\" . An example of a shard that processes String type data is (String.ToUpper) . This shard takes a String and converts it into its upper case version. Code Output 1 2 3 4 5 ( string \"Hello World!\" ) ( String.ToUpper ) ( Log ) ;; upper case version => HELLO WORLD! \"Bye Universe!\" ( String.ToUpper ) ( Log ) ;; upper case version => BYE UNIVERSE! [info] [2022-07-26 19:38:14.813] [T-18168] [logging.cpp::55] [mywire] Bytes: 0x20440058720 size: 11 Table \u00b6 Type Table is a collection of key/value pairs. Its also known as map, data dictionary, or associative array. An example of a Table type would be: {:key1 \"Hello\" :key2 \"World\"} . Code Output 1 2 3 { :k1 123 } >= .tabvar ;; .tabvar is type `Table` now .tabvar ( ExpectTable ) ( Log ) ;; `ExpectTable` outputs `Table` type => {k1: 123} [info] [2022-07-26 22:46:17.194] [T-26104] [logging.cpp::55] [mywire] {k1: 123} Wire \u00b6 Type Wire represents a wire being passed as data. Note Has keyword Wire . A Wire type thus consists of a sequence of shards (which make up the wire), their shared state (memory) context, name of the wire, and other properties that enable operations on the wire like scheduling it on a mesh, starting/stopping/pausing the wire, etc. Note What's a wire ? For example, the shard (Stop) accepts Wire type data in its :Wire parameter and stops that wire's execution if its currently running.","title":"Types"},{"location":"shards/types/#types","text":"This section documents all the valid data types that are accepted by various shards either as their input value or as their parameter values. These data types also apply to the output created by any shard. Valid data types for every shard are listed under the Type column of their Parameters, Input, and Output sections (types are enclosed within parentheses and if multiple types apply then they are separated by a space). Compound types While this section lists the simple (or primitive) data types, you can combine these to create compound data types. For example, combining Int , String , and Seq , can give you a sequence of sequences ( (Seq [(Seq)]) ), a sequence of integers and strings ( (Seq [(Int)] [(String)]) ), and so on. Why types? Types are helpful as they reduce errors in programming. They are also very useful in visual programming as type-matching can be used to reduce the dropdown options when prompting a user on what shard to use next (depending on which shard's input type matches with the current shard's output type). Note While all the following types are available internally to various shards, only a few are currently accessible in the Shards scripting environment. Consequently, only these types have keywords/aliases.","title":"Types"},{"location":"shards/types/#any","text":"Type Any indicates that all valid data types are allowed. For example, Any as the allowed data type for input and :Value parameter of shard (All) means that (All) accepts and compares across all data types. 1 2 3 ( All :Value [( Any )] ) (All) compares the input and :Value parameter values and returns true only if both the value and data type of these entities is equal/same. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [ 4 5 6 ] ( All :Value [ 4 5 6 ]) ( Log ) ;; value and type match => true \"I'm a string\" >= .var1 \"I'm a string\" >= .var2 .var1 ( All :Value .var2 ) ( Log ) ;; value and type match => true \"I'm a string\" >= .var3 \"I'm a different string\" >= .var4 .var3 ( All :Value .var4 ) ( Log ) ;; value mismatch => false ( Float 4.0 ) >= .var5 ( Int 4 ) >= .var6 .var5 ( All :Value .var6 ) ( Log ) ;; type mismatch => false [info] [2022-07-22 13:05:25.848] [T-18072] [logging.cpp::55] [mywire] true [info] [2022-07-22 13:05:25.861] [T-18072] [logging.cpp::55] [mywire] true [info] [2022-07-22 13:05:25.862] [T-18072] [logging.cpp::55] [mywire] false [info] [2022-07-22 13:05:25.864] [T-18072] [logging.cpp::55] [mywire] false","title":"Any"},{"location":"shards/types/#array","text":"Type Array is a collection of values that can be accessed directly via indexes (since items are indexed by contiguous integers). Also called a vector. Looks exactly like the Seq type, but an Array type's items are accessible by index (and hence accessible randomly). Example of an Array type would be: [43 6 1] .","title":"Array"},{"location":"shards/types/#audio","text":"Type Audio is uncompressed audio data. Examples of shards that use this type are (Audio.Oscillator) , (Audio.ReadFile) , and (Audio.WriteFile) all of which generate Audio type data as their output. Supported formats Shards supports the audio formats WAV, MP3, OGG, and FLAC.","title":"Audio"},{"location":"shards/types/#bool","text":"Type Bool allows only two values - true or false . In that sense it can be thought of as a special case of an Enum data type. Consider the shard (Is) . This shard compares its input and the value in the :Value parameter for equality. After the comparison it needs to communicate its result in a yes/no format (yes values are equal; no values are not equal). 1 2 3 ( Is :Value [( Any )] ) To allow the shard to do this its output type is defined as a Bool . If the values are equal this shard emits true as its output, if the values are inequal it emits false . No other output is allowed. Code Output 1 2 3 4 5 100 ( Is :Value ( * 10 10 )) ( Log ) ;; Is equal => true [ 20 ] ( Is :Value 20 ) ( Log ) ;; Is not equal => false [info] [2022-07-22 18:38:24.383] [T-25360] [logging.cpp::55] [mywire] true [info] [2022-07-22 18:38:24.395] [T-25360] [logging.cpp::55] [mywire] false","title":"Bool"},{"location":"shards/types/#bytes","text":"Type Bytes represents binary data. Note Has keyword bytes and alias Bytes . A byte is made up of 8 bits (for example, 10111010 ) and a Bytes type is an array of such bytes: [11110001 10110111 10000111] Bits and Bytes Bits are how data is stored in a computer at the level of ectrical circuits. A bit can have only two values (1 or 0, representing the circuit is on or off) - hence the name binary data. A group of eight bits make a byte: 11111111 , 10101010 , etc. Since a bit can have only two values, a Byte can represent a total of 256 numbers (2^8): 0 to 255. Shards like (ToBytes) , (BytesToString) , (BytesToInts) , etc. all use the type Bytes either for their input or their output.","title":"Bytes"},{"location":"shards/types/#color","text":"Type Color represents an RGBA color format and is constructed from four unsigned 8 bit integers (one each for the R, G, B, and A values). Note Has keyword color and alias Color . Each of the R, G, B, and A values range from 0 to 255. R, G, and B stand for red, blue, and green components of the color. A represents the alpha channel property (how opaqe a pixel is - 0 is fully transparent, 255 is fully opaque). The shard (ToColor) converts its input into a Color type. Code Output 1 2 3 4 5 6 7 8 ( int4 255 10 10 257 ) ( ToColor ) ( Log ) ;; if input > 255, 256 is subtracted from it => 255, 10, 10, 1 [ 23 45 56 78 ] ( ToColor ) ( Log ) ;; input in range 0-255 so => 23, 45, 56, 78 \"Hello\" ( ToColor ) ( Log ) ;; non-numeric input so => 0, 0, 0, 0 [info] [2022-07-26 19:08:24.520] [T-24408] [logging.cpp::55] [mywire] 255, 10, 10, 1 [info] [2022-07-26 19:08:24.533] [T-24408] [logging.cpp::55] [mywire] 23, 45, 56, 78 [info] [2022-07-26 19:08:24.534] [T-24408] [logging.cpp::55] [mywire] 0, 0, 0, 0","title":"Color"},{"location":"shards/types/#contextvar","text":"Type ContextVar represents a contextual variable (i.e., a variable that is in scope for the shard processing this data). Note Has keyword context-var and alias ContextVar . The shard (Math.Inc) accepts only ContextVar type numeric data (i.e., a variable that holds numeric data) into its :Value parameter, and increments it by 1. Code Output 1 2 3 4 5 6 7 11 >= .intvar ;; .intvar is of type `ContextVar` ( Math.Inc .intvar ) .intvar ( Log ) ;; => 12 ( Float2 4.5 5.7 ) >= .floatvar ;; .floatvar is of type `ContextVar` ( Math.Inc .floatvar ) .floatvar ( Log ) ;; => (5.5, 6.7) [info] [2022-07-26 19:30:22.837] [T-27800] [logging.cpp::55] [mywire] 12 [info] [2022-07-26 19:30:22.843] [T-27800] [logging.cpp::55] [mywire] (5.5, 6.7)","title":"ContextVar"},{"location":"shards/types/#enum","text":"Enum stands for enumerated data type. Note Has keyword enum and alias Enum . The value that you pass to an enumerated variable can only take certain 'states' or named constant values. For example, in (Math.Mean) the value for :Kind parameter needs to be of type Enum . 1 2 3 ( Math.Mean :Kind [( Enum )] ) (Math.Mean) computes the mean of a sequence of floating-point numbers. But there are three kinds of means - Arithmetic mean, Geometric mean, and Harmonic mean. So the parameter :Kind is defined as an enum variable with these three fixed states : :Kind = {Arithmtic mean, Geometric mean, Harmonic mean} And hence :Kind expects a value that matches one of its possible states. In other words the value you pass in for :Kind needs to be an enumerated data type. In simple terms it just means that you pass in one of the allowed named constant values. Anything else will fail validation. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [ 2.0 10.0 ] ( Math.Mean :Kind Mean.Arithmetic ) ( Log ) ;; AM => 6 [ 2.0 10.0 ] ( Math.Mean :Kind Mean.Geometric ) ( Log ) ;; GM => 4.47214 [ 2.0 10.0 ] ( Math.Mean :Kind Mean.Harmonic ) ( Log ) ;; HM => 3.33333 [ 2.0 10.0 ] ( Math.Mean ;; AM is default, anything else will throw error ;; :Kind 123 ) ( Log ) ;; AM => 6 [info] [2022-07-22 15:35:00.868] [T-15316] [logging.cpp::55] [mywire] 6 [info] [2022-07-22 15:35:00.881] [T-15316] [logging.cpp::55] [mywire] 4.47214 [info] [2022-07-22 15:35:00.882] [T-15316] [logging.cpp::55] [mywire] 3.33333 [info] [2022-07-22 15:35:00.883] [T-15316] [logging.cpp::55] [mywire] 6","title":"Enum"},{"location":"shards/types/#float","text":"Type Float defines a 64-bit signed floating point number. Note Has keyword float and alias Float . Floating point means it has the capability to store a decimal point and hence supports decimal numbers. 64 bits of memory allows this data type to support a very large range of positive and negative decimal numbers (16 significant decimal digits and an exponent range of \u2212383 to +384). A Float value looks like this: (float 2.53) . It may also be represented without the keyword float , with just the floating-point value: 2.53 . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 4 5 ( float 2.4 ) ( Math.Add ( float 1.43 )) ( Log ) ;; float output => 3.83 2.4 ( Math.Add 1.43 ) ( Log ) ;; float output => 3.83 [info] [2022-07-22 22:06:32.856] [T-20204] [logging.cpp::55] [mywire] 3.83 [info] [2022-07-22 22:06:32.873] [T-20204] [logging.cpp::55] [mywire] 3.83","title":"Float"},{"location":"shards/types/#float2","text":"Type Float2 defines a vector of two Float type numbers. Note Has keyword float2 and alias Float2 . A vector can be thought of as a group or list of items that are considered together for processing. A Float2 type value looks like this: (float2 3.4 -5.0) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( float2 4.1 5.0 ) ( Math.Add ( float2 6.3 9.2 )) ( Log ) ;; float2 output => (10.4, 14.2) ``` [info] [2022-07-22 22:10:00.688] [T-24616] [logging.cpp::55] [mywire] (10.4, 14.2) ```","title":"Float2"},{"location":"shards/types/#float3","text":"Type Float3 defines a vector of three 32-bit signed floating point numbers. Note Has keyword float3 and alias Float3 . Floating point means it has the capability to store a decimal point and hence supports decimal numbers. 32 bits of memory allows this data type to support a large range of positive and negative decimal numbers (7 significant decimal digits and an exponent range of \u2212101 to +90). A Float3 type value looks like this: (float3 2.9 -4.23 7.83) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( float3 1.2 3.4 5.6 ) ( Math.Add ( float3 6.5 4.3 2.1 )) ( Log ) ;; float3 output => (7.7, 7.7, 7.7) [info] [2022-07-22 22:19:36.923] [T-16128] [logging.cpp::55] [mywire] (7.7, 7.7, 7.7)","title":"Float3"},{"location":"shards/types/#float4","text":"Type Float4 is like type Float3 but is a vector of four 32-bit signed floating point numbers instead. Note Has keyword float4 and alias Float4 . A Float4 type value looks like this: (float4 -8.84 38.2 4.7 0.4) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 ( float4 3.1 6.4 9.2 4.6 ) ( Math.Add ( float4 6.8 3.5 0.9 5.3 )) ( Log ) ;; Int4 output => (9.9, 9.9, 9.9, 9.9) [info] [2022-07-22 22:23:24.076] [T-25152] [logging.cpp::55] [mywire] (9.9, 9.9, 10.1, 9.9)","title":"Float4"},{"location":"shards/types/#image","text":"Type Image is uncompressed image data. A shard that uses this type is (StripAlpha) . This takes an Image type input, strips out its alpha (transparency) channel, and outputs an Image type (transformed image). Supported formats Shards supports the image formats PNG and SVG.","title":"Image"},{"location":"shards/types/#int","text":"Type Int defines a 64-bit signed integer. Note Has keyword int and alias Int . 64 bits of memory allows this data type to store integer values ranging from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807 (no decimals). An Int value looks like this: (int 2) . It may also be represented without the keyword int , with just the integer value: 2 . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 4 5 ( int 3 ) ( Math.Add ( int 2 )) ( Log ) ;; int output => 5 3 ( Math.Add 2 ) ( Log ) ;; int output => 5 [info] [2022-07-22 21:20:18.771] [T-4568] [logging.cpp::55] [mywire] 5 [info] [2022-07-22 21:20:18.782] [T-4568] [logging.cpp::55] [mywire] 5","title":"Int"},{"location":"shards/types/#int2","text":"Type Int2 defines a vector of two Int type numbers. Note Has keyword int2 and alias Int2 . A vector can be thought of as a group or list of items that are considered together for processing. An Int2 type value looks like this: (int2 3 -5) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( int2 4 5 ) ( Math.Add ( int2 6 9 )) ( Log ) ;; int2 output => (10, 14) [info] [2022-07-22 21:22:26.381] [T-17748] [logging.cpp::55] [mywire] (10, 14)","title":"Int2"},{"location":"shards/types/#int3","text":"Type Int3 defines a vector of three 32-bit signed integers. Note Has keyword int3 and alias Int3 . 32 bits of memory for each number allows this data type to store integer values ranging from -2147483648 to +2147483647 (no decimals). An Int3 type value looks like this: (int3 2 4 -4) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 ( int3 1 10 99 ) ( Math.Add ( int3 99 90 1 )) ( Log ) ;; int3 output => (100, 100, 100) [info] [2022-07-22 21:24:38.132] [T-25580] [logging.cpp::55] [mywire] (100, 100, 100)","title":"Int3"},{"location":"shards/types/#int4","text":"Type Int4 is like type Int3 but is a vector of four 32-bit signed integers instead. Note Has keyword int4 and alias Int4 . An Int4 type value looks like this: (int4 1 -4 0 3) . (Math.Add) is an example of a shard that uses this data type for its input, output, and :Operand parameter. Code Output 1 2 3 ( int4 3 6 9 4 ) ( Math.Add ( int4 6 3 0 5 )) ( Log ) ;; int4 output => (9, 9, 9, 9) [info] [2022-07-22 21:27:58.115] [T-20884] [logging.cpp::55] [mywire] (9, 9, 9, 9)","title":"Int4"},{"location":"shards/types/#int8","text":"Type Int8 defines a vector of eight 16-bit signed integers. 16 bits of memory for each number allows this data type to store integer values ranging from \u221232,768 to +32,767 (no decimals). The shard (Math.Add) accepts Int8 as input and as its :Operand . The shard adds these up outputs the sum as another vector of 8 integers or Int8 data type.","title":"Int8"},{"location":"shards/types/#int16","text":"Type Int16 defines a vector of sixteen 8-bit signed integers. 8 bits of memory for each number allows this data type to store integer values ranging from \u2212128 to +127 (no decimals). The shard (Math.Add) accepts Int16 as input and as its :Operand . The shard adds these up outputs the sum as another vector of 16 integers or Int16 data type.","title":"Int16"},{"location":"shards/types/#none","text":"Type None indicates that no data type is expected. This implies that no value is expected. For example, None as one of the valid data types for :Max parameter in shard (RandomInt) means that setting a value for this parameter is not mandatory. 1 2 3 ( RandomInt :Max [( None ) ( Int ) ( ContextVar [( Int )])] ) (RandomInt) generates a random integer and the :Max parameter is the upper limit (not inclusive) of the value that can be generated. So it makes sense to have None as one of the valid types for this :Max parameter for cases when you do not want an upper limit on the random integer (though in this case the system will inherently set the upper limit to the maximum value a 64-bit signed integer can hold: 9,223,372,036,854,775,807). Code Output 1 2 3 4 5 ( RandomInt 8 ) ( Log ) ;; max int that can be generated is 7 ( RandomInt ) ( Log ) ;; now upper limit subject to max capacity of a 64-bit signed integer [info] [2022-07-22 13:45:03.282] [T-19992] [logging.cpp::55] [mywire] 4 [info] [2022-07-22 13:45:03.293] [T-19992] [logging.cpp::55] [mywire] 311828859","title":"None"},{"location":"shards/types/#object","text":"Type Object is an opaque data type in Shards. Opacity in a data type means that the structure of this kind of data is not defined in an interface and is visible only to shards that use this type. What this also implies is that the internal structure of this data type will vary from shard to shard. For example, the :Socket parameter object of (WS.ReadString) is different from the output object of (GFX.DrawQueue) , even though both are of type Object .","title":"Object"},{"location":"shards/types/#path","text":"Type Path is String type data that is expected to contain a valid path (your operating system or local machine) for loading resources like script files, images, audio files etc. Note Has keyword path and alias Path . A valid Path type data string would look like this: \"../../external/sample-models/Avocado.glb\" Note For shards this type is the same as String type as far as type validations are concerned (when you execute your script Shards first checks the types before running your code). However,if the path-string passed is invalid, malformed, or missing the resource to be loaded, the shard will complain with an error message at runtime (i.e., when your code actually runs). A shard that uses this type is (Process.Run) . This shard takes a Path type in its :Executable parameter.","title":"Path"},{"location":"shards/types/#set","text":"Type Set is a collection of unique values. It's different from other collections like Seq and Array , both of which can contain non-unique or duplicate items. An example of a Set type data would be (22 3 378 4) .","title":"Set"},{"location":"shards/types/#seq","text":"Type Seq is a collection of values that can be accessed sequentially (i.e., they're iterable). Note Has keyword seq . Also called a sequence. An example of Seq type would be [7 2 54 42] . The shard (Take) works on this type. This shard can access Seq elements by their position. Code Output 1 2 [ 7 2 54 42 ] ( Take 2 ) ( Log ) ;; print the 2nd element => 54 [info] [2022-07-26 22:24:48.918] [T-20928] [logging.cpp::55] [mywire] 54","title":"Seq"},{"location":"shards/types/#shardref","text":"Type ShardRef (also called type Shard ) represents a shard being passed as data. This type is an important aspect of the homoiconicity feature (i.e., code/data interchangeability) in Shards. Note What's a shard ? The shard (ForEach) expects type ShardRef for its :Apply parameter (the other option being a sequence of ShardRef type values, i.e., a Wire type). (ForEach) then applies this shard (or sequence of shards) on its input to transform it into its output.","title":"ShardRef"},{"location":"shards/types/#string","text":"Type String represents string data (any data enclosed within double quotes). Note Has keyword string and alias String . A String value looks like this: (string \"Hello @Tom!\") . It may also be represented without the keyword string , with just the data within double quotes: \"Hello @Tom!\" . An example of a shard that processes String type data is (String.ToUpper) . This shard takes a String and converts it into its upper case version. Code Output 1 2 3 4 5 ( string \"Hello World!\" ) ( String.ToUpper ) ( Log ) ;; upper case version => HELLO WORLD! \"Bye Universe!\" ( String.ToUpper ) ( Log ) ;; upper case version => BYE UNIVERSE! [info] [2022-07-26 19:38:14.813] [T-18168] [logging.cpp::55] [mywire] Bytes: 0x20440058720 size: 11","title":"String"},{"location":"shards/types/#table","text":"Type Table is a collection of key/value pairs. Its also known as map, data dictionary, or associative array. An example of a Table type would be: {:key1 \"Hello\" :key2 \"World\"} . Code Output 1 2 3 { :k1 123 } >= .tabvar ;; .tabvar is type `Table` now .tabvar ( ExpectTable ) ( Log ) ;; `ExpectTable` outputs `Table` type => {k1: 123} [info] [2022-07-26 22:46:17.194] [T-26104] [logging.cpp::55] [mywire] {k1: 123}","title":"Table"},{"location":"shards/types/#wire","text":"Type Wire represents a wire being passed as data. Note Has keyword Wire . A Wire type thus consists of a sequence of shards (which make up the wire), their shared state (memory) context, name of the wire, and other properties that enable operations on the wire like scheduling it on a mesh, starting/stopping/pausing the wire, etc. Note What's a wire ? For example, the shard (Stop) accepts Wire type data in its :Wire parameter and stops that wire's execution if its currently running.","title":"Wire"},{"location":"shards/Assert/Is/","text":"Assert.Is \u00b6 ( Assert.Is :Value [( Any )] :Abort [( Bool )] ) Definition \u00b6 This assertion is used to check whether the input is equal to a given value. Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Abort [(Bool)] false If we should abort the process on failure. Input \u00b6 Type Description [(Any)] The input can be of any type. Output \u00b6 Type Description [(Any)] The output will be the input (passthrough). Details \u00b6 If the assertion is satisfied (i.e., the input is equal to or same as the :Value parameter) the program will is allowed to continue (control passes to the next shard), irrespective of the :Abort parameter . However, if the assertion fails, the program - aborts with an error dump if the :Abort parameter is set to true - logs an assertion validation error but continues running (control passes to the next wire scheduled on the mesh). Since this shard can precisely control the conditions under which a program is allowed to run or is to be aborted, it's effective for writing (inline) unit test cases with it. See also Assert.IsNot Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `true`, assertion true ;; => log no errors and don't abort program 8 ( Assert.Is ;:Value 8 ;:Abort true ) Code Output 1 2 3 4 5 6 7 8 9 10 ;; :Abort = `true`, assertion false ;; => abort the program 7 ( Assert.Is ;:Value 8 ;:Abort ;; uncomment next line to abort program on run ; true ) [error] [2022-08-15 10:09:06.275] [T-968] [assert.cpp::66] Failed assertion Is, input: 7 expected: 8 [error] [2022-08-15 10:09:06.275] [T-968] [runtime.cpp::747] Shard activation error, failed shard: Assert.Is, error: Assert failed - Is Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion true ;; => log no errors and don't abort program 8 ( Assert.Is ;:Value 8 ;:Abort false ) Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion false ;; => log assertion error but don't abort program 7 ( Assert.Is ;:Value 8 ;:Abort false ) [error] [2022-08-15 10:09:06.414] [T-4368] [assert.cpp::66] Failed assertion Is, input: 7 expected: 8 [error] [2022-08-15 10:09:06.415] [T-4368] [runtime.cpp::747] Shard activation error, failed shard: Assert.Is, error: Assert failed - Is","title":"Assert.Is"},{"location":"shards/Assert/Is/#assertis","text":"( Assert.Is :Value [( Any )] :Abort [( Bool )] )","title":"Assert.Is"},{"location":"shards/Assert/Is/#definition","text":"This assertion is used to check whether the input is equal to a given value.","title":"Definition"},{"location":"shards/Assert/Is/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality. Abort [(Bool)] false If we should abort the process on failure.","title":"Parameters"},{"location":"shards/Assert/Is/#input","text":"Type Description [(Any)] The input can be of any type.","title":"Input"},{"location":"shards/Assert/Is/#output","text":"Type Description [(Any)] The output will be the input (passthrough).","title":"Output"},{"location":"shards/Assert/Is/#details","text":"If the assertion is satisfied (i.e., the input is equal to or same as the :Value parameter) the program will is allowed to continue (control passes to the next shard), irrespective of the :Abort parameter . However, if the assertion fails, the program - aborts with an error dump if the :Abort parameter is set to true - logs an assertion validation error but continues running (control passes to the next wire scheduled on the mesh). Since this shard can precisely control the conditions under which a program is allowed to run or is to be aborted, it's effective for writing (inline) unit test cases with it. See also Assert.IsNot","title":"Details"},{"location":"shards/Assert/Is/#examples","text":"Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `true`, assertion true ;; => log no errors and don't abort program 8 ( Assert.Is ;:Value 8 ;:Abort true ) Code Output 1 2 3 4 5 6 7 8 9 10 ;; :Abort = `true`, assertion false ;; => abort the program 7 ( Assert.Is ;:Value 8 ;:Abort ;; uncomment next line to abort program on run ; true ) [error] [2022-08-15 10:09:06.275] [T-968] [assert.cpp::66] Failed assertion Is, input: 7 expected: 8 [error] [2022-08-15 10:09:06.275] [T-968] [runtime.cpp::747] Shard activation error, failed shard: Assert.Is, error: Assert failed - Is Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion true ;; => log no errors and don't abort program 8 ( Assert.Is ;:Value 8 ;:Abort false ) Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion false ;; => log assertion error but don't abort program 7 ( Assert.Is ;:Value 8 ;:Abort false ) [error] [2022-08-15 10:09:06.414] [T-4368] [assert.cpp::66] Failed assertion Is, input: 7 expected: 8 [error] [2022-08-15 10:09:06.415] [T-4368] [runtime.cpp::747] Shard activation error, failed shard: Assert.Is, error: Assert failed - Is","title":"Examples"},{"location":"shards/Assert/IsNot/","text":"Assert.IsNot \u00b6 ( Assert.IsNot :Value [( Any )] :Abort [( Bool )] ) Definition \u00b6 This assertion is used to check whether the input is different from a given value. Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Abort [(Bool)] false If we should abort the process on failure. Input \u00b6 Type Description [(Any)] The input can be of any type. Output \u00b6 Type Description [(Any)] The output will be the input (passthrough). Details \u00b6 In this shard it's the inequality that's asserted. This means the assertion is considered successful if input to this shard does not match the :Value parameter of this shard. The rest of behaviour of this shard (including the impact of the value of the :Abort parameter) is identical to Assert.Is . Just like Assert.Is , this shard too can be used for writing (inline) unit test cases. See also Assert.Is Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `true`, assertion true ;; => log no errors and don't abort program 8 ( Assert.IsNot ;:Value 16 ;:Abort true ) Code Output 1 2 3 4 5 6 7 8 9 10 ;; :Abort = `true`, assertion false ;; => abort the program 8 ( Assert.IsNot ;:Value 8 ;:Abort ;; uncomment next line to abort program on run ; true ) [error] [2022-08-15 10:09:06.556] [T-4624] [assert.cpp::84] Failed assertion IsNot, input: 8 not expected: 8 [error] [2022-08-15 10:09:06.557] [T-4624] [runtime.cpp::747] Shard activation error, failed shard: Assert.IsNot, error: Assert failed - IsNot Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion true ;; => log no errors and don't abort program 8 ( Assert.IsNot ;:Value 16 ;:Abort false ) Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion false ;; => log assertion error but don't abort program 8 ( Assert.IsNot ;:Value 8 ;:Abort false ) [error] [2022-08-15 10:09:06.694] [T-4908] [assert.cpp::84] Failed assertion IsNot, input: 8 not expected: 8 [error] [2022-08-15 10:09:06.694] [T-4908] [runtime.cpp::747] Shard activation error, failed shard: Assert.IsNot, error: Assert failed - IsNot","title":"Assert.IsNot"},{"location":"shards/Assert/IsNot/#assertisnot","text":"( Assert.IsNot :Value [( Any )] :Abort [( Bool )] )","title":"Assert.IsNot"},{"location":"shards/Assert/IsNot/#definition","text":"This assertion is used to check whether the input is different from a given value.","title":"Definition"},{"location":"shards/Assert/IsNot/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality. Abort [(Bool)] false If we should abort the process on failure.","title":"Parameters"},{"location":"shards/Assert/IsNot/#input","text":"Type Description [(Any)] The input can be of any type.","title":"Input"},{"location":"shards/Assert/IsNot/#output","text":"Type Description [(Any)] The output will be the input (passthrough).","title":"Output"},{"location":"shards/Assert/IsNot/#details","text":"In this shard it's the inequality that's asserted. This means the assertion is considered successful if input to this shard does not match the :Value parameter of this shard. The rest of behaviour of this shard (including the impact of the value of the :Abort parameter) is identical to Assert.Is . Just like Assert.Is , this shard too can be used for writing (inline) unit test cases. See also Assert.Is","title":"Details"},{"location":"shards/Assert/IsNot/#examples","text":"Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `true`, assertion true ;; => log no errors and don't abort program 8 ( Assert.IsNot ;:Value 16 ;:Abort true ) Code Output 1 2 3 4 5 6 7 8 9 10 ;; :Abort = `true`, assertion false ;; => abort the program 8 ( Assert.IsNot ;:Value 8 ;:Abort ;; uncomment next line to abort program on run ; true ) [error] [2022-08-15 10:09:06.556] [T-4624] [assert.cpp::84] Failed assertion IsNot, input: 8 not expected: 8 [error] [2022-08-15 10:09:06.557] [T-4624] [runtime.cpp::747] Shard activation error, failed shard: Assert.IsNot, error: Assert failed - IsNot Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion true ;; => log no errors and don't abort program 8 ( Assert.IsNot ;:Value 16 ;:Abort false ) Code Output 1 2 3 4 5 6 7 8 ;; :Abort = `false`, assertion false ;; => log assertion error but don't abort program 8 ( Assert.IsNot ;:Value 8 ;:Abort false ) [error] [2022-08-15 10:09:06.694] [T-4908] [assert.cpp::84] Failed assertion IsNot, input: 8 not expected: 8 [error] [2022-08-15 10:09:06.694] [T-4908] [runtime.cpp::747] Shard activation error, failed shard: Assert.IsNot, error: Assert failed - IsNot","title":"Examples"},{"location":"shards/Audio/Channel/","text":"Audio.Channel \u00b6 Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.Channel :InputBus [( Int )] :InputChannels [( Seq [( Int )])] :OutputBus [( Int )] :OutputChannels [( Seq [( Int )])] :Volume [( Float ) ( ContextVar [( Float )])] :Shards [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description InputBus [(Int)] 0 The input bus number, 0 is the audio device ADC. InputChannels [(Seq [(Int)])] None The list of input channels to pass as input to Shards. OutputBus [(Int)] 0 The output bus number, 0 is the audio device DAC. OutputChannels [(Seq [(Int)])] None The list of output channels to write from Shards's output. Volume [(Float) (ContextVar [(Float)])] 0.7 The volume of this channel. Shards [(Shard) (Seq [(Shard)]) (None)] None The shards that will process audio data. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Audio.Channel"},{"location":"shards/Audio/Channel/#audiochannel","text":"Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.Channel :InputBus [( Int )] :InputChannels [( Seq [( Int )])] :OutputBus [( Int )] :OutputChannels [( Seq [( Int )])] :Volume [( Float ) ( ContextVar [( Float )])] :Shards [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Audio.Channel"},{"location":"shards/Audio/Channel/#definition","text":"","title":"Definition"},{"location":"shards/Audio/Channel/#parameters","text":"Name Type Default Description InputBus [(Int)] 0 The input bus number, 0 is the audio device ADC. InputChannels [(Seq [(Int)])] None The list of input channels to pass as input to Shards. OutputBus [(Int)] 0 The output bus number, 0 is the audio device DAC. OutputChannels [(Seq [(Int)])] None The list of output channels to write from Shards's output. Volume [(Float) (ContextVar [(Float)])] 0.7 The volume of this channel. Shards [(Shard) (Seq [(Shard)]) (None)] None The shards that will process audio data.","title":"Parameters"},{"location":"shards/Audio/Channel/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Audio/Channel/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Audio/Device/","text":"Audio.Device \u00b6 Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.Device ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Audio.Device"},{"location":"shards/Audio/Device/#audiodevice","text":"Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.Device )","title":"Audio.Device"},{"location":"shards/Audio/Device/#definition","text":"","title":"Definition"},{"location":"shards/Audio/Device/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Audio/Device/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Audio/Oscillator/","text":"Audio.Oscillator \u00b6 Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.Oscillator :Type [( Enum )] :Amplitude [( Float ) ( ContextVar [( Float )])] :Channels [( Int )] :SampleRate [( Int )] :Samples [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Type [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x77617665 The waveform type to oscillate. Amplitude [(Float) (ContextVar [(Float)])] 0.4 The waveform amplitude. Channels [(Int)] 2 The number of desired output audio channels. SampleRate [(Int)] 44100 The desired output sampling rate. Ignored if inside an Audio.Channel. Samples [(Int)] 1024 The desired number of samples in the output. Ignored if inside an Audio.Channel. Input \u00b6 Type Description [(Float)] Output \u00b6 Type Description [(Audio)]","title":"Audio.Oscillator"},{"location":"shards/Audio/Oscillator/#audiooscillator","text":"Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.Oscillator :Type [( Enum )] :Amplitude [( Float ) ( ContextVar [( Float )])] :Channels [( Int )] :SampleRate [( Int )] :Samples [( Int )] )","title":"Audio.Oscillator"},{"location":"shards/Audio/Oscillator/#definition","text":"","title":"Definition"},{"location":"shards/Audio/Oscillator/#parameters","text":"Name Type Default Description Type [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x77617665 The waveform type to oscillate. Amplitude [(Float) (ContextVar [(Float)])] 0.4 The waveform amplitude. Channels [(Int)] 2 The number of desired output audio channels. SampleRate [(Int)] 44100 The desired output sampling rate. Ignored if inside an Audio.Channel. Samples [(Int)] 1024 The desired number of samples in the output. Ignored if inside an Audio.Channel.","title":"Parameters"},{"location":"shards/Audio/Oscillator/#input","text":"Type Description [(Float)]","title":"Input"},{"location":"shards/Audio/Oscillator/#output","text":"Type Description [(Audio)]","title":"Output"},{"location":"shards/Audio/ReadFile/","text":"Audio.ReadFile \u00b6 Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.ReadFile :File [( String ) ( ContextVar [( String )])] :Channels [( Int )] :SampleRate [( Int )] :Samples [( Int )] :Looped [( Bool )] :From [( Float ) ( ContextVar [( Float )]) ( None )] :To [( Float ) ( ContextVar [( Float )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description File [(String) (ContextVar [(String)])] None The audio file to read from (wav,ogg,mp3,flac). Channels [(Int)] 2 The number of desired output audio channels. SampleRate [(Int)] 44100 The desired output sampling rate. Ignored if inside an Audio.Channel. Samples [(Int)] 1024 The desired number of samples in the output. Ignored if inside an Audio.Channel. Looped [(Bool)] false If the file should be played in loop or should stop the wire when it ends. From [(Float) (ContextVar [(Float)]) (None)] None The starting time in seconds. To [(Float) (ContextVar [(Float)]) (None)] None The end time in seconds. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Audio)]","title":"Audio.ReadFile"},{"location":"shards/Audio/ReadFile/#audioreadfile","text":"Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.ReadFile :File [( String ) ( ContextVar [( String )])] :Channels [( Int )] :SampleRate [( Int )] :Samples [( Int )] :Looped [( Bool )] :From [( Float ) ( ContextVar [( Float )]) ( None )] :To [( Float ) ( ContextVar [( Float )]) ( None )] )","title":"Audio.ReadFile"},{"location":"shards/Audio/ReadFile/#definition","text":"","title":"Definition"},{"location":"shards/Audio/ReadFile/#parameters","text":"Name Type Default Description File [(String) (ContextVar [(String)])] None The audio file to read from (wav,ogg,mp3,flac). Channels [(Int)] 2 The number of desired output audio channels. SampleRate [(Int)] 44100 The desired output sampling rate. Ignored if inside an Audio.Channel. Samples [(Int)] 1024 The desired number of samples in the output. Ignored if inside an Audio.Channel. Looped [(Bool)] false If the file should be played in loop or should stop the wire when it ends. From [(Float) (ContextVar [(Float)]) (None)] None The starting time in seconds. To [(Float) (ContextVar [(Float)]) (None)] None The end time in seconds.","title":"Parameters"},{"location":"shards/Audio/ReadFile/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Audio/ReadFile/#output","text":"Type Description [(Audio)]","title":"Output"},{"location":"shards/Audio/WriteFile/","text":"Audio.WriteFile \u00b6 Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.WriteFile :File [( String ) ( ContextVar [( String )])] :Channels [( Int )] :SampleRate [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description File [(String) (ContextVar [(String)])] None The audio file to read from (wav,ogg,mp3,flac). Channels [(Int)] 2 The number of desired output audio channels. SampleRate [(Int)] 44100 The desired output sampling rate. Input \u00b6 Type Description [(Audio)] Output \u00b6 Type Description [(Audio)]","title":"Audio.WriteFile"},{"location":"shards/Audio/WriteFile/#audiowritefile","text":"Experimental/unstable This API is experimental and might produce unexpected results or crash. ( Audio.WriteFile :File [( String ) ( ContextVar [( String )])] :Channels [( Int )] :SampleRate [( Int )] )","title":"Audio.WriteFile"},{"location":"shards/Audio/WriteFile/#definition","text":"","title":"Definition"},{"location":"shards/Audio/WriteFile/#parameters","text":"Name Type Default Description File [(String) (ContextVar [(String)])] None The audio file to read from (wav,ogg,mp3,flac). Channels [(Int)] 2 The number of desired output audio channels. SampleRate [(Int)] 44100 The desired output sampling rate.","title":"Parameters"},{"location":"shards/Audio/WriteFile/#input","text":"Type Description [(Audio)]","title":"Input"},{"location":"shards/Audio/WriteFile/#output","text":"Type Description [(Audio)]","title":"Output"},{"location":"shards/BigInt/Abs/","text":"BigInt.Abs \u00b6 ( BigInt.Abs ) Definition \u00b6 Computes the absolute value of a big integer. Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Examples \u00b6 Code Output 1 2 3 4 5 1 ( BigInt ) = .expected -1 ( BigInt ) ( BigInt.Abs ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Abs"},{"location":"shards/BigInt/Abs/#bigintabs","text":"( BigInt.Abs )","title":"BigInt.Abs"},{"location":"shards/BigInt/Abs/#definition","text":"Computes the absolute value of a big integer.","title":"Definition"},{"location":"shards/BigInt/Abs/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/Abs/#output","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Output"},{"location":"shards/BigInt/Abs/#examples","text":"Code Output 1 2 3 4 5 1 ( BigInt ) = .expected -1 ( BigInt ) ( BigInt.Abs ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Add/","text":"BigInt.Add \u00b6 ( BigInt.Add :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 7 ( BigInt ) = .expected 4 ( BigInt ) = .operand 3 ( BigInt ) ( BigInt.Add ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Add"},{"location":"shards/BigInt/Add/#bigintadd","text":"( BigInt.Add :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Add"},{"location":"shards/BigInt/Add/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Add/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Add/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Add/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Add/#examples","text":"Code Output 1 2 3 4 5 6 7 8 7 ( BigInt ) = .expected 4 ( BigInt ) = .operand 3 ( BigInt ) ( BigInt.Add ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/And/","text":"BigInt.And \u00b6 ( BigInt.And :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 2 ( BigInt ) = .expected 3 ( BigInt ) = .operand 6 ( BigInt ) ( BigInt.And ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.And"},{"location":"shards/BigInt/And/#bigintand","text":"( BigInt.And :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.And"},{"location":"shards/BigInt/And/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/And/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/And/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/And/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/And/#examples","text":"Code Output 1 2 3 4 5 6 7 8 2 ( BigInt ) = .expected 3 ( BigInt ) = .operand 6 ( BigInt ) ( BigInt.And ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Divide/","text":"BigInt.Divide \u00b6 ( BigInt.Divide :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 4 ( BigInt ) = .expected 2 ( BigInt ) = .operand 8 ( BigInt ) ( BigInt.Divide ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Divide"},{"location":"shards/BigInt/Divide/#bigintdivide","text":"( BigInt.Divide :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Divide"},{"location":"shards/BigInt/Divide/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Divide/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Divide/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Divide/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Divide/#examples","text":"Code Output 1 2 3 4 5 6 7 8 4 ( BigInt ) = .expected 2 ( BigInt ) = .operand 8 ( BigInt ) ( BigInt.Divide ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/FromFloat/","text":"BigInt.FromFloat \u00b6 ( BigInt.FromFloat :ShiftedBy [( Int )] ) Definition \u00b6 Converts a floating point number to a big integer. Parameters \u00b6 Name Type Default Description ShiftedBy [(Int)] 0 The shift is of the decimal point, i.e. of powers of ten, and is to the left if n is negative or to the right if n is positive. Input \u00b6 Type Description [(Float)] Floating point number. Output \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Examples \u00b6 Code Output 1 2 3 4 42 ( BigInt ) = .expected 42.1 ( BigInt.FromFloat ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.FromFloat"},{"location":"shards/BigInt/FromFloat/#bigintfromfloat","text":"( BigInt.FromFloat :ShiftedBy [( Int )] )","title":"BigInt.FromFloat"},{"location":"shards/BigInt/FromFloat/#definition","text":"Converts a floating point number to a big integer.","title":"Definition"},{"location":"shards/BigInt/FromFloat/#parameters","text":"Name Type Default Description ShiftedBy [(Int)] 0 The shift is of the decimal point, i.e. of powers of ten, and is to the left if n is negative or to the right if n is positive.","title":"Parameters"},{"location":"shards/BigInt/FromFloat/#input","text":"Type Description [(Float)] Floating point number.","title":"Input"},{"location":"shards/BigInt/FromFloat/#output","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Output"},{"location":"shards/BigInt/FromFloat/#examples","text":"Code Output 1 2 3 4 42 ( BigInt ) = .expected 42.1 ( BigInt.FromFloat ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Is/","text":"BigInt.Is \u00b6 ( BigInt.Is :Operand [( ContextVar [( Bytes )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bool)] A boolean value repesenting the result of the logic operation. Examples \u00b6 Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 11 ( BigInt ) ( BigInt.Is ;:Operand .expected ) ( Assert.Is true true )","title":"BigInt.Is"},{"location":"shards/BigInt/Is/#bigintis","text":"( BigInt.Is :Operand [( ContextVar [( Bytes )])] )","title":"BigInt.Is"},{"location":"shards/BigInt/Is/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/Is/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Is/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/Is/#output","text":"Type Description [(Bool)] A boolean value repesenting the result of the logic operation.","title":"Output"},{"location":"shards/BigInt/Is/#examples","text":"Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 11 ( BigInt ) ( BigInt.Is ;:Operand .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/IsLess/","text":"BigInt.IsLess \u00b6 ( BigInt.IsLess :Operand [( ContextVar [( Bytes )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bool)] A boolean value repesenting the result of the logic operation. Examples \u00b6 Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 9 ( BigInt ) ( BigInt.IsLess ;:Operand .expected ) ( Assert.Is true true )","title":"BigInt.IsLess"},{"location":"shards/BigInt/IsLess/#bigintisless","text":"( BigInt.IsLess :Operand [( ContextVar [( Bytes )])] )","title":"BigInt.IsLess"},{"location":"shards/BigInt/IsLess/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/IsLess/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/IsLess/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/IsLess/#output","text":"Type Description [(Bool)] A boolean value repesenting the result of the logic operation.","title":"Output"},{"location":"shards/BigInt/IsLess/#examples","text":"Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 9 ( BigInt ) ( BigInt.IsLess ;:Operand .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/IsLessEqual/","text":"BigInt.IsLessEqual \u00b6 ( BigInt.IsLessEqual :Operand [( ContextVar [( Bytes )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bool)] A boolean value repesenting the result of the logic operation. Examples \u00b6 Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 9 ( BigInt ) ( BigInt.IsLessEqual ;:Operand .expected ) ( Assert.Is true true )","title":"BigInt.IsLessEqual"},{"location":"shards/BigInt/IsLessEqual/#bigintislessequal","text":"( BigInt.IsLessEqual :Operand [( ContextVar [( Bytes )])] )","title":"BigInt.IsLessEqual"},{"location":"shards/BigInt/IsLessEqual/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/IsLessEqual/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/IsLessEqual/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/IsLessEqual/#output","text":"Type Description [(Bool)] A boolean value repesenting the result of the logic operation.","title":"Output"},{"location":"shards/BigInt/IsLessEqual/#examples","text":"Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 9 ( BigInt ) ( BigInt.IsLessEqual ;:Operand .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/IsMore/","text":"BigInt.IsMore \u00b6 ( BigInt.IsMore :Operand [( ContextVar [( Bytes )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bool)] A boolean value repesenting the result of the logic operation. Examples \u00b6 Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 12 ( BigInt ) ( BigInt.IsMore ;:Operand .expected ) ( Assert.Is true true )","title":"BigInt.IsMore"},{"location":"shards/BigInt/IsMore/#bigintismore","text":"( BigInt.IsMore :Operand [( ContextVar [( Bytes )])] )","title":"BigInt.IsMore"},{"location":"shards/BigInt/IsMore/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/IsMore/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/IsMore/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/IsMore/#output","text":"Type Description [(Bool)] A boolean value repesenting the result of the logic operation.","title":"Output"},{"location":"shards/BigInt/IsMore/#examples","text":"Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 12 ( BigInt ) ( BigInt.IsMore ;:Operand .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/IsMoreEqual/","text":"BigInt.IsMoreEqual \u00b6 ( BigInt.IsMoreEqual :Operand [( ContextVar [( Bytes )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bool)] A boolean value repesenting the result of the logic operation. Examples \u00b6 Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 12 ( BigInt ) ( BigInt.IsMoreEqual ;:Operand .expected ) ( Assert.Is true true )","title":"BigInt.IsMoreEqual"},{"location":"shards/BigInt/IsMoreEqual/#bigintismoreequal","text":"( BigInt.IsMoreEqual :Operand [( ContextVar [( Bytes )])] )","title":"BigInt.IsMoreEqual"},{"location":"shards/BigInt/IsMoreEqual/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/IsMoreEqual/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/IsMoreEqual/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/IsMoreEqual/#output","text":"Type Description [(Bool)] A boolean value repesenting the result of the logic operation.","title":"Output"},{"location":"shards/BigInt/IsMoreEqual/#examples","text":"Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 12 ( BigInt ) ( BigInt.IsMoreEqual ;:Operand .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/IsNot/","text":"BigInt.IsNot \u00b6 ( BigInt.IsNot :Operand [( ContextVar [( Bytes )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bool)] A boolean value repesenting the result of the logic operation. Examples \u00b6 Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 9 ( BigInt ) ( BigInt.IsNot ;:Operand .expected ) ( Assert.Is true true )","title":"BigInt.IsNot"},{"location":"shards/BigInt/IsNot/#bigintisnot","text":"( BigInt.IsNot :Operand [( ContextVar [( Bytes )])] )","title":"BigInt.IsNot"},{"location":"shards/BigInt/IsNot/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/IsNot/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)])] None The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/IsNot/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/IsNot/#output","text":"Type Description [(Bool)] A boolean value repesenting the result of the logic operation.","title":"Output"},{"location":"shards/BigInt/IsNot/#examples","text":"Code Output 1 2 3 4 5 6 7 11 ( BigInt ) = .expected 9 ( BigInt ) ( BigInt.IsNot ;:Operand .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Max/","text":"BigInt.Max \u00b6 ( BigInt.Max :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 7 ( BigInt ) = .expected 4 ( BigInt ) = .operand 7 ( BigInt ) ( BigInt.Max ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Max"},{"location":"shards/BigInt/Max/#bigintmax","text":"( BigInt.Max :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Max"},{"location":"shards/BigInt/Max/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Max/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Max/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Max/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Max/#examples","text":"Code Output 1 2 3 4 5 6 7 8 7 ( BigInt ) = .expected 4 ( BigInt ) = .operand 7 ( BigInt ) ( BigInt.Max ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Min/","text":"BigInt.Min \u00b6 ( BigInt.Min :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 4 ( BigInt ) = .expected 4 ( BigInt ) = .operand 7 ( BigInt ) ( BigInt.Min ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Min"},{"location":"shards/BigInt/Min/#bigintmin","text":"( BigInt.Min :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Min"},{"location":"shards/BigInt/Min/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Min/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Min/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Min/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Min/#examples","text":"Code Output 1 2 3 4 5 6 7 8 4 ( BigInt ) = .expected 4 ( BigInt ) = .operand 7 ( BigInt ) ( BigInt.Min ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Mod/","text":"BigInt.Mod \u00b6 ( BigInt.Mod :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 3 ( BigInt ) = .expected 10 ( BigInt ) = .operand 13 ( BigInt ) ( BigInt.Mod ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Mod"},{"location":"shards/BigInt/Mod/#bigintmod","text":"( BigInt.Mod :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Mod"},{"location":"shards/BigInt/Mod/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Mod/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Mod/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Mod/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Mod/#examples","text":"Code Output 1 2 3 4 5 6 7 8 3 ( BigInt ) = .expected 10 ( BigInt ) = .operand 13 ( BigInt ) ( BigInt.Mod ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Multiply/","text":"BigInt.Multiply \u00b6 ( BigInt.Multiply :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 24 ( BigInt ) = .expected 3 ( BigInt ) = .operand 8 ( BigInt ) ( BigInt.Multiply ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Multiply"},{"location":"shards/BigInt/Multiply/#bigintmultiply","text":"( BigInt.Multiply :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Multiply"},{"location":"shards/BigInt/Multiply/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Multiply/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Multiply/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Multiply/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Multiply/#examples","text":"Code Output 1 2 3 4 5 6 7 8 24 ( BigInt ) = .expected 3 ( BigInt ) = .operand 8 ( BigInt ) ( BigInt.Multiply ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Or/","text":"BigInt.Or \u00b6 ( BigInt.Or :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 7 ( BigInt ) = .expected 3 ( BigInt ) = .operand 6 ( BigInt ) ( BigInt.Or ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Or"},{"location":"shards/BigInt/Or/#bigintor","text":"( BigInt.Or :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Or"},{"location":"shards/BigInt/Or/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Or/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Or/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Or/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Or/#examples","text":"Code Output 1 2 3 4 5 6 7 8 7 ( BigInt ) = .expected 3 ( BigInt ) = .operand 6 ( BigInt ) ( BigInt.Or ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Pow/","text":"BigInt.Pow \u00b6 ( BigInt.Pow :Operand [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)])] None The integer operand, can be a variable Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 ( BigInt ) = .expected 2 ( BigInt ) ( BigInt.Pow ;:Operand 3 ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Pow"},{"location":"shards/BigInt/Pow/#bigintpow","text":"( BigInt.Pow :Operand [( Int ) ( ContextVar [( Int )])] )","title":"BigInt.Pow"},{"location":"shards/BigInt/Pow/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/Pow/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)])] None The integer operand, can be a variable","title":"Parameters"},{"location":"shards/BigInt/Pow/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/Pow/#output","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Output"},{"location":"shards/BigInt/Pow/#examples","text":"Code Output 1 2 3 4 5 6 7 8 ( BigInt ) = .expected 2 ( BigInt ) ( BigInt.Pow ;:Operand 3 ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Shift/","text":"BigInt.Shift \u00b6 ( BigInt.Shift :By [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description By [(Int) (ContextVar [(Int)])] 0 The shift is of the decimal point, i.e. of powers of ten, and is to the left if n is negative or to the right if n is positive. Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Examples \u00b6 Code Output 1 2 3 4 5 6 7 4200 ( BigInt ) = .expected 42 ( BigInt ) ( BigInt.Shift ;:By 2 ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Shift"},{"location":"shards/BigInt/Shift/#bigintshift","text":"( BigInt.Shift :By [( Int ) ( ContextVar [( Int )])] )","title":"BigInt.Shift"},{"location":"shards/BigInt/Shift/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/Shift/#parameters","text":"Name Type Default Description By [(Int) (ContextVar [(Int)])] 0 The shift is of the decimal point, i.e. of powers of ten, and is to the left if n is negative or to the right if n is positive.","title":"Parameters"},{"location":"shards/BigInt/Shift/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/Shift/#output","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Output"},{"location":"shards/BigInt/Shift/#examples","text":"Code Output 1 2 3 4 5 6 7 4200 ( BigInt ) = .expected 42 ( BigInt ) ( BigInt.Shift ;:By 2 ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Sqrt/","text":"BigInt.Sqrt \u00b6 ( BigInt.Sqrt ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Examples \u00b6 Code Output 1 2 3 4 5 2 ( BigInt ) = .expected 4 ( BigInt ) ( BigInt.Sqrt ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Sqrt"},{"location":"shards/BigInt/Sqrt/#bigintsqrt","text":"( BigInt.Sqrt )","title":"BigInt.Sqrt"},{"location":"shards/BigInt/Sqrt/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/Sqrt/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/Sqrt/#output","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Output"},{"location":"shards/BigInt/Sqrt/#examples","text":"Code Output 1 2 3 4 5 2 ( BigInt ) = .expected 4 ( BigInt ) ( BigInt.Sqrt ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/Subtract/","text":"BigInt.Subtract \u00b6 ( BigInt.Subtract :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 5 ( BigInt ) = .expected 2 ( BigInt ) = .operand 7 ( BigInt ) ( BigInt.Subtract ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Subtract"},{"location":"shards/BigInt/Subtract/#bigintsubtract","text":"( BigInt.Subtract :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Subtract"},{"location":"shards/BigInt/Subtract/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Subtract/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Subtract/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Subtract/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Subtract/#examples","text":"Code Output 1 2 3 4 5 6 7 8 5 ( BigInt ) = .expected 2 ( BigInt ) = .operand 7 ( BigInt ) ( BigInt.Subtract ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/BigInt/ToBytes/","text":"BigInt.ToBytes \u00b6 ( BigInt.ToBytes :Bits [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Bits [(Int)] 0 The desired amount of bits for the output or 0 for automatic packing. Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Bytes)] Examples \u00b6 Code Output 1 2 3 4 5 6 42 ( BigInt ) ( BigInt.ToBytes ;:Bits 16 ) ( ToHex ) ( Assert.Is \"0x002a\" true )","title":"BigInt.ToBytes"},{"location":"shards/BigInt/ToBytes/#biginttobytes","text":"( BigInt.ToBytes :Bits [( Int )] )","title":"BigInt.ToBytes"},{"location":"shards/BigInt/ToBytes/#definition","text":"","title":"Definition"},{"location":"shards/BigInt/ToBytes/#parameters","text":"Name Type Default Description Bits [(Int)] 0 The desired amount of bits for the output or 0 for automatic packing.","title":"Parameters"},{"location":"shards/BigInt/ToBytes/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/ToBytes/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/BigInt/ToBytes/#examples","text":"Code Output 1 2 3 4 5 6 42 ( BigInt ) ( BigInt.ToBytes ;:Bits 16 ) ( ToHex ) ( Assert.Is \"0x002a\" true )","title":"Examples"},{"location":"shards/BigInt/ToFloat/","text":"BigInt.ToFloat \u00b6 ( BigInt.ToFloat :ShiftedBy [( Int )] ) Definition \u00b6 Converts a big integer value to a floating point number. Parameters \u00b6 Name Type Default Description ShiftedBy [(Int)] 0 The shift is of the decimal point, i.e. of powers of ten, and is to the left if n is negative or to the right if n is positive. Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Float)] Floating point number representation of the big integer value. Examples \u00b6 Code Output 1 2 3 4 5 3 ( BigInt ) ( BigInt.ToFloat ;:ShiftedBy 1 ) ( Assert.Is ( float 30.0 ) true )","title":"BigInt.ToFloat"},{"location":"shards/BigInt/ToFloat/#biginttofloat","text":"( BigInt.ToFloat :ShiftedBy [( Int )] )","title":"BigInt.ToFloat"},{"location":"shards/BigInt/ToFloat/#definition","text":"Converts a big integer value to a floating point number.","title":"Definition"},{"location":"shards/BigInt/ToFloat/#parameters","text":"Name Type Default Description ShiftedBy [(Int)] 0 The shift is of the decimal point, i.e. of powers of ten, and is to the left if n is negative or to the right if n is positive.","title":"Parameters"},{"location":"shards/BigInt/ToFloat/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/ToFloat/#output","text":"Type Description [(Float)] Floating point number representation of the big integer value.","title":"Output"},{"location":"shards/BigInt/ToFloat/#examples","text":"Code Output 1 2 3 4 5 3 ( BigInt ) ( BigInt.ToFloat ;:ShiftedBy 1 ) ( Assert.Is ( float 30.0 ) true )","title":"Examples"},{"location":"shards/BigInt/ToHex/","text":"BigInt.ToHex \u00b6 ( BigInt.ToHex ) Definition \u00b6 Converts the value to a hexadecimal representation. Input \u00b6 Type Description [(Int) (Bytes) (String)] Output \u00b6 Type Description [(String)] Hexadecimal representation of the integer value. Examples \u00b6 Code Output 1 2 3 42 ( BigInt ) ( BigInt.ToHex ) ( Assert.Is \"0x2a\" true )","title":"BigInt.ToHex"},{"location":"shards/BigInt/ToHex/#biginttohex","text":"( BigInt.ToHex )","title":"BigInt.ToHex"},{"location":"shards/BigInt/ToHex/#definition","text":"Converts the value to a hexadecimal representation.","title":"Definition"},{"location":"shards/BigInt/ToHex/#input","text":"Type Description [(Int) (Bytes) (String)]","title":"Input"},{"location":"shards/BigInt/ToHex/#output","text":"Type Description [(String)] Hexadecimal representation of the integer value.","title":"Output"},{"location":"shards/BigInt/ToHex/#examples","text":"Code Output 1 2 3 42 ( BigInt ) ( BigInt.ToHex ) ( Assert.Is \"0x2a\" true )","title":"Examples"},{"location":"shards/BigInt/ToInt/","text":"BigInt.ToInt \u00b6 ( BigInt.ToInt ) Definition \u00b6 Converts a big integer value to an integer. Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(Int)] Integer representation of the big integer value. Examples \u00b6 Code Output 1 2 3 42 ( BigInt ) ( BigInt.ToInt ) ( Assert.Is ( int 42 ) true )","title":"BigInt.ToInt"},{"location":"shards/BigInt/ToInt/#biginttoint","text":"( BigInt.ToInt )","title":"BigInt.ToInt"},{"location":"shards/BigInt/ToInt/#definition","text":"Converts a big integer value to an integer.","title":"Definition"},{"location":"shards/BigInt/ToInt/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/ToInt/#output","text":"Type Description [(Int)] Integer representation of the big integer value.","title":"Output"},{"location":"shards/BigInt/ToInt/#examples","text":"Code Output 1 2 3 42 ( BigInt ) ( BigInt.ToInt ) ( Assert.Is ( int 42 ) true )","title":"Examples"},{"location":"shards/BigInt/ToString/","text":"BigInt.ToString \u00b6 ( BigInt.ToString ) Definition \u00b6 Converts the value to a string representation. Input \u00b6 Type Description [(Bytes)] Big integer represented as bytes. Output \u00b6 Type Description [(String)] String representation of the big integer value. Examples \u00b6 Code Output 1 2 3 42 ( BigInt ) ( BigInt.Shift 20 ) ( BigInt.ToString ) ( Assert.Is \"4200000000000000000000\" true )","title":"BigInt.ToString"},{"location":"shards/BigInt/ToString/#biginttostring","text":"( BigInt.ToString )","title":"BigInt.ToString"},{"location":"shards/BigInt/ToString/#definition","text":"Converts the value to a string representation.","title":"Definition"},{"location":"shards/BigInt/ToString/#input","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Input"},{"location":"shards/BigInt/ToString/#output","text":"Type Description [(String)] String representation of the big integer value.","title":"Output"},{"location":"shards/BigInt/ToString/#examples","text":"Code Output 1 2 3 42 ( BigInt ) ( BigInt.Shift 20 ) ( BigInt.ToString ) ( Assert.Is \"4200000000000000000000\" true )","title":"Examples"},{"location":"shards/BigInt/Xor/","text":"BigInt.Xor \u00b6 ( BigInt.Xor :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation. Output \u00b6 Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 5 ( BigInt ) = .expected 3 ( BigInt ) = .operand 6 ( BigInt ) ( BigInt.Xor ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"BigInt.Xor"},{"location":"shards/BigInt/Xor/#bigintxor","text":"( BigInt.Xor :Operand [( ContextVar [( Bytes )]) ( ContextVar [( Seq [( Bytes )])])] )","title":"BigInt.Xor"},{"location":"shards/BigInt/Xor/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/BigInt/Xor/#parameters","text":"Name Type Default Description Operand [(ContextVar [(Bytes)]) (ContextVar [(Seq [(Bytes)])])] 0 The bytes variable representing the operand","title":"Parameters"},{"location":"shards/BigInt/Xor/#input","text":"Type Description [(Bytes) (Seq [(Bytes)])] Any valid big integer(s) represented as bytes supported by this operation.","title":"Input"},{"location":"shards/BigInt/Xor/#output","text":"Type Description [(Bytes) (Seq [(Bytes)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/BigInt/Xor/#examples","text":"Code Output 1 2 3 4 5 6 7 8 5 ( BigInt ) = .expected 3 ( BigInt ) = .operand 6 ( BigInt ) ( BigInt.Xor ;:Operand .operand ) ( BigInt.Is .expected ) ( Assert.Is true true )","title":"Examples"},{"location":"shards/Brotli/Compress/","text":"Brotli.Compress \u00b6 ( Brotli.Compress :Quality [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Quality [(Int)] 11 Compression quality, higher is better but slower, valid values from 1 to 11. Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"Brotli.Compress"},{"location":"shards/Brotli/Compress/#brotlicompress","text":"( Brotli.Compress :Quality [( Int )] )","title":"Brotli.Compress"},{"location":"shards/Brotli/Compress/#definition","text":"","title":"Definition"},{"location":"shards/Brotli/Compress/#parameters","text":"Name Type Default Description Quality [(Int)] 11 Compression quality, higher is better but slower, valid values from 1 to 11.","title":"Parameters"},{"location":"shards/Brotli/Compress/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/Brotli/Compress/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Brotli/Decompress/","text":"Brotli.Decompress \u00b6 ( Brotli.Decompress ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"Brotli.Decompress"},{"location":"shards/Brotli/Decompress/#brotlidecompress","text":"( Brotli.Decompress )","title":"Brotli.Decompress"},{"location":"shards/Brotli/Decompress/#definition","text":"","title":"Definition"},{"location":"shards/Brotli/Decompress/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/Brotli/Decompress/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/CSV/Read/","text":"CSV.Read \u00b6 ( CSV.Read :NoHeader [( Bool )] :Separator [( String )] ) Definition \u00b6 Reads a CSV string and outputs the data as a sequence of strings in a sequence of rows. Parameters \u00b6 Name Type Default Description NoHeader [(Bool)] false Whether the shard should parse the first row as data, instead of header. Separator [(String)] \",\" The character to use as fields separator. Input \u00b6 Type Description [(String)] A multiline string in CSV format. Output \u00b6 Type Description [(Seq [(Seq [(String)])])] A sequence of rows, with each row being a sequence of strings.","title":"CSV.Read"},{"location":"shards/CSV/Read/#csvread","text":"( CSV.Read :NoHeader [( Bool )] :Separator [( String )] )","title":"CSV.Read"},{"location":"shards/CSV/Read/#definition","text":"Reads a CSV string and outputs the data as a sequence of strings in a sequence of rows.","title":"Definition"},{"location":"shards/CSV/Read/#parameters","text":"Name Type Default Description NoHeader [(Bool)] false Whether the shard should parse the first row as data, instead of header. Separator [(String)] \",\" The character to use as fields separator.","title":"Parameters"},{"location":"shards/CSV/Read/#input","text":"Type Description [(String)] A multiline string in CSV format.","title":"Input"},{"location":"shards/CSV/Read/#output","text":"Type Description [(Seq [(Seq [(String)])])] A sequence of rows, with each row being a sequence of strings.","title":"Output"},{"location":"shards/CSV/Write/","text":"CSV.Write \u00b6 ( CSV.Write :NoHeader [( Bool )] :Separator [( String )] ) Definition \u00b6 Reads a sequence of strings in a sequence of rows and outputs the data as a CSV string. Parameters \u00b6 Name Type Default Description NoHeader [(Bool)] false Whether the shard should parse the first row as data, instead of header. Separator [(String)] \",\" The character to use as fields separator. Input \u00b6 Type Description [(Seq [(Seq [(String)])])] A sequence of rows, with each row being a sequence of strings. Output \u00b6 Type Description [(String)] A multiline string in CSV format.","title":"CSV.Write"},{"location":"shards/CSV/Write/#csvwrite","text":"( CSV.Write :NoHeader [( Bool )] :Separator [( String )] )","title":"CSV.Write"},{"location":"shards/CSV/Write/#definition","text":"Reads a sequence of strings in a sequence of rows and outputs the data as a CSV string.","title":"Definition"},{"location":"shards/CSV/Write/#parameters","text":"Name Type Default Description NoHeader [(Bool)] false Whether the shard should parse the first row as data, instead of header. Separator [(String)] \",\" The character to use as fields separator.","title":"Parameters"},{"location":"shards/CSV/Write/#input","text":"Type Description [(Seq [(Seq [(String)])])] A sequence of rows, with each row being a sequence of strings.","title":"Input"},{"location":"shards/CSV/Write/#output","text":"Type Description [(String)] A multiline string in CSV format.","title":"Output"},{"location":"shards/ChaChaPoly/Decrypt/","text":"ChaChaPoly.Decrypt \u00b6 ( ChaChaPoly.Decrypt :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to encrypt/decrypt the input payload. Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"ChaChaPoly.Decrypt"},{"location":"shards/ChaChaPoly/Decrypt/#chachapolydecrypt","text":"( ChaChaPoly.Decrypt :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] )","title":"ChaChaPoly.Decrypt"},{"location":"shards/ChaChaPoly/Decrypt/#definition","text":"","title":"Definition"},{"location":"shards/ChaChaPoly/Decrypt/#parameters","text":"Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to encrypt/decrypt the input payload.","title":"Parameters"},{"location":"shards/ChaChaPoly/Decrypt/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/ChaChaPoly/Decrypt/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/ChaChaPoly/Encrypt/","text":"ChaChaPoly.Encrypt \u00b6 ( ChaChaPoly.Encrypt :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to encrypt/decrypt the input payload. Input \u00b6 Type Description [(String) (Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"ChaChaPoly.Encrypt"},{"location":"shards/ChaChaPoly/Encrypt/#chachapolyencrypt","text":"( ChaChaPoly.Encrypt :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] )","title":"ChaChaPoly.Encrypt"},{"location":"shards/ChaChaPoly/Encrypt/#definition","text":"","title":"Definition"},{"location":"shards/ChaChaPoly/Encrypt/#parameters","text":"Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to encrypt/decrypt the input payload.","title":"Parameters"},{"location":"shards/ChaChaPoly/Encrypt/#input","text":"Type Description [(String) (Bytes)]","title":"Input"},{"location":"shards/ChaChaPoly/Encrypt/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/DSP/FFT/","text":"DSP.FFT \u00b6 Experimental/unstable This API is experimental and might produce unexpected results or crash. ( DSP.FFT ) Definition \u00b6 Input \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)]) (Audio)] Output \u00b6 Type Description [(Seq [(Float2)])]","title":"DSP.FFT"},{"location":"shards/DSP/FFT/#dspfft","text":"Experimental/unstable This API is experimental and might produce unexpected results or crash. ( DSP.FFT )","title":"DSP.FFT"},{"location":"shards/DSP/FFT/#definition","text":"","title":"Definition"},{"location":"shards/DSP/FFT/#input","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)]) (Audio)]","title":"Input"},{"location":"shards/DSP/FFT/#output","text":"Type Description [(Seq [(Float2)])]","title":"Output"},{"location":"shards/DSP/IFFT/","text":"DSP.IFFT \u00b6 Experimental/unstable This API is experimental and might produce unexpected results or crash. ( DSP.IFFT :Audio [( Bool )] :Complex [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Audio [(Bool)] false If the output should be an Audio chunk. Complex [(Bool)] false If the output should be complex numbers (only if not Audio). Input \u00b6 Type Description [(Seq [(Float2)])] Output \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)]) (Audio)]","title":"DSP.IFFT"},{"location":"shards/DSP/IFFT/#dspifft","text":"Experimental/unstable This API is experimental and might produce unexpected results or crash. ( DSP.IFFT :Audio [( Bool )] :Complex [( Bool )] )","title":"DSP.IFFT"},{"location":"shards/DSP/IFFT/#definition","text":"","title":"Definition"},{"location":"shards/DSP/IFFT/#parameters","text":"Name Type Default Description Audio [(Bool)] false If the output should be an Audio chunk. Complex [(Bool)] false If the output should be complex numbers (only if not Audio).","title":"Parameters"},{"location":"shards/DSP/IFFT/#input","text":"Type Description [(Seq [(Float2)])]","title":"Input"},{"location":"shards/DSP/IFFT/#output","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)]) (Audio)]","title":"Output"},{"location":"shards/Date/Format/","text":"Date.Format \u00b6 ( Date.Format :Format [( String )] ) Definition \u00b6 Reads an epoch timestamps and formats it into a readable string. Parameters \u00b6 Name Type Default Description Format [(String)] \"%a %b %e %T %Y\" The actual formatting string, see full docs: https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html#specifiers Input \u00b6 Type Description [(Int)] An epoch timestamp (seconds after epoch). Output \u00b6 Type Description [(String)] A formatted readable string.","title":"Date.Format"},{"location":"shards/Date/Format/#dateformat","text":"( Date.Format :Format [( String )] )","title":"Date.Format"},{"location":"shards/Date/Format/#definition","text":"Reads an epoch timestamps and formats it into a readable string.","title":"Definition"},{"location":"shards/Date/Format/#parameters","text":"Name Type Default Description Format [(String)] \"%a %b %e %T %Y\" The actual formatting string, see full docs: https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html#specifiers","title":"Parameters"},{"location":"shards/Date/Format/#input","text":"Type Description [(Int)] An epoch timestamp (seconds after epoch).","title":"Input"},{"location":"shards/Date/Format/#output","text":"Type Description [(String)] A formatted readable string.","title":"Output"},{"location":"shards/Desktop/Bounds/","text":"Desktop.Bounds \u00b6 ( Desktop.Bounds ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.Bounds"},{"location":"shards/Desktop/Bounds/#desktopbounds","text":"( Desktop.Bounds )","title":"Desktop.Bounds"},{"location":"shards/Desktop/Bounds/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/Bounds/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/Bounds/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/CursorBitmap/","text":"Desktop.CursorBitmap \u00b6 ( Desktop.CursorBitmap ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Image)]","title":"Desktop.CursorBitmap"},{"location":"shards/Desktop/CursorBitmap/#desktopcursorbitmap","text":"( Desktop.CursorBitmap )","title":"Desktop.CursorBitmap"},{"location":"shards/Desktop/CursorBitmap/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/CursorBitmap/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Desktop/CursorBitmap/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/Desktop/GetMousePos/","text":"Desktop.GetMousePos \u00b6 ( Desktop.GetMousePos :Window [( Object ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.GetMousePos"},{"location":"shards/Desktop/GetMousePos/#desktopgetmousepos","text":"( Desktop.GetMousePos :Window [( Object ) ( None )] )","title":"Desktop.GetMousePos"},{"location":"shards/Desktop/GetMousePos/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/GetMousePos/#parameters","text":"Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin.","title":"Parameters"},{"location":"shards/Desktop/GetMousePos/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Desktop/GetMousePos/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/HasWindow/","text":"Desktop.HasWindow \u00b6 ( Desktop.HasWindow :Title [( String )] :Class [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Title [(String)] \"\" The title of the window to look for. Class [(String)] \"\" An optional and platform dependent window class. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Bool)]","title":"Desktop.HasWindow"},{"location":"shards/Desktop/HasWindow/#desktophaswindow","text":"( Desktop.HasWindow :Title [( String )] :Class [( String )] )","title":"Desktop.HasWindow"},{"location":"shards/Desktop/HasWindow/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/HasWindow/#parameters","text":"Name Type Default Description Title [(String)] \"\" The title of the window to look for. Class [(String)] \"\" An optional and platform dependent window class.","title":"Parameters"},{"location":"shards/Desktop/HasWindow/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Desktop/HasWindow/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/Desktop/IsForeground/","text":"Desktop.IsForeground \u00b6 ( Desktop.IsForeground ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Bool)]","title":"Desktop.IsForeground"},{"location":"shards/Desktop/IsForeground/#desktopisforeground","text":"( Desktop.IsForeground )","title":"Desktop.IsForeground"},{"location":"shards/Desktop/IsForeground/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/IsForeground/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/IsForeground/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/Desktop/LastInput/","text":"Desktop.LastInput \u00b6 ( Desktop.LastInput ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float)]","title":"Desktop.LastInput"},{"location":"shards/Desktop/LastInput/#desktoplastinput","text":"( Desktop.LastInput )","title":"Desktop.LastInput"},{"location":"shards/Desktop/LastInput/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/LastInput/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Desktop/LastInput/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/Desktop/LeftClick/","text":"Desktop.LeftClick \u00b6 ( Desktop.LeftClick :Window [( Object ) ( None )] :Natural [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Natural [(Bool)] true Small pauses will be injected after click events down & up. Input \u00b6 Type Description [(Int2)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.LeftClick"},{"location":"shards/Desktop/LeftClick/#desktopleftclick","text":"( Desktop.LeftClick :Window [( Object ) ( None )] :Natural [( Bool )] )","title":"Desktop.LeftClick"},{"location":"shards/Desktop/LeftClick/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/LeftClick/#parameters","text":"Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Natural [(Bool)] true Small pauses will be injected after click events down & up.","title":"Parameters"},{"location":"shards/Desktop/LeftClick/#input","text":"Type Description [(Int2)]","title":"Input"},{"location":"shards/Desktop/LeftClick/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/MiddleClick/","text":"Desktop.MiddleClick \u00b6 ( Desktop.MiddleClick :Window [( Object ) ( None )] :Natural [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Natural [(Bool)] true Small pauses will be injected after click events down & up. Input \u00b6 Type Description [(Int2)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.MiddleClick"},{"location":"shards/Desktop/MiddleClick/#desktopmiddleclick","text":"( Desktop.MiddleClick :Window [( Object ) ( None )] :Natural [( Bool )] )","title":"Desktop.MiddleClick"},{"location":"shards/Desktop/MiddleClick/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/MiddleClick/#parameters","text":"Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Natural [(Bool)] true Small pauses will be injected after click events down & up.","title":"Parameters"},{"location":"shards/Desktop/MiddleClick/#input","text":"Type Description [(Int2)]","title":"Input"},{"location":"shards/Desktop/MiddleClick/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/Move/","text":"Desktop.Move \u00b6 ( Desktop.Move :X [( Int )] :Y [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description X [(Int)] 0 The desired horizontal coordinates. Y [(Int)] 0 The desired vertical coordinates. Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.Move"},{"location":"shards/Desktop/Move/#desktopmove","text":"( Desktop.Move :X [( Int )] :Y [( Int )] )","title":"Desktop.Move"},{"location":"shards/Desktop/Move/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/Move/#parameters","text":"Name Type Default Description X [(Int)] 0 The desired horizontal coordinates. Y [(Int)] 0 The desired vertical coordinates.","title":"Parameters"},{"location":"shards/Desktop/Move/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/Move/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/NotForeground/","text":"Desktop.NotForeground \u00b6 ( Desktop.NotForeground ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Bool)]","title":"Desktop.NotForeground"},{"location":"shards/Desktop/NotForeground/#desktopnotforeground","text":"( Desktop.NotForeground )","title":"Desktop.NotForeground"},{"location":"shards/Desktop/NotForeground/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/NotForeground/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/NotForeground/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/Desktop/PID/","text":"Desktop.PID \u00b6 ( Desktop.PID ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Int)]","title":"Desktop.PID"},{"location":"shards/Desktop/PID/#desktoppid","text":"( Desktop.PID )","title":"Desktop.PID"},{"location":"shards/Desktop/PID/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/PID/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/PID/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/Desktop/Pixel/","text":"Desktop.Pixel \u00b6 ( Desktop.Pixel :Window [( Object ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None The window variable name to use as coordinate origin. Input \u00b6 Type Description [(Int2)] Output \u00b6 Type Description [(Color)]","title":"Desktop.Pixel"},{"location":"shards/Desktop/Pixel/#desktoppixel","text":"( Desktop.Pixel :Window [( Object ) ( None )] )","title":"Desktop.Pixel"},{"location":"shards/Desktop/Pixel/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/Pixel/#parameters","text":"Name Type Default Description Window [(Object) (None)] None The window variable name to use as coordinate origin.","title":"Parameters"},{"location":"shards/Desktop/Pixel/#input","text":"Type Description [(Int2)]","title":"Input"},{"location":"shards/Desktop/Pixel/#output","text":"Type Description [(Color)]","title":"Output"},{"location":"shards/Desktop/Resize/","text":"Desktop.Resize \u00b6 ( Desktop.Resize :Width [( Int )] :Height [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Width [(Int)] 0 The desired width. Height [(Int)] 0 The desired height. Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.Resize"},{"location":"shards/Desktop/Resize/#desktopresize","text":"( Desktop.Resize :Width [( Int )] :Height [( Int )] )","title":"Desktop.Resize"},{"location":"shards/Desktop/Resize/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/Resize/#parameters","text":"Name Type Default Description Width [(Int)] 0 The desired width. Height [(Int)] 0 The desired height.","title":"Parameters"},{"location":"shards/Desktop/Resize/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/Resize/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/RightClick/","text":"Desktop.RightClick \u00b6 ( Desktop.RightClick :Window [( Object ) ( None )] :Natural [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Natural [(Bool)] true Small pauses will be injected after click events down & up. Input \u00b6 Type Description [(Int2)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.RightClick"},{"location":"shards/Desktop/RightClick/#desktoprightclick","text":"( Desktop.RightClick :Window [( Object ) ( None )] :Natural [( Bool )] )","title":"Desktop.RightClick"},{"location":"shards/Desktop/RightClick/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/RightClick/#parameters","text":"Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Natural [(Bool)] true Small pauses will be injected after click events down & up.","title":"Parameters"},{"location":"shards/Desktop/RightClick/#input","text":"Type Description [(Int2)]","title":"Input"},{"location":"shards/Desktop/RightClick/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/SendKeyEvent/","text":"Desktop.SendKeyEvent \u00b6 ( Desktop.SendKeyEvent :Window [( Object ) ( None )] ) Definition \u00b6 Sends the input key event. \u00b6 The input of this shard will be a Int2. \u00b6 The first integer will be 0 for Key down/push events and 1 for Key up/release events. The second integer will the scancode of the key. Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None None or a window variable if we wish to send the event only to a specific target window. Input \u00b6 Type Description [(Int2)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.SendKeyEvent"},{"location":"shards/Desktop/SendKeyEvent/#desktopsendkeyevent","text":"( Desktop.SendKeyEvent :Window [( Object ) ( None )] )","title":"Desktop.SendKeyEvent"},{"location":"shards/Desktop/SendKeyEvent/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SendKeyEvent/#sends-the-input-key-event","text":"","title":"Sends the input key event."},{"location":"shards/Desktop/SendKeyEvent/#the-input-of-this-shard-will-be-a-int2","text":"The first integer will be 0 for Key down/push events and 1 for Key up/release events. The second integer will the scancode of the key.","title":"The input of this shard will be a Int2."},{"location":"shards/Desktop/SendKeyEvent/#parameters","text":"Name Type Default Description Window [(Object) (None)] None None or a window variable if we wish to send the event only to a specific target window.","title":"Parameters"},{"location":"shards/Desktop/SendKeyEvent/#input","text":"Type Description [(Int2)]","title":"Input"},{"location":"shards/Desktop/SendKeyEvent/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/SetBorderless/","text":"Desktop.SetBorderless \u00b6 ( Desktop.SetBorderless ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.SetBorderless"},{"location":"shards/Desktop/SetBorderless/#desktopsetborderless","text":"( Desktop.SetBorderless )","title":"Desktop.SetBorderless"},{"location":"shards/Desktop/SetBorderless/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SetBorderless/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/SetBorderless/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/SetClickthrough/","text":"Desktop.SetClickthrough \u00b6 ( Desktop.SetClickthrough ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.SetClickthrough"},{"location":"shards/Desktop/SetClickthrough/#desktopsetclickthrough","text":"( Desktop.SetClickthrough )","title":"Desktop.SetClickthrough"},{"location":"shards/Desktop/SetClickthrough/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SetClickthrough/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/SetClickthrough/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/SetForeground/","text":"Desktop.SetForeground \u00b6 ( Desktop.SetForeground ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.SetForeground"},{"location":"shards/Desktop/SetForeground/#desktopsetforeground","text":"( Desktop.SetForeground )","title":"Desktop.SetForeground"},{"location":"shards/Desktop/SetForeground/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SetForeground/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/SetForeground/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/SetMousePos/","text":"Desktop.SetMousePos \u00b6 ( Desktop.SetMousePos :Window [( Object ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Input \u00b6 Type Description [(Int2)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.SetMousePos"},{"location":"shards/Desktop/SetMousePos/#desktopsetmousepos","text":"( Desktop.SetMousePos :Window [( Object ) ( None )] )","title":"Desktop.SetMousePos"},{"location":"shards/Desktop/SetMousePos/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SetMousePos/#parameters","text":"Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin.","title":"Parameters"},{"location":"shards/Desktop/SetMousePos/#input","text":"Type Description [(Int2)]","title":"Input"},{"location":"shards/Desktop/SetMousePos/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/SetTimerResolution/","text":"Desktop.SetTimerResolution \u00b6 ( Desktop.SetTimerResolution ) Definition \u00b6 Input \u00b6 Type Description [(Int)] Output \u00b6 Type Description [(Int)]","title":"Desktop.SetTimerResolution"},{"location":"shards/Desktop/SetTimerResolution/#desktopsettimerresolution","text":"( Desktop.SetTimerResolution )","title":"Desktop.SetTimerResolution"},{"location":"shards/Desktop/SetTimerResolution/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SetTimerResolution/#input","text":"Type Description [(Int)]","title":"Input"},{"location":"shards/Desktop/SetTimerResolution/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/Desktop/SetTitle/","text":"Desktop.SetTitle \u00b6 ( Desktop.SetTitle :Title [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Title [(String)] \"\" The title of the window to look for. Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.SetTitle"},{"location":"shards/Desktop/SetTitle/#desktopsettitle","text":"( Desktop.SetTitle :Title [( String )] )","title":"Desktop.SetTitle"},{"location":"shards/Desktop/SetTitle/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SetTitle/#parameters","text":"Name Type Default Description Title [(String)] \"\" The title of the window to look for.","title":"Parameters"},{"location":"shards/Desktop/SetTitle/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/SetTitle/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/SetTopmost/","text":"Desktop.SetTopmost \u00b6 ( Desktop.SetTopmost ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.SetTopmost"},{"location":"shards/Desktop/SetTopmost/#desktopsettopmost","text":"( Desktop.SetTopmost )","title":"Desktop.SetTopmost"},{"location":"shards/Desktop/SetTopmost/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/SetTopmost/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/SetTopmost/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/Size/","text":"Desktop.Size \u00b6 ( Desktop.Size ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.Size"},{"location":"shards/Desktop/Size/#desktopsize","text":"( Desktop.Size )","title":"Desktop.Size"},{"location":"shards/Desktop/Size/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/Size/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/Size/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/Tap/","text":"Desktop.Tap \u00b6 ( Desktop.Tap :Window [( Object ) ( None )] :Long [( Bool )] :Natural [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Long [(Bool)] false A big delay will be injected after tap down to simulate a long tap. Natural [(Bool)] true Small pauses will be injected after tap events down & up. Input \u00b6 Type Description [(Int2)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.Tap"},{"location":"shards/Desktop/Tap/#desktoptap","text":"( Desktop.Tap :Window [( Object ) ( None )] :Long [( Bool )] :Natural [( Bool )] )","title":"Desktop.Tap"},{"location":"shards/Desktop/Tap/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/Tap/#parameters","text":"Name Type Default Description Window [(Object) (None)] None None or a window variable we wish to use as relative origin. Long [(Bool)] false A big delay will be injected after tap down to simulate a long tap. Natural [(Bool)] true Small pauses will be injected after tap events down & up.","title":"Parameters"},{"location":"shards/Desktop/Tap/#input","text":"Type Description [(Int2)]","title":"Input"},{"location":"shards/Desktop/Tap/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/UnsetClickthrough/","text":"Desktop.UnsetClickthrough \u00b6 ( Desktop.UnsetClickthrough ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.UnsetClickthrough"},{"location":"shards/Desktop/UnsetClickthrough/#desktopunsetclickthrough","text":"( Desktop.UnsetClickthrough )","title":"Desktop.UnsetClickthrough"},{"location":"shards/Desktop/UnsetClickthrough/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/UnsetClickthrough/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/UnsetClickthrough/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/UnsetTopmost/","text":"Desktop.UnsetTopmost \u00b6 ( Desktop.UnsetTopmost ) Definition \u00b6 Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(Object)]","title":"Desktop.UnsetTopmost"},{"location":"shards/Desktop/UnsetTopmost/#desktopunsettopmost","text":"( Desktop.UnsetTopmost )","title":"Desktop.UnsetTopmost"},{"location":"shards/Desktop/UnsetTopmost/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/UnsetTopmost/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/Desktop/UnsetTopmost/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Desktop/WaitKeyEvent/","text":"Desktop.WaitKeyEvent \u00b6 ( Desktop.WaitKeyEvent ) Definition \u00b6 Pauses the wire and waits for keyboard events. \u00b6 The output of this shard will be a Int2. \u00b6 The first integer will be 0 for Key down/push events and 1 for Key up/release events. The second integer will the scancode of the key. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Int2)]","title":"Desktop.WaitKeyEvent"},{"location":"shards/Desktop/WaitKeyEvent/#desktopwaitkeyevent","text":"( Desktop.WaitKeyEvent )","title":"Desktop.WaitKeyEvent"},{"location":"shards/Desktop/WaitKeyEvent/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/WaitKeyEvent/#pauses-the-wire-and-waits-for-keyboard-events","text":"","title":"Pauses the wire and waits for keyboard events."},{"location":"shards/Desktop/WaitKeyEvent/#the-output-of-this-shard-will-be-a-int2","text":"The first integer will be 0 for Key down/push events and 1 for Key up/release events. The second integer will the scancode of the key.","title":"The output of this shard will be a Int2."},{"location":"shards/Desktop/WaitKeyEvent/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Desktop/WaitKeyEvent/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Desktop/WaitWindow/","text":"Desktop.WaitWindow \u00b6 ( Desktop.WaitWindow :Title [( String )] :Class [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Title [(String)] \"\" The title of the window to look for. Class [(String)] \"\" An optional and platform dependent window class. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"Desktop.WaitWindow"},{"location":"shards/Desktop/WaitWindow/#desktopwaitwindow","text":"( Desktop.WaitWindow :Title [( String )] :Class [( String )] )","title":"Desktop.WaitWindow"},{"location":"shards/Desktop/WaitWindow/#definition","text":"","title":"Definition"},{"location":"shards/Desktop/WaitWindow/#parameters","text":"Name Type Default Description Title [(String)] \"\" The title of the window to look for. Class [(String)] \"\" An optional and platform dependent window class.","title":"Parameters"},{"location":"shards/Desktop/WaitWindow/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Desktop/WaitWindow/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/ECDSA/PublicKey/","text":"ECDSA.PublicKey \u00b6 ( ECDSA.PublicKey :Compressed [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Compressed [(Bool)] false If the output PublicKey should use the compressed format. Input \u00b6 Type Description [(Bytes) (String)] Output \u00b6 Type Description [(Bytes)]","title":"ECDSA.PublicKey"},{"location":"shards/ECDSA/PublicKey/#ecdsapublickey","text":"( ECDSA.PublicKey :Compressed [( Bool )] )","title":"ECDSA.PublicKey"},{"location":"shards/ECDSA/PublicKey/#definition","text":"","title":"Definition"},{"location":"shards/ECDSA/PublicKey/#parameters","text":"Name Type Default Description Compressed [(Bool)] false If the output PublicKey should use the compressed format.","title":"Parameters"},{"location":"shards/ECDSA/PublicKey/#input","text":"Type Description [(Bytes) (String)]","title":"Input"},{"location":"shards/ECDSA/PublicKey/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/ECDSA/Recover/","text":"ECDSA.Recover \u00b6 ( ECDSA.Recover :Signature [( Bytes ) ( ContextVar [( Bytes )])] :Compressed [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Signature [(Bytes) (ContextVar [(Bytes)])] None The signature generated signing the input message with the private key. Compressed [(Bool)] false If the output PublicKey should use the compressed format. Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"ECDSA.Recover"},{"location":"shards/ECDSA/Recover/#ecdsarecover","text":"( ECDSA.Recover :Signature [( Bytes ) ( ContextVar [( Bytes )])] :Compressed [( Bool )] )","title":"ECDSA.Recover"},{"location":"shards/ECDSA/Recover/#definition","text":"","title":"Definition"},{"location":"shards/ECDSA/Recover/#parameters","text":"Name Type Default Description Signature [(Bytes) (ContextVar [(Bytes)])] None The signature generated signing the input message with the private key. Compressed [(Bool)] false If the output PublicKey should use the compressed format.","title":"Parameters"},{"location":"shards/ECDSA/Recover/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/ECDSA/Recover/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/ECDSA/Seed/","text":"ECDSA.Seed \u00b6 ( ECDSA.Seed :Compressed [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Compressed [(Bool)] false If the output PublicKey should use the compressed format. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bytes)]","title":"ECDSA.Seed"},{"location":"shards/ECDSA/Seed/#ecdsaseed","text":"( ECDSA.Seed :Compressed [( Bool )] )","title":"ECDSA.Seed"},{"location":"shards/ECDSA/Seed/#definition","text":"","title":"Definition"},{"location":"shards/ECDSA/Seed/#parameters","text":"Name Type Default Description Compressed [(Bool)] false If the output PublicKey should use the compressed format.","title":"Parameters"},{"location":"shards/ECDSA/Seed/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/ECDSA/Seed/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/ECDSA/Sign/","text":"ECDSA.Sign \u00b6 ( ECDSA.Sign :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to sign the hashed message input. Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"ECDSA.Sign"},{"location":"shards/ECDSA/Sign/#ecdsasign","text":"( ECDSA.Sign :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] )","title":"ECDSA.Sign"},{"location":"shards/ECDSA/Sign/#definition","text":"","title":"Definition"},{"location":"shards/ECDSA/Sign/#parameters","text":"Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to sign the hashed message input.","title":"Parameters"},{"location":"shards/ECDSA/Sign/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/ECDSA/Sign/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/EDN/Uglify/","text":"EDN.Uglify \u00b6 ( EDN.Uglify :Hooks [( Seq [( Any )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Hooks [(Seq [(Any)])] None A list of pairs to hook, [ ], shards will have as input the contents of the symbols's list. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"EDN.Uglify"},{"location":"shards/EDN/Uglify/#ednuglify","text":"( EDN.Uglify :Hooks [( Seq [( Any )])] )","title":"EDN.Uglify"},{"location":"shards/EDN/Uglify/#definition","text":"","title":"Definition"},{"location":"shards/EDN/Uglify/#parameters","text":"Name Type Default Description Hooks [(Seq [(Any)])] None A list of pairs to hook, [ ], shards will have as input the contents of the symbols's list.","title":"Parameters"},{"location":"shards/EDN/Uglify/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/EDN/Uglify/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Ed25519/PublicKey/","text":"Ed25519.PublicKey \u00b6 ( Ed25519.PublicKey ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (String)] Output \u00b6 Type Description [(Bytes)]","title":"Ed25519.PublicKey"},{"location":"shards/Ed25519/PublicKey/#ed25519publickey","text":"( Ed25519.PublicKey )","title":"Ed25519.PublicKey"},{"location":"shards/Ed25519/PublicKey/#definition","text":"","title":"Definition"},{"location":"shards/Ed25519/PublicKey/#input","text":"Type Description [(Bytes) (String)]","title":"Input"},{"location":"shards/Ed25519/PublicKey/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Ed25519/Seed/","text":"Ed25519.Seed \u00b6 ( Ed25519.Seed ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bytes)]","title":"Ed25519.Seed"},{"location":"shards/Ed25519/Seed/#ed25519seed","text":"( Ed25519.Seed )","title":"Ed25519.Seed"},{"location":"shards/Ed25519/Seed/#definition","text":"","title":"Definition"},{"location":"shards/Ed25519/Seed/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Ed25519/Seed/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Ed25519/Sign/","text":"Ed25519.Sign \u00b6 ( Ed25519.Sign :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to sign the hashed message input. Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"Ed25519.Sign"},{"location":"shards/Ed25519/Sign/#ed25519sign","text":"( Ed25519.Sign :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] )","title":"Ed25519.Sign"},{"location":"shards/Ed25519/Sign/#definition","text":"","title":"Definition"},{"location":"shards/Ed25519/Sign/#parameters","text":"Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to sign the hashed message input.","title":"Parameters"},{"location":"shards/Ed25519/Sign/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/Ed25519/Sign/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Eth/DecodeCall/","text":"Eth.DecodeCall \u00b6 ( Eth.DecodeCall :ABI [( String ) ( ContextVar [( String )]) ( None )] :Name [( String ) ( None )] :Input [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description ABI [(String) (ContextVar [(String)]) (None)] None The contract's json ABI. Name [(String) (None)] None The name of the method to call. Input [(Bool)] false If the input is the actual function call transaction input rather than the result of the call. Input \u00b6 Type Description [(Bytes) (String)] Output \u00b6 Type Description [(Seq [(Any)])]","title":"Eth.DecodeCall"},{"location":"shards/Eth/DecodeCall/#ethdecodecall","text":"( Eth.DecodeCall :ABI [( String ) ( ContextVar [( String )]) ( None )] :Name [( String ) ( None )] :Input [( Bool )] )","title":"Eth.DecodeCall"},{"location":"shards/Eth/DecodeCall/#definition","text":"","title":"Definition"},{"location":"shards/Eth/DecodeCall/#parameters","text":"Name Type Default Description ABI [(String) (ContextVar [(String)]) (None)] None The contract's json ABI. Name [(String) (None)] None The name of the method to call. Input [(Bool)] false If the input is the actual function call transaction input rather than the result of the call.","title":"Parameters"},{"location":"shards/Eth/DecodeCall/#input","text":"Type Description [(Bytes) (String)]","title":"Input"},{"location":"shards/Eth/DecodeCall/#output","text":"Type Description [(Seq [(Any)])]","title":"Output"},{"location":"shards/Eth/EncodeCall/","text":"Eth.EncodeCall \u00b6 ( Eth.EncodeCall :ABI [( String ) ( ContextVar [( String )]) ( None )] :Name [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description ABI [(String) (ContextVar [(String)]) (None)] None The contract's json ABI. Name [(String) (None)] None The name of the method to call. Input \u00b6 Type Description [(Seq [(Any)])] Output \u00b6 Type Description [(Bytes)]","title":"Eth.EncodeCall"},{"location":"shards/Eth/EncodeCall/#ethencodecall","text":"( Eth.EncodeCall :ABI [( String ) ( ContextVar [( String )]) ( None )] :Name [( String ) ( None )] )","title":"Eth.EncodeCall"},{"location":"shards/Eth/EncodeCall/#definition","text":"","title":"Definition"},{"location":"shards/Eth/EncodeCall/#parameters","text":"Name Type Default Description ABI [(String) (ContextVar [(String)]) (None)] None The contract's json ABI. Name [(String) (None)] None The name of the method to call.","title":"Parameters"},{"location":"shards/Eth/EncodeCall/#input","text":"Type Description [(Seq [(Any)])]","title":"Input"},{"location":"shards/Eth/EncodeCall/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/FS/Copy/","text":"FS.Copy \u00b6 ( FS.Copy :Destination [( String ) ( ContextVar [( String )]) ( None )] :Behavior [( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Destination [(String) (ContextVar [(String)]) (None)] None The destination path, can be a file or a directory. Behavior [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x66736f77 What to do when the destination already exists. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"FS.Copy"},{"location":"shards/FS/Copy/#fscopy","text":"( FS.Copy :Destination [( String ) ( ContextVar [( String )]) ( None )] :Behavior [( Enum )] )","title":"FS.Copy"},{"location":"shards/FS/Copy/#definition","text":"","title":"Definition"},{"location":"shards/FS/Copy/#parameters","text":"Name Type Default Description Destination [(String) (ContextVar [(String)]) (None)] None The destination path, can be a file or a directory. Behavior [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x66736f77 What to do when the destination already exists.","title":"Parameters"},{"location":"shards/FS/Copy/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/Copy/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/FS/Extension/","text":"FS.Extension \u00b6 ( FS.Extension ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"FS.Extension"},{"location":"shards/FS/Extension/#fsextension","text":"( FS.Extension )","title":"FS.Extension"},{"location":"shards/FS/Extension/#definition","text":"","title":"Definition"},{"location":"shards/FS/Extension/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/Extension/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/FS/Filename/","text":"FS.Filename \u00b6 ( FS.Filename :NoExtension [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description NoExtension [(Bool)] false If the extension should be stripped from the result. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"FS.Filename"},{"location":"shards/FS/Filename/#fsfilename","text":"( FS.Filename :NoExtension [( Bool )] )","title":"FS.Filename"},{"location":"shards/FS/Filename/#definition","text":"","title":"Definition"},{"location":"shards/FS/Filename/#parameters","text":"Name Type Default Description NoExtension [(Bool)] false If the extension should be stripped from the result.","title":"Parameters"},{"location":"shards/FS/Filename/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/Filename/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/FS/IsDirectory/","text":"FS.IsDirectory \u00b6 ( FS.IsDirectory ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bool)]","title":"FS.IsDirectory"},{"location":"shards/FS/IsDirectory/#fsisdirectory","text":"( FS.IsDirectory )","title":"FS.IsDirectory"},{"location":"shards/FS/IsDirectory/#definition","text":"","title":"Definition"},{"location":"shards/FS/IsDirectory/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/IsDirectory/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/FS/IsFile/","text":"FS.IsFile \u00b6 ( FS.IsFile ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bool)]","title":"FS.IsFile"},{"location":"shards/FS/IsFile/#fsisfile","text":"( FS.IsFile )","title":"FS.IsFile"},{"location":"shards/FS/IsFile/#definition","text":"","title":"Definition"},{"location":"shards/FS/IsFile/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/IsFile/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/FS/Iterate/","text":"FS.Iterate \u00b6 ( FS.Iterate :Recursive [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Recursive [(Bool)] true If the iteration should be recursive, following sub-directories. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Seq [(String)])]","title":"FS.Iterate"},{"location":"shards/FS/Iterate/#fsiterate","text":"( FS.Iterate :Recursive [( Bool )] )","title":"FS.Iterate"},{"location":"shards/FS/Iterate/#definition","text":"","title":"Definition"},{"location":"shards/FS/Iterate/#parameters","text":"Name Type Default Description Recursive [(Bool)] true If the iteration should be recursive, following sub-directories.","title":"Parameters"},{"location":"shards/FS/Iterate/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/Iterate/#output","text":"Type Description [(Seq [(String)])]","title":"Output"},{"location":"shards/FS/Read/","text":"FS.Read \u00b6 ( FS.Read :Bytes [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Bytes [(Bool)] false If the output should be Bytes instead of String. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"FS.Read"},{"location":"shards/FS/Read/#fsread","text":"( FS.Read :Bytes [( Bool )] )","title":"FS.Read"},{"location":"shards/FS/Read/#definition","text":"","title":"Definition"},{"location":"shards/FS/Read/#parameters","text":"Name Type Default Description Bytes [(Bool)] false If the output should be Bytes instead of String.","title":"Parameters"},{"location":"shards/FS/Read/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/Read/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/FS/Remove/","text":"FS.Remove \u00b6 ( FS.Remove ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bool)]","title":"FS.Remove"},{"location":"shards/FS/Remove/#fsremove","text":"( FS.Remove )","title":"FS.Remove"},{"location":"shards/FS/Remove/#definition","text":"","title":"Definition"},{"location":"shards/FS/Remove/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/Remove/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/FS/Write/","text":"FS.Write \u00b6 ( FS.Write :Contents [( String ) ( Bytes ) ( ContextVar [( String )]) ( ContextVar [( Bytes )]) ( None )] :Overwrite [( Bool )] :Append [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Contents [(String) (Bytes) (ContextVar [(String)]) (ContextVar [(Bytes)]) (None)] None The string or bytes to write as the file's contents. Overwrite [(Bool)] false Overwrite the file if it already exists. Append [(Bool)] false If we should append Contents to an existing file. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"FS.Write"},{"location":"shards/FS/Write/#fswrite","text":"( FS.Write :Contents [( String ) ( Bytes ) ( ContextVar [( String )]) ( ContextVar [( Bytes )]) ( None )] :Overwrite [( Bool )] :Append [( Bool )] )","title":"FS.Write"},{"location":"shards/FS/Write/#definition","text":"","title":"Definition"},{"location":"shards/FS/Write/#parameters","text":"Name Type Default Description Contents [(String) (Bytes) (ContextVar [(String)]) (ContextVar [(Bytes)]) (None)] None The string or bytes to write as the file's contents. Overwrite [(Bool)] false Overwrite the file if it already exists. Append [(Bool)] false If we should append Contents to an existing file.","title":"Parameters"},{"location":"shards/FS/Write/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/FS/Write/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/GFX/BuiltinFeature/","text":"GFX.BuiltinFeature \u00b6 ( GFX.BuiltinFeature :Id [( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Id [(Enum)] Enum: 0 vendor: 0x63676678 type: 0x66656964 Builtin feature id. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"GFX.BuiltinFeature"},{"location":"shards/GFX/BuiltinFeature/#gfxbuiltinfeature","text":"( GFX.BuiltinFeature :Id [( Enum )] )","title":"GFX.BuiltinFeature"},{"location":"shards/GFX/BuiltinFeature/#definition","text":"","title":"Definition"},{"location":"shards/GFX/BuiltinFeature/#parameters","text":"Name Type Default Description Id [(Enum)] Enum: 0 vendor: 0x63676678 type: 0x66656964 Builtin feature id.","title":"Parameters"},{"location":"shards/GFX/BuiltinFeature/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/BuiltinFeature/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/BuiltinMesh/","text":"GFX.BuiltinMesh \u00b6 ( GFX.BuiltinMesh :Type [( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Type [(Enum)] Enum: 0 vendor: 0x63676678 type: 0x626d6964 The type of object to make. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"GFX.BuiltinMesh"},{"location":"shards/GFX/BuiltinMesh/#gfxbuiltinmesh","text":"( GFX.BuiltinMesh :Type [( Enum )] )","title":"GFX.BuiltinMesh"},{"location":"shards/GFX/BuiltinMesh/#definition","text":"","title":"Definition"},{"location":"shards/GFX/BuiltinMesh/#parameters","text":"Name Type Default Description Type [(Enum)] Enum: 0 vendor: 0x63676678 type: 0x626d6964 The type of object to make.","title":"Parameters"},{"location":"shards/GFX/BuiltinMesh/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/BuiltinMesh/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/ClearQueue/","text":"GFX.ClearQueue \u00b6 ( GFX.ClearQueue ) Definition \u00b6 Clears a draw queue Input \u00b6 Type Description [(Object)] Output \u00b6 Type Description [(None)]","title":"GFX.ClearQueue"},{"location":"shards/GFX/ClearQueue/#gfxclearqueue","text":"( GFX.ClearQueue )","title":"GFX.ClearQueue"},{"location":"shards/GFX/ClearQueue/#definition","text":"Clears a draw queue","title":"Definition"},{"location":"shards/GFX/ClearQueue/#input","text":"Type Description [(Object)]","title":"Input"},{"location":"shards/GFX/ClearQueue/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/GFX/Draw/","text":"GFX.Draw \u00b6 ( GFX.Draw :Queue [( None ) ( ContextVar [( Object )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Queue [(None) (ContextVar [(Object)])] None The queue to add the draw command to (Optional). Uses the default queue if not specified Input \u00b6 Type Description [(Object) (Object) (Seq [(Object) (Object)])] Output \u00b6 Type Description [(None)]","title":"GFX.Draw"},{"location":"shards/GFX/Draw/#gfxdraw","text":"( GFX.Draw :Queue [( None ) ( ContextVar [( Object )])] )","title":"GFX.Draw"},{"location":"shards/GFX/Draw/#definition","text":"","title":"Definition"},{"location":"shards/GFX/Draw/#parameters","text":"Name Type Default Description Queue [(None) (ContextVar [(Object)])] None The queue to add the draw command to (Optional). Uses the default queue if not specified","title":"Parameters"},{"location":"shards/GFX/Draw/#input","text":"Type Description [(Object) (Object) (Seq [(Object) (Object)])]","title":"Input"},{"location":"shards/GFX/Draw/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/GFX/DrawQueue/","text":"GFX.DrawQueue \u00b6 ( GFX.DrawQueue ) Definition \u00b6 Creates a new drawable queue to record Draw commands into Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"GFX.DrawQueue"},{"location":"shards/GFX/DrawQueue/#gfxdrawqueue","text":"( GFX.DrawQueue )","title":"GFX.DrawQueue"},{"location":"shards/GFX/DrawQueue/#definition","text":"Creates a new drawable queue to record Draw commands into","title":"Definition"},{"location":"shards/GFX/DrawQueue/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/DrawQueue/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/Drawable/","text":"GFX.Drawable \u00b6 ( GFX.Drawable :Transform [( None ) ( ContextVar [( Seq [( Float4 )])])] :Params [( None ) ( Table [( ContextVar [( Seq [( Float4 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float )])]) ( ContextVar [()])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Transform [(None) (ContextVar [(Seq [(Float4)])])] None The transform variable to use (Optional) Params [(None) (Table [(ContextVar [(Seq [(Float4)])]) (ContextVar [(Float4)]) (ContextVar [(Float3)]) (ContextVar [(Float2)]) (ContextVar [(Float)])]) (ContextVar [()])] None The params variable to use (Optional) Input \u00b6 Type Description [(Table [(Any)])] Output \u00b6 Type Description [(Object)]","title":"GFX.Drawable"},{"location":"shards/GFX/Drawable/#gfxdrawable","text":"( GFX.Drawable :Transform [( None ) ( ContextVar [( Seq [( Float4 )])])] :Params [( None ) ( Table [( ContextVar [( Seq [( Float4 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float )])]) ( ContextVar [()])] )","title":"GFX.Drawable"},{"location":"shards/GFX/Drawable/#definition","text":"","title":"Definition"},{"location":"shards/GFX/Drawable/#parameters","text":"Name Type Default Description Transform [(None) (ContextVar [(Seq [(Float4)])])] None The transform variable to use (Optional) Params [(None) (Table [(ContextVar [(Seq [(Float4)])]) (ContextVar [(Float4)]) (ContextVar [(Float3)]) (ContextVar [(Float2)]) (ContextVar [(Float)])]) (ContextVar [()])] None The params variable to use (Optional)","title":"Parameters"},{"location":"shards/GFX/Drawable/#input","text":"Type Description [(Table [(Any)])]","title":"Input"},{"location":"shards/GFX/Drawable/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/DrawablePass/","text":"GFX.DrawablePass \u00b6 ( GFX.DrawablePass :Features [( ContextVar [( Seq [( Object )])]) ( Seq [( Object )])] :Queue [( None ) ( ContextVar [( Object )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Features [(ContextVar [(Seq [(Object)])]) (Seq [(Object)])] None Features to use. Queue [(None) (ContextVar [(Object)])] None The queue to draw from (Optional). Uses the default queue if not specified Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"GFX.DrawablePass"},{"location":"shards/GFX/DrawablePass/#gfxdrawablepass","text":"( GFX.DrawablePass :Features [( ContextVar [( Seq [( Object )])]) ( Seq [( Object )])] :Queue [( None ) ( ContextVar [( Object )])] )","title":"GFX.DrawablePass"},{"location":"shards/GFX/DrawablePass/#definition","text":"","title":"Definition"},{"location":"shards/GFX/DrawablePass/#parameters","text":"Name Type Default Description Features [(ContextVar [(Seq [(Object)])]) (Seq [(Object)])] None Features to use. Queue [(None) (ContextVar [(Object)])] None The queue to draw from (Optional). Uses the default queue if not specified","title":"Parameters"},{"location":"shards/GFX/DrawablePass/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/DrawablePass/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/Feature/","text":"GFX.Feature \u00b6 ( GFX.Feature ) Definition \u00b6 Input \u00b6 Type Description [(Table [(Any)])] Output \u00b6 Type Description [(Object)]","title":"GFX.Feature"},{"location":"shards/GFX/Feature/#gfxfeature","text":"( GFX.Feature )","title":"GFX.Feature"},{"location":"shards/GFX/Feature/#definition","text":"","title":"Definition"},{"location":"shards/GFX/Feature/#input","text":"Type Description [(Table [(Any)])]","title":"Input"},{"location":"shards/GFX/Feature/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/MainWindow/","text":"GFX.MainWindow \u00b6 ( GFX.MainWindow :Title [( String )] :Width [( Int )] :Height [( Int )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Debug [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Title [(String)] \"\" The title of the window to create. Width [(Int)] 1280 The width of the window to create. In pixels and DPI aware. Height [(Int)] 720 The height of the window to create. In pixels and DPI aware. Contents [(Shard) (Seq [(Shard)]) (None)] None The contents of this window. Debug [(Bool)] false If the device backing the window should be created with debug layers on. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(None)]","title":"GFX.MainWindow"},{"location":"shards/GFX/MainWindow/#gfxmainwindow","text":"( GFX.MainWindow :Title [( String )] :Width [( Int )] :Height [( Int )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Debug [( Bool )] )","title":"GFX.MainWindow"},{"location":"shards/GFX/MainWindow/#definition","text":"","title":"Definition"},{"location":"shards/GFX/MainWindow/#parameters","text":"Name Type Default Description Title [(String)] \"\" The title of the window to create. Width [(Int)] 1280 The width of the window to create. In pixels and DPI aware. Height [(Int)] 720 The height of the window to create. In pixels and DPI aware. Contents [(Shard) (Seq [(Shard)]) (None)] None The contents of this window. Debug [(Bool)] false If the device backing the window should be created with debug layers on.","title":"Parameters"},{"location":"shards/GFX/MainWindow/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/MainWindow/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/GFX/Material/","text":"GFX.Material \u00b6 ( GFX.Material :Params [( Table [( ContextVar [( Seq [( Float4 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float )])]) ( ContextVar [()])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Params [(Table [(ContextVar [(Seq [(Float4)])]) (ContextVar [(Float4)]) (ContextVar [(Float3)]) (ContextVar [(Float2)]) (ContextVar [(Float)])]) (ContextVar [()])] None The params variable to use Input \u00b6 Type Description [(Table [(Any)])] Output \u00b6 Type Description [(Object)]","title":"GFX.Material"},{"location":"shards/GFX/Material/#gfxmaterial","text":"( GFX.Material :Params [( Table [( ContextVar [( Seq [( Float4 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float )])]) ( ContextVar [()])] )","title":"GFX.Material"},{"location":"shards/GFX/Material/#definition","text":"","title":"Definition"},{"location":"shards/GFX/Material/#parameters","text":"Name Type Default Description Params [(Table [(ContextVar [(Seq [(Float4)])]) (ContextVar [(Float4)]) (ContextVar [(Float3)]) (ContextVar [(Float2)]) (ContextVar [(Float)])]) (ContextVar [()])] None The params variable to use","title":"Parameters"},{"location":"shards/GFX/Material/#input","text":"Type Description [(Table [(Any)])]","title":"Input"},{"location":"shards/GFX/Material/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/Mesh/","text":"GFX.Mesh \u00b6 ( GFX.Mesh :Layout [( Seq [( String )])] :WindingOrder [( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Layout [(Seq [(String)])] None The names for each vertex attribute. WindingOrder [(Enum)] None Front facing winding order for this mesh. Input \u00b6 Type Description [(Table {\"Vertices\" (Seq [(Float) (Float2) (Float3) (Float4) (Color)]) \"Indices\" (Seq [(Int)])})] Output \u00b6 Type Description [(Object)]","title":"GFX.Mesh"},{"location":"shards/GFX/Mesh/#gfxmesh","text":"( GFX.Mesh :Layout [( Seq [( String )])] :WindingOrder [( Enum )] )","title":"GFX.Mesh"},{"location":"shards/GFX/Mesh/#definition","text":"","title":"Definition"},{"location":"shards/GFX/Mesh/#parameters","text":"Name Type Default Description Layout [(Seq [(String)])] None The names for each vertex attribute. WindingOrder [(Enum)] None Front facing winding order for this mesh.","title":"Parameters"},{"location":"shards/GFX/Mesh/#input","text":"Type Description [(Table {\"Vertices\" (Seq [(Float) (Float2) (Float3) (Float4) (Color)]) \"Indices\" (Seq [(Int)])})]","title":"Input"},{"location":"shards/GFX/Mesh/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/Render/","text":"GFX.Render \u00b6 ( GFX.Render :Steps [( ContextVar [( Seq [( Object )])]) ( Seq [( Object )])] :View [( None ) ( ContextVar [( Object )])] :Views [( None ) ( ContextVar [( Seq [( Object )])]) ( Seq [( Object )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Steps [(ContextVar [(Seq [(Object)])]) (Seq [(Object)])] None Render steps to follow. View [(None) (ContextVar [(Object)])] None The view to render into. (Optional) Views [(None) (ContextVar [(Seq [(Object)])]) (Seq [(Object)])] None The views to render into. (Optional) Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(None)]","title":"GFX.Render"},{"location":"shards/GFX/Render/#gfxrender","text":"( GFX.Render :Steps [( ContextVar [( Seq [( Object )])]) ( Seq [( Object )])] :View [( None ) ( ContextVar [( Object )])] :Views [( None ) ( ContextVar [( Seq [( Object )])]) ( Seq [( Object )])] )","title":"GFX.Render"},{"location":"shards/GFX/Render/#definition","text":"","title":"Definition"},{"location":"shards/GFX/Render/#parameters","text":"Name Type Default Description Steps [(ContextVar [(Seq [(Object)])]) (Seq [(Object)])] None Render steps to follow. View [(None) (ContextVar [(Object)])] None The view to render into. (Optional) Views [(None) (ContextVar [(Seq [(Object)])]) (Seq [(Object)])] None The views to render into. (Optional)","title":"Parameters"},{"location":"shards/GFX/Render/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/Render/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/GFX/UIPass/","text":"GFX.UIPass \u00b6 ( GFX.UIPass :Queue [( None ) ( ContextVar [( Object )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Queue [(None) (ContextVar [(Object)])] None The queue to draw from (Optional). Uses the default queue if not specified Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"GFX.UIPass"},{"location":"shards/GFX/UIPass/#gfxuipass","text":"( GFX.UIPass :Queue [( None ) ( ContextVar [( Object )])] )","title":"GFX.UIPass"},{"location":"shards/GFX/UIPass/#definition","text":"","title":"Definition"},{"location":"shards/GFX/UIPass/#parameters","text":"Name Type Default Description Queue [(None) (ContextVar [(Object)])] None The queue to draw from (Optional). Uses the default queue if not specified","title":"Parameters"},{"location":"shards/GFX/UIPass/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/UIPass/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/View/","text":"GFX.View \u00b6 ( GFX.View :View [( None ) ( ContextVar [( Seq [( Float4 )])])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description View [(None) (ContextVar [(Seq [(Float4)])])] None The view matrix. (Optional) Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"GFX.View"},{"location":"shards/GFX/View/#gfxview","text":"( GFX.View :View [( None ) ( ContextVar [( Seq [( Float4 )])])] )","title":"GFX.View"},{"location":"shards/GFX/View/#definition","text":"","title":"Definition"},{"location":"shards/GFX/View/#parameters","text":"Name Type Default Description View [(None) (ContextVar [(Seq [(Float4)])])] None The view matrix. (Optional)","title":"Parameters"},{"location":"shards/GFX/View/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/GFX/View/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GFX/glTF/","text":"GFX.glTF \u00b6 ( GFX.glTF :Transform [( None ) ( ContextVar [( Seq [( Float4 )])])] :Path [( None ) ( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Transform [(None) (ContextVar [(Seq [(Float4)])])] None The transform variable to use Path [(None) (String)] None The static path to load a model from during warmup Input \u00b6 Type Description [(Table [(Any)])] Output \u00b6 Type Description [(Object)]","title":"GFX.glTF"},{"location":"shards/GFX/glTF/#gfxgltf","text":"( GFX.glTF :Transform [( None ) ( ContextVar [( Seq [( Float4 )])])] :Path [( None ) ( String )] )","title":"GFX.glTF"},{"location":"shards/GFX/glTF/#definition","text":"","title":"Definition"},{"location":"shards/GFX/glTF/#parameters","text":"Name Type Default Description Transform [(None) (ContextVar [(Seq [(Float4)])])] None The transform variable to use Path [(None) (String)] None The static path to load a model from during warmup","title":"Parameters"},{"location":"shards/GFX/glTF/#input","text":"Type Description [(Table [(Any)])]","title":"Input"},{"location":"shards/GFX/glTF/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/GUI/Bullet/","text":"GUI.Bullet \u00b6 ( GUI.Bullet ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Bullet"},{"location":"shards/GUI/Bullet/#guibullet","text":"( GUI.Bullet )","title":"GUI.Bullet"},{"location":"shards/GUI/Bullet/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Bullet/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/Bullet/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Button/","text":"GUI.Button \u00b6 ( GUI.Button :Label [( String )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Type [( Enum )] :Size [( Float2 )] :Repeat [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The text label of this button. Action [(Shard) (Seq [(Shard)]) (None)] None The shards to execute when the button is pressed. Type [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x67756942 The button type. Size [(Float2)] (0, 0) The optional size override. Repeat [(Bool)] false Whether to repeat the action while the button is pressed. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the button was clicked during that frame.","title":"GUI.Button"},{"location":"shards/GUI/Button/#guibutton","text":"( GUI.Button :Label [( String )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Type [( Enum )] :Size [( Float2 )] :Repeat [( Bool )] )","title":"GUI.Button"},{"location":"shards/GUI/Button/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Button/#parameters","text":"Name Type Default Description Label [(String)] \"\" The text label of this button. Action [(Shard) (Seq [(Shard)]) (None)] None The shards to execute when the button is pressed. Type [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x67756942 The button type. Size [(Float2)] (0, 0) The optional size override. Repeat [(Bool)] false Whether to repeat the action while the button is pressed.","title":"Parameters"},{"location":"shards/GUI/Button/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Button/#output","text":"Type Description [(Bool)] A boolean indicating whether the button was clicked during that frame.","title":"Output"},{"location":"shards/GUI/Checkbox/","text":"GUI.Checkbox \u00b6 ( GUI.Checkbox :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the checkbox changed state during that frame.","title":"GUI.Checkbox"},{"location":"shards/GUI/Checkbox/#guicheckbox","text":"( GUI.Checkbox :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] )","title":"GUI.Checkbox"},{"location":"shards/GUI/Checkbox/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Checkbox/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value.","title":"Parameters"},{"location":"shards/GUI/Checkbox/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Checkbox/#output","text":"Type Description [(Bool)] A boolean indicating whether the checkbox changed state during that frame.","title":"Output"},{"location":"shards/GUI/CheckboxFlags/","text":"GUI.CheckboxFlags \u00b6 ( GUI.CheckboxFlags :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Value [( Int ) ( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Value [(Int) (Enum)] None The flag value to set or unset. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the checkbox changed state during that frame.","title":"GUI.CheckboxFlags"},{"location":"shards/GUI/CheckboxFlags/#guicheckboxflags","text":"( GUI.CheckboxFlags :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Value [( Int ) ( Enum )] )","title":"GUI.CheckboxFlags"},{"location":"shards/GUI/CheckboxFlags/#definition","text":"","title":"Definition"},{"location":"shards/GUI/CheckboxFlags/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Value [(Int) (Enum)] None The flag value to set or unset.","title":"Parameters"},{"location":"shards/GUI/CheckboxFlags/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/CheckboxFlags/#output","text":"Type Description [(Bool)] A boolean indicating whether the checkbox changed state during that frame.","title":"Output"},{"location":"shards/GUI/ChildWindow/","text":"GUI.ChildWindow \u00b6 ( GUI.ChildWindow :Width [( Int ) ( None )] :Height [( Int ) ( None )] :Border [( Bool )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Width [(Int) (None)] None The width of the child window to create Height [(Int) (None)] None The height of the child window to create. Border [(Bool)] false If we want to draw a border frame around the child window. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.ChildWindow"},{"location":"shards/GUI/ChildWindow/#guichildwindow","text":"( GUI.ChildWindow :Width [( Int ) ( None )] :Height [( Int ) ( None )] :Border [( Bool )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.ChildWindow"},{"location":"shards/GUI/ChildWindow/#definition","text":"","title":"Definition"},{"location":"shards/GUI/ChildWindow/#parameters","text":"Name Type Default Description Width [(Int) (None)] None The width of the child window to create Height [(Int) (None)] None The height of the child window to create. Border [(Bool)] false If we want to draw a border frame around the child window. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/ChildWindow/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/ChildWindow/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/CollapsingHeader/","text":"GUI.CollapsingHeader \u00b6 ( GUI.CollapsingHeader :Label [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :StartOpen [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The label of this node. Contents [(Shard) (Seq [(Shard)]) (None)] None The contents under this header. StartOpen [(Bool)] false If this header should start in the open state. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the header is open.","title":"GUI.CollapsingHeader"},{"location":"shards/GUI/CollapsingHeader/#guicollapsingheader","text":"( GUI.CollapsingHeader :Label [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :StartOpen [( Bool )] )","title":"GUI.CollapsingHeader"},{"location":"shards/GUI/CollapsingHeader/#definition","text":"","title":"Definition"},{"location":"shards/GUI/CollapsingHeader/#parameters","text":"Name Type Default Description Label [(String)] \"\" The label of this node. Contents [(Shard) (Seq [(Shard)]) (None)] None The contents under this header. StartOpen [(Bool)] false If this header should start in the open state.","title":"Parameters"},{"location":"shards/GUI/CollapsingHeader/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/CollapsingHeader/#output","text":"Type Description [(Bool)] A boolean indicating whether the header is open.","title":"Output"},{"location":"shards/GUI/ColorInput/","text":"GUI.ColorInput \u00b6 ( GUI.ColorInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Color)] The color that was input.","title":"GUI.ColorInput"},{"location":"shards/GUI/ColorInput/#guicolorinput","text":"( GUI.ColorInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] )","title":"GUI.ColorInput"},{"location":"shards/GUI/ColorInput/#definition","text":"","title":"Definition"},{"location":"shards/GUI/ColorInput/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value.","title":"Parameters"},{"location":"shards/GUI/ColorInput/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/ColorInput/#output","text":"Type Description [(Color)] The color that was input.","title":"Output"},{"location":"shards/GUI/Combo/","text":"GUI.Combo \u00b6 ( GUI.Combo :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Input \u00b6 Type Description [(Seq [(Any)])] A sequence of values. Output \u00b6 Type Description [(Any)] The selected value.","title":"GUI.Combo"},{"location":"shards/GUI/Combo/#guicombo","text":"( GUI.Combo :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] )","title":"GUI.Combo"},{"location":"shards/GUI/Combo/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Combo/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value.","title":"Parameters"},{"location":"shards/GUI/Combo/#input","text":"Type Description [(Seq [(Any)])] A sequence of values.","title":"Input"},{"location":"shards/GUI/Combo/#output","text":"Type Description [(Any)] The selected value.","title":"Output"},{"location":"shards/GUI/Disable/","text":"GUI.Disable \u00b6 ( GUI.Disable :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Disable [( Bool ) ( ContextVar [( Bool )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Disable [(Bool) (ContextVar [(Bool)])] true Sets whether the contents should be disabled. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Disable"},{"location":"shards/GUI/Disable/#guidisable","text":"( GUI.Disable :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Disable [( Bool ) ( ContextVar [( Bool )])] )","title":"GUI.Disable"},{"location":"shards/GUI/Disable/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Disable/#parameters","text":"Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Disable [(Bool) (ContextVar [(Bool)])] true Sets whether the contents should be disabled.","title":"Parameters"},{"location":"shards/GUI/Disable/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/Disable/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Dummy/","text":"GUI.Dummy \u00b6 ( GUI.Dummy :Width [( Int ) ( ContextVar [( Int )])] :Height [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Width [(Int) (ContextVar [(Int)])] 0 The width of the item. Height [(Int) (ContextVar [(Int)])] 0 The height of the item. Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Dummy"},{"location":"shards/GUI/Dummy/#guidummy","text":"( GUI.Dummy :Width [( Int ) ( ContextVar [( Int )])] :Height [( Int ) ( ContextVar [( Int )])] )","title":"GUI.Dummy"},{"location":"shards/GUI/Dummy/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Dummy/#parameters","text":"Name Type Default Description Width [(Int) (ContextVar [(Int)])] 0 The width of the item. Height [(Int) (ContextVar [(Int)])] 0 The height of the item.","title":"Parameters"},{"location":"shards/GUI/Dummy/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/Dummy/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/FPS/","text":"GUI.FPS \u00b6 ( GUI.FPS ) Definition \u00b6 Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float)] The current framerate.","title":"GUI.FPS"},{"location":"shards/GUI/FPS/#guifps","text":"( GUI.FPS )","title":"GUI.FPS"},{"location":"shards/GUI/FPS/#definition","text":"","title":"Definition"},{"location":"shards/GUI/FPS/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/FPS/#output","text":"Type Description [(Float)] The current framerate.","title":"Output"},{"location":"shards/GUI/Float2Drag/","text":"GUI.Float2Drag \u00b6 ( GUI.Float2Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float2)] The value produced by this shard.","title":"GUI.Float2Drag"},{"location":"shards/GUI/Float2Drag/#guifloat2drag","text":"( GUI.Float2Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.Float2Drag"},{"location":"shards/GUI/Float2Drag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float2Drag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/Float2Drag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float2Drag/#output","text":"Type Description [(Float2)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Float2Input/","text":"GUI.Float2Input \u00b6 ( GUI.Float2Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float2)] The value that was input.","title":"GUI.Float2Input"},{"location":"shards/GUI/Float2Input/#guifloat2input","text":"( GUI.Float2Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] )","title":"GUI.Float2Input"},{"location":"shards/GUI/Float2Input/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float2Input/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/Float2Input/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float2Input/#output","text":"Type Description [(Float2)] The value that was input.","title":"Output"},{"location":"shards/GUI/Float2Slider/","text":"GUI.Float2Slider \u00b6 ( GUI.Float2Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float2)] The value produced by this shard.","title":"GUI.Float2Slider"},{"location":"shards/GUI/Float2Slider/#guifloat2slider","text":"( GUI.Float2Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] )","title":"GUI.Float2Slider"},{"location":"shards/GUI/Float2Slider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float2Slider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/Float2Slider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float2Slider/#output","text":"Type Description [(Float2)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Float3Drag/","text":"GUI.Float3Drag \u00b6 ( GUI.Float3Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float3)] The value produced by this shard.","title":"GUI.Float3Drag"},{"location":"shards/GUI/Float3Drag/#guifloat3drag","text":"( GUI.Float3Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.Float3Drag"},{"location":"shards/GUI/Float3Drag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float3Drag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/Float3Drag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float3Drag/#output","text":"Type Description [(Float3)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Float3Input/","text":"GUI.Float3Input \u00b6 ( GUI.Float3Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float3)] The value that was input.","title":"GUI.Float3Input"},{"location":"shards/GUI/Float3Input/#guifloat3input","text":"( GUI.Float3Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] )","title":"GUI.Float3Input"},{"location":"shards/GUI/Float3Input/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float3Input/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/Float3Input/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float3Input/#output","text":"Type Description [(Float3)] The value that was input.","title":"Output"},{"location":"shards/GUI/Float3Slider/","text":"GUI.Float3Slider \u00b6 ( GUI.Float3Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float3)] The value produced by this shard.","title":"GUI.Float3Slider"},{"location":"shards/GUI/Float3Slider/#guifloat3slider","text":"( GUI.Float3Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] )","title":"GUI.Float3Slider"},{"location":"shards/GUI/Float3Slider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float3Slider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/Float3Slider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float3Slider/#output","text":"Type Description [(Float3)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Float4Drag/","text":"GUI.Float4Drag \u00b6 ( GUI.Float4Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float4)] The value produced by this shard.","title":"GUI.Float4Drag"},{"location":"shards/GUI/Float4Drag/#guifloat4drag","text":"( GUI.Float4Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.Float4Drag"},{"location":"shards/GUI/Float4Drag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float4Drag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/Float4Drag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float4Drag/#output","text":"Type Description [(Float4)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Float4Input/","text":"GUI.Float4Input \u00b6 ( GUI.Float4Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float4)] The value that was input.","title":"GUI.Float4Input"},{"location":"shards/GUI/Float4Input/#guifloat4input","text":"( GUI.Float4Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] )","title":"GUI.Float4Input"},{"location":"shards/GUI/Float4Input/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float4Input/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/Float4Input/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float4Input/#output","text":"Type Description [(Float4)] The value that was input.","title":"Output"},{"location":"shards/GUI/Float4Slider/","text":"GUI.Float4Slider \u00b6 ( GUI.Float4Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float4)] The value produced by this shard.","title":"GUI.Float4Slider"},{"location":"shards/GUI/Float4Slider/#guifloat4slider","text":"( GUI.Float4Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] )","title":"GUI.Float4Slider"},{"location":"shards/GUI/Float4Slider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Float4Slider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/Float4Slider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Float4Slider/#output","text":"Type Description [(Float4)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/FloatDrag/","text":"GUI.FloatDrag \u00b6 ( GUI.FloatDrag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float)] The value produced by this shard.","title":"GUI.FloatDrag"},{"location":"shards/GUI/FloatDrag/#guifloatdrag","text":"( GUI.FloatDrag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.FloatDrag"},{"location":"shards/GUI/FloatDrag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/FloatDrag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/FloatDrag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/FloatDrag/#output","text":"Type Description [(Float)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/FloatInput/","text":"GUI.FloatInput \u00b6 ( GUI.FloatInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float)] The value that was input.","title":"GUI.FloatInput"},{"location":"shards/GUI/FloatInput/#guifloatinput","text":"( GUI.FloatInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Float ) ( ContextVar [( Float )])] :StepFast [( Float ) ( ContextVar [( Float )])] )","title":"GUI.FloatInput"},{"location":"shards/GUI/FloatInput/#definition","text":"","title":"Definition"},{"location":"shards/GUI/FloatInput/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Float) (ContextVar [(Float)])] 0 The value of a single increment. StepFast [(Float) (ContextVar [(Float)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/FloatInput/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/FloatInput/#output","text":"Type Description [(Float)] The value that was input.","title":"Output"},{"location":"shards/GUI/FloatSlider/","text":"GUI.FloatSlider \u00b6 ( GUI.FloatSlider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Float)] The value produced by this shard.","title":"GUI.FloatSlider"},{"location":"shards/GUI/FloatSlider/#guifloatslider","text":"( GUI.FloatSlider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] )","title":"GUI.FloatSlider"},{"location":"shards/GUI/FloatSlider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/FloatSlider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] 0 The minimum value. Max [(Float) (ContextVar [(Float)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/FloatSlider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/FloatSlider/#output","text":"Type Description [(Float)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/GetClipboard/","text":"GUI.GetClipboard \u00b6 ( GUI.GetClipboard ) Definition \u00b6 Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(String)] The content of the clipboard.","title":"GUI.GetClipboard"},{"location":"shards/GUI/GetClipboard/#guigetclipboard","text":"( GUI.GetClipboard )","title":"GUI.GetClipboard"},{"location":"shards/GUI/GetClipboard/#definition","text":"","title":"Definition"},{"location":"shards/GUI/GetClipboard/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/GetClipboard/#output","text":"Type Description [(String)] The content of the clipboard.","title":"Output"},{"location":"shards/GUI/Group/","text":"GUI.Group \u00b6 ( GUI.Group :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Group"},{"location":"shards/GUI/Group/#guigroup","text":"( GUI.Group :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.Group"},{"location":"shards/GUI/Group/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Group/#parameters","text":"Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/Group/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/Group/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/HasPointer/","text":"GUI.HasPointer \u00b6 ( GUI.HasPointer ) Definition \u00b6 Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Bool)] A boolean.","title":"GUI.HasPointer"},{"location":"shards/GUI/HasPointer/#guihaspointer","text":"( GUI.HasPointer )","title":"GUI.HasPointer"},{"location":"shards/GUI/HasPointer/#definition","text":"","title":"Definition"},{"location":"shards/GUI/HasPointer/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/HasPointer/#output","text":"Type Description [(Bool)] A boolean.","title":"Output"},{"location":"shards/GUI/HeadersRow/","text":"GUI.HeadersRow \u00b6 ( GUI.HeadersRow ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.HeadersRow"},{"location":"shards/GUI/HeadersRow/#guiheadersrow","text":"( GUI.HeadersRow )","title":"GUI.HeadersRow"},{"location":"shards/GUI/HeadersRow/#definition","text":"","title":"Definition"},{"location":"shards/GUI/HeadersRow/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/HeadersRow/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/HelpMarker/","text":"GUI.HelpMarker \u00b6 ( GUI.HelpMarker :Description [( String )] :Inline [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Description [(String)] None The text displayed in a popup. Inline [(Bool)] true Display on the same line. Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.HelpMarker"},{"location":"shards/GUI/HelpMarker/#guihelpmarker","text":"( GUI.HelpMarker :Description [( String )] :Inline [( Bool )] )","title":"GUI.HelpMarker"},{"location":"shards/GUI/HelpMarker/#definition","text":"","title":"Definition"},{"location":"shards/GUI/HelpMarker/#parameters","text":"Name Type Default Description Description [(String)] None The text displayed in a popup. Inline [(Bool)] true Display on the same line.","title":"Parameters"},{"location":"shards/GUI/HelpMarker/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/HelpMarker/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/HexViewer/","text":"GUI.HexViewer \u00b6 ( GUI.HexViewer ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] The value to display in the viewer. Output \u00b6 Type Description [(Bytes)] The output of this shard will be its input.","title":"GUI.HexViewer"},{"location":"shards/GUI/HexViewer/#guihexviewer","text":"( GUI.HexViewer )","title":"GUI.HexViewer"},{"location":"shards/GUI/HexViewer/#definition","text":"","title":"Definition"},{"location":"shards/GUI/HexViewer/#input","text":"Type Description [(Bytes)] The value to display in the viewer.","title":"Input"},{"location":"shards/GUI/HexViewer/#output","text":"Type Description [(Bytes)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Indent/","text":"GUI.Indent \u00b6 ( GUI.Indent ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Indent"},{"location":"shards/GUI/Indent/#guiindent","text":"( GUI.Indent )","title":"GUI.Indent"},{"location":"shards/GUI/Indent/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Indent/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/Indent/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Int2Drag/","text":"GUI.Int2Drag \u00b6 ( GUI.Int2Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int2)] The value produced by this shard.","title":"GUI.Int2Drag"},{"location":"shards/GUI/Int2Drag/#guiint2drag","text":"( GUI.Int2Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.Int2Drag"},{"location":"shards/GUI/Int2Drag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int2Drag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/Int2Drag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int2Drag/#output","text":"Type Description [(Int2)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Int2Input/","text":"GUI.Int2Input \u00b6 ( GUI.Int2Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int2)] The value that was input.","title":"GUI.Int2Input"},{"location":"shards/GUI/Int2Input/#guiint2input","text":"( GUI.Int2Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] )","title":"GUI.Int2Input"},{"location":"shards/GUI/Int2Input/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int2Input/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/Int2Input/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int2Input/#output","text":"Type Description [(Int2)] The value that was input.","title":"Output"},{"location":"shards/GUI/Int2Slider/","text":"GUI.Int2Slider \u00b6 ( GUI.Int2Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int2)] The value produced by this shard.","title":"GUI.Int2Slider"},{"location":"shards/GUI/Int2Slider/#guiint2slider","text":"( GUI.Int2Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] )","title":"GUI.Int2Slider"},{"location":"shards/GUI/Int2Slider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int2Slider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/Int2Slider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int2Slider/#output","text":"Type Description [(Int2)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Int3Drag/","text":"GUI.Int3Drag \u00b6 ( GUI.Int3Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int3)] The value produced by this shard.","title":"GUI.Int3Drag"},{"location":"shards/GUI/Int3Drag/#guiint3drag","text":"( GUI.Int3Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.Int3Drag"},{"location":"shards/GUI/Int3Drag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int3Drag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/Int3Drag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int3Drag/#output","text":"Type Description [(Int3)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Int3Input/","text":"GUI.Int3Input \u00b6 ( GUI.Int3Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int3)] The value that was input.","title":"GUI.Int3Input"},{"location":"shards/GUI/Int3Input/#guiint3input","text":"( GUI.Int3Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] )","title":"GUI.Int3Input"},{"location":"shards/GUI/Int3Input/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int3Input/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/Int3Input/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int3Input/#output","text":"Type Description [(Int3)] The value that was input.","title":"Output"},{"location":"shards/GUI/Int3Slider/","text":"GUI.Int3Slider \u00b6 ( GUI.Int3Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int3)] The value produced by this shard.","title":"GUI.Int3Slider"},{"location":"shards/GUI/Int3Slider/#guiint3slider","text":"( GUI.Int3Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] )","title":"GUI.Int3Slider"},{"location":"shards/GUI/Int3Slider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int3Slider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/Int3Slider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int3Slider/#output","text":"Type Description [(Int3)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Int4Drag/","text":"GUI.Int4Drag \u00b6 ( GUI.Int4Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int4)] The value produced by this shard.","title":"GUI.Int4Drag"},{"location":"shards/GUI/Int4Drag/#guiint4drag","text":"( GUI.Int4Drag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.Int4Drag"},{"location":"shards/GUI/Int4Drag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int4Drag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/Int4Drag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int4Drag/#output","text":"Type Description [(Int4)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/Int4Input/","text":"GUI.Int4Input \u00b6 ( GUI.Int4Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int4)] The value that was input.","title":"GUI.Int4Input"},{"location":"shards/GUI/Int4Input/#guiint4input","text":"( GUI.Int4Input :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] )","title":"GUI.Int4Input"},{"location":"shards/GUI/Int4Input/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int4Input/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/Int4Input/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int4Input/#output","text":"Type Description [(Int4)] The value that was input.","title":"Output"},{"location":"shards/GUI/Int4Slider/","text":"GUI.Int4Slider \u00b6 ( GUI.Int4Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int4)] The value produced by this shard.","title":"GUI.Int4Slider"},{"location":"shards/GUI/Int4Slider/#guiint4slider","text":"( GUI.Int4Slider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] )","title":"GUI.Int4Slider"},{"location":"shards/GUI/Int4Slider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Int4Slider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/Int4Slider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Int4Slider/#output","text":"Type Description [(Int4)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/IntDrag/","text":"GUI.IntDrag \u00b6 ( GUI.IntDrag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int)] The value produced by this shard.","title":"GUI.IntDrag"},{"location":"shards/GUI/IntDrag/#guiintdrag","text":"( GUI.IntDrag :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Speed [( String ) ( None )] )","title":"GUI.IntDrag"},{"location":"shards/GUI/IntDrag/#definition","text":"","title":"Definition"},{"location":"shards/GUI/IntDrag/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Speed [(String) (None)] 1 The speed multiplier for this drag widget.","title":"Parameters"},{"location":"shards/GUI/IntDrag/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/IntDrag/#output","text":"Type Description [(Int)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/IntInput/","text":"GUI.IntInput \u00b6 ( GUI.IntInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int)] The value that was input.","title":"GUI.IntInput"},{"location":"shards/GUI/IntInput/#guiintinput","text":"( GUI.IntInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Step [( Int ) ( ContextVar [( Int )])] :StepFast [( Int ) ( ContextVar [( Int )])] )","title":"GUI.IntInput"},{"location":"shards/GUI/IntInput/#definition","text":"","title":"Definition"},{"location":"shards/GUI/IntInput/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Step [(Int) (ContextVar [(Int)])] 0 The value of a single increment. StepFast [(Int) (ContextVar [(Int)])] 0 The value of a single increment, when holding Ctrl","title":"Parameters"},{"location":"shards/GUI/IntInput/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/IntInput/#output","text":"Type Description [(Int)] The value that was input.","title":"Output"},{"location":"shards/GUI/IntSlider/","text":"GUI.IntSlider \u00b6 ( GUI.IntSlider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Int)] The value produced by this shard.","title":"GUI.IntSlider"},{"location":"shards/GUI/IntSlider/#guiintslider","text":"( GUI.IntSlider :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] )","title":"GUI.IntSlider"},{"location":"shards/GUI/IntSlider/#definition","text":"","title":"Definition"},{"location":"shards/GUI/IntSlider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] 0 The minimum value. Max [(Int) (ContextVar [(Int)])] 100 The maximum value.","title":"Parameters"},{"location":"shards/GUI/IntSlider/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/IntSlider/#output","text":"Type Description [(Int)] The value produced by this shard.","title":"Output"},{"location":"shards/GUI/ListBox/","text":"GUI.ListBox \u00b6 ( GUI.ListBox :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :ItemsHeight [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. ItemsHeight [(Int)] -1 Height of the list in number of items Input \u00b6 Type Description [(Seq [(Any)])] A sequence of values. Output \u00b6 Type Description [(Any)] The currently selected value.","title":"GUI.ListBox"},{"location":"shards/GUI/ListBox/#guilistbox","text":"( GUI.ListBox :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :ItemsHeight [( Int )] )","title":"GUI.ListBox"},{"location":"shards/GUI/ListBox/#definition","text":"","title":"Definition"},{"location":"shards/GUI/ListBox/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. ItemsHeight [(Int)] -1 Height of the list in number of items","title":"Parameters"},{"location":"shards/GUI/ListBox/#input","text":"Type Description [(Seq [(Any)])] A sequence of values.","title":"Input"},{"location":"shards/GUI/ListBox/#output","text":"Type Description [(Any)] The currently selected value.","title":"Output"},{"location":"shards/GUI/MainMenuBar/","text":"GUI.MainMenuBar \u00b6 ( GUI.MainMenuBar :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the menu is visible.","title":"GUI.MainMenuBar"},{"location":"shards/GUI/MainMenuBar/#guimainmenubar","text":"( GUI.MainMenuBar :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.MainMenuBar"},{"location":"shards/GUI/MainMenuBar/#definition","text":"","title":"Definition"},{"location":"shards/GUI/MainMenuBar/#parameters","text":"Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/MainMenuBar/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/MainMenuBar/#output","text":"Type Description [(Bool)] A boolean indicating whether the menu is visible.","title":"Output"},{"location":"shards/GUI/Menu/","text":"GUI.Menu \u00b6 ( GUI.Menu :Label [( String )] :IsEnabled [( Bool ) ( ContextVar [( Bool )])] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The label of the menu IsEnabled [(Bool) (ContextVar [(Bool)])] true Sets whether this menu is enabled. A disabled item cannot be selected or clicked. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the menu is visible.","title":"GUI.Menu"},{"location":"shards/GUI/Menu/#guimenu","text":"( GUI.Menu :Label [( String )] :IsEnabled [( Bool ) ( ContextVar [( Bool )])] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.Menu"},{"location":"shards/GUI/Menu/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Menu/#parameters","text":"Name Type Default Description Label [(String)] \"\" The label of the menu IsEnabled [(Bool) (ContextVar [(Bool)])] true Sets whether this menu is enabled. A disabled item cannot be selected or clicked. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/Menu/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/Menu/#output","text":"Type Description [(Bool)] A boolean indicating whether the menu is visible.","title":"Output"},{"location":"shards/GUI/MenuBar/","text":"GUI.MenuBar \u00b6 ( GUI.MenuBar :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the menu is visible.","title":"GUI.MenuBar"},{"location":"shards/GUI/MenuBar/#guimenubar","text":"( GUI.MenuBar :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.MenuBar"},{"location":"shards/GUI/MenuBar/#definition","text":"","title":"Definition"},{"location":"shards/GUI/MenuBar/#parameters","text":"Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/MenuBar/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/MenuBar/#output","text":"Type Description [(Bool)] A boolean indicating whether the menu is visible.","title":"Output"},{"location":"shards/GUI/MenuItem/","text":"GUI.MenuItem \u00b6 ( GUI.MenuItem :Label [( String )] :IsChecked [( Bool ) ( ContextVar [( Bool )])] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Shortcut [( String )] :IsEnabled [( Bool ) ( ContextVar [( Bool )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] None The label of the menu item IsChecked [(Bool) (ContextVar [(Bool)])] false Sets whether this menu item is checked. A checked item displays a check mark on the side. Action [(Shard) (Seq [(Shard)]) (None)] None Shortcut [(String)] None A keyboard shortcut to activate that item IsEnabled [(Bool) (ContextVar [(Bool)])] true Sets whether this menu item is enabled. A disabled item cannot be selected or clicked. Input \u00b6 Type Description [(Any)] The value will be passed to the Action shards. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.MenuItem"},{"location":"shards/GUI/MenuItem/#guimenuitem","text":"( GUI.MenuItem :Label [( String )] :IsChecked [( Bool ) ( ContextVar [( Bool )])] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Shortcut [( String )] :IsEnabled [( Bool ) ( ContextVar [( Bool )])] )","title":"GUI.MenuItem"},{"location":"shards/GUI/MenuItem/#definition","text":"","title":"Definition"},{"location":"shards/GUI/MenuItem/#parameters","text":"Name Type Default Description Label [(String)] None The label of the menu item IsChecked [(Bool) (ContextVar [(Bool)])] false Sets whether this menu item is checked. A checked item displays a check mark on the side. Action [(Shard) (Seq [(Shard)]) (None)] None Shortcut [(String)] None A keyboard shortcut to activate that item IsEnabled [(Bool) (ContextVar [(Bool)])] true Sets whether this menu item is enabled. A disabled item cannot be selected or clicked.","title":"Parameters"},{"location":"shards/GUI/MenuItem/#input","text":"Type Description [(Any)] The value will be passed to the Action shards.","title":"Input"},{"location":"shards/GUI/MenuItem/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/NewLine/","text":"GUI.NewLine \u00b6 ( GUI.NewLine ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.NewLine"},{"location":"shards/GUI/NewLine/#guinewline","text":"( GUI.NewLine )","title":"GUI.NewLine"},{"location":"shards/GUI/NewLine/#definition","text":"","title":"Definition"},{"location":"shards/GUI/NewLine/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/NewLine/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/NextColumn/","text":"GUI.NextColumn \u00b6 ( GUI.NextColumn ) Definition \u00b6 Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the table column is visible. Details \u00b6 This shard, whenever it's called within a table (i.e. a GUI.Table ), automatically generates a new column that can be processed and then rendered as part of that parent table. For example, the output of every iteration of a ForEach shard can be rendered as a new column using this shard (see Examples below). Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;; Render a GUI.table with a NextColumn shard ( def grid-cols 3 ) ( def input-grid [ 1 2 3 4 5 ]) ;; input data for GUI.Table ;; GUI.Table render using the GUI.NextColumn ( defshards renderNxtCol [] ( GUI.Table :Columns grid-cols :Contents ( ForEach ( -> ( | ( GUI.NextColumn )) ( | ( GUI.Text )))))) ;; toggle .grid render statements (33, 34) to see how the output ;; looks like with and without the GUI.NextColumn function ( defloop main-wire input-grid >= .grid ( GFX.MainWindow :Title \"Code Output\" :Width 480 :Height 360 :Contents ( -> ( GUI.Window :Title \"canvas\" :Width 1.0 :Height 1.0 :Pos ( int2 0 0 ) :Flags [ GuiWindowFlags.NoTitleBar GuiWindowFlags.NoResize GuiWindowFlags.NoMove GuiWindowFlags.NoCollapse ] :Contents ( -> .grid ( renderNxtCol )))))) ;; new col for every value => GUI shows data ( defmesh root ) ( schedule root main-wire ) ( run root ( / 1.0 50 ) 100 ) ;; GUI Window will persist for 2 seconds (100 frames at 50 FPS) [info] [2022-08-15 10:09:25.358] [T-1580] [SHCore.cpp::963] Ignoring value inside a wire definition: #user-function(00000283eda78180) ignore this warning if this was intentional. [info] [2022-08-15 10:09:25.359] [T-1580] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ;; Render a GUI.table without a NextColumn shard ( def grid-cols 3 ) ( def input-grid [ 1 2 3 4 5 ]) ;; input data for GUI.Table ;; GUI.Table render without using the GUI.NextColumn ( defshards renderNoNxtCol [] ( GUI.Table :Columns grid-cols :Contents ( ForEach ( -> ( GUI.Text ))))) ;; toggle .grid render statements (33, 34) to see how the output ;; looks like with and without the GUI.NextColumn function ( defloop main-wire input-grid >= .grid ( GFX.MainWindow :Title \"Code Output\" :Width 480 :Height 360 :Contents ( -> ( GUI.Window :Title \"canvas\" :Width 1.0 :Height 1.0 :Pos ( int2 0 0 ) :Flags [ GuiWindowFlags.NoTitleBar GuiWindowFlags.NoResize GuiWindowFlags.NoMove GuiWindowFlags.NoCollapse ] :Contents ( -> .grid ( renderNoNxtCol )))))) ;; no new col created => no GUI data shown ( defmesh root ) ( schedule root main-wire ) ( run root ( / 1.0 50 ) 100 ) ;; GUI Window will persist for 2 seconds (100 frames at 50 FPS) [info] [2022-08-15 10:09:27.481] [T-1512] [SHCore.cpp::963] Ignoring value inside a wire definition: #user-function(0000021343397a60) ignore this warning if this was intentional. [info] [2022-08-15 10:09:27.482] [T-1512] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"GUI.NextColumn"},{"location":"shards/GUI/NextColumn/#guinextcolumn","text":"( GUI.NextColumn )","title":"GUI.NextColumn"},{"location":"shards/GUI/NextColumn/#definition","text":"","title":"Definition"},{"location":"shards/GUI/NextColumn/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/NextColumn/#output","text":"Type Description [(Bool)] A boolean indicating whether the table column is visible.","title":"Output"},{"location":"shards/GUI/NextColumn/#details","text":"This shard, whenever it's called within a table (i.e. a GUI.Table ), automatically generates a new column that can be processed and then rendered as part of that parent table. For example, the output of every iteration of a ForEach shard can be rendered as a new column using this shard (see Examples below).","title":"Details"},{"location":"shards/GUI/NextColumn/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;; Render a GUI.table with a NextColumn shard ( def grid-cols 3 ) ( def input-grid [ 1 2 3 4 5 ]) ;; input data for GUI.Table ;; GUI.Table render using the GUI.NextColumn ( defshards renderNxtCol [] ( GUI.Table :Columns grid-cols :Contents ( ForEach ( -> ( | ( GUI.NextColumn )) ( | ( GUI.Text )))))) ;; toggle .grid render statements (33, 34) to see how the output ;; looks like with and without the GUI.NextColumn function ( defloop main-wire input-grid >= .grid ( GFX.MainWindow :Title \"Code Output\" :Width 480 :Height 360 :Contents ( -> ( GUI.Window :Title \"canvas\" :Width 1.0 :Height 1.0 :Pos ( int2 0 0 ) :Flags [ GuiWindowFlags.NoTitleBar GuiWindowFlags.NoResize GuiWindowFlags.NoMove GuiWindowFlags.NoCollapse ] :Contents ( -> .grid ( renderNxtCol )))))) ;; new col for every value => GUI shows data ( defmesh root ) ( schedule root main-wire ) ( run root ( / 1.0 50 ) 100 ) ;; GUI Window will persist for 2 seconds (100 frames at 50 FPS) [info] [2022-08-15 10:09:25.358] [T-1580] [SHCore.cpp::963] Ignoring value inside a wire definition: #user-function(00000283eda78180) ignore this warning if this was intentional. [info] [2022-08-15 10:09:25.359] [T-1580] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ;; Render a GUI.table without a NextColumn shard ( def grid-cols 3 ) ( def input-grid [ 1 2 3 4 5 ]) ;; input data for GUI.Table ;; GUI.Table render without using the GUI.NextColumn ( defshards renderNoNxtCol [] ( GUI.Table :Columns grid-cols :Contents ( ForEach ( -> ( GUI.Text ))))) ;; toggle .grid render statements (33, 34) to see how the output ;; looks like with and without the GUI.NextColumn function ( defloop main-wire input-grid >= .grid ( GFX.MainWindow :Title \"Code Output\" :Width 480 :Height 360 :Contents ( -> ( GUI.Window :Title \"canvas\" :Width 1.0 :Height 1.0 :Pos ( int2 0 0 ) :Flags [ GuiWindowFlags.NoTitleBar GuiWindowFlags.NoResize GuiWindowFlags.NoMove GuiWindowFlags.NoCollapse ] :Contents ( -> .grid ( renderNoNxtCol )))))) ;; no new col created => no GUI data shown ( defmesh root ) ( schedule root main-wire ) ( run root ( / 1.0 50 ) 100 ) ;; GUI Window will persist for 2 seconds (100 frames at 50 FPS) [info] [2022-08-15 10:09:27.481] [T-1512] [SHCore.cpp::963] Ignoring value inside a wire definition: #user-function(0000021343397a60) ignore this warning if this was intentional. [info] [2022-08-15 10:09:27.482] [T-1512] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"Examples"},{"location":"shards/GUI/NextRow/","text":"GUI.NextRow \u00b6 ( GUI.NextRow ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.NextRow"},{"location":"shards/GUI/NextRow/#guinextrow","text":"( GUI.NextRow )","title":"GUI.NextRow"},{"location":"shards/GUI/NextRow/#definition","text":"","title":"Definition"},{"location":"shards/GUI/NextRow/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/NextRow/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Plot/","text":"GUI.Plot \u00b6 ( GUI.Plot :Title [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Width [( Int ) ( None )] :Height [( Int ) ( None )] :X_Label [( String )] :Y_Label [( String )] :X_Limits [( None ) ( Float2 ) ( ContextVar [( Float2 )])] :Y_Limits [( None ) ( Float2 ) ( ContextVar [( Float2 )])] :Lock_X [( Bool ) ( ContextVar [( Bool )])] :Lock_Y [( Bool ) ( ContextVar [( Bool )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Title [(String)] \"\" The title of the plot to create. Contents [(Shard) (Seq [(Shard)]) (None)] None The shards describing this plot. Width [(Int) (None)] None The width of the plot area to create. Height [(Int) (None)] None The height of the plot area to create. X_Label [(String)] \"\" The X axis label. Y_Label [(String)] \"\" The Y axis label. X_Limits [(None) (Float2) (ContextVar [(Float2)])] None The X axis limits. Y_Limits [(None) (Float2) (ContextVar [(Float2)])] None The Y axis limits. Lock_X [(Bool) (ContextVar [(Bool)])] false If the X axis should be locked into its limits. Lock_Y [(Bool) (ContextVar [(Bool)])] false If the Y axis should be locked into its limits. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Plot"},{"location":"shards/GUI/Plot/#guiplot","text":"( GUI.Plot :Title [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Width [( Int ) ( None )] :Height [( Int ) ( None )] :X_Label [( String )] :Y_Label [( String )] :X_Limits [( None ) ( Float2 ) ( ContextVar [( Float2 )])] :Y_Limits [( None ) ( Float2 ) ( ContextVar [( Float2 )])] :Lock_X [( Bool ) ( ContextVar [( Bool )])] :Lock_Y [( Bool ) ( ContextVar [( Bool )])] )","title":"GUI.Plot"},{"location":"shards/GUI/Plot/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Plot/#parameters","text":"Name Type Default Description Title [(String)] \"\" The title of the plot to create. Contents [(Shard) (Seq [(Shard)]) (None)] None The shards describing this plot. Width [(Int) (None)] None The width of the plot area to create. Height [(Int) (None)] None The height of the plot area to create. X_Label [(String)] \"\" The X axis label. Y_Label [(String)] \"\" The Y axis label. X_Limits [(None) (Float2) (ContextVar [(Float2)])] None The X axis limits. Y_Limits [(None) (Float2) (ContextVar [(Float2)])] None The Y axis limits. Lock_X [(Bool) (ContextVar [(Bool)])] false If the X axis should be locked into its limits. Lock_Y [(Bool) (ContextVar [(Bool)])] false If the Y axis should be locked into its limits.","title":"Parameters"},{"location":"shards/GUI/Plot/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/Plot/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/PlotBars/","text":"GUI.PlotBars \u00b6 ( GUI.PlotBars :Label [( String )] :Color [( None ) ( Color )] :Width [( Float )] :Horizontal [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color. Width [(Float)] None The width of each bar Horizontal [(Bool)] 0.67 If the bar should be horiziontal rather than vertical Input \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values. Output \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"GUI.PlotBars"},{"location":"shards/GUI/PlotBars/#guiplotbars","text":"( GUI.PlotBars :Label [( String )] :Color [( None ) ( Color )] :Width [( Float )] :Horizontal [( Bool )] )","title":"GUI.PlotBars"},{"location":"shards/GUI/PlotBars/#definition","text":"","title":"Definition"},{"location":"shards/GUI/PlotBars/#parameters","text":"Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color. Width [(Float)] None The width of each bar Horizontal [(Bool)] 0.67 If the bar should be horiziontal rather than vertical","title":"Parameters"},{"location":"shards/GUI/PlotBars/#input","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values.","title":"Input"},{"location":"shards/GUI/PlotBars/#output","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/PlotDigital/","text":"GUI.PlotDigital \u00b6 ( GUI.PlotDigital :Label [( String )] :Color [( None ) ( Color )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color. Input \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values. Output \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"GUI.PlotDigital"},{"location":"shards/GUI/PlotDigital/#guiplotdigital","text":"( GUI.PlotDigital :Label [( String )] :Color [( None ) ( Color )] )","title":"GUI.PlotDigital"},{"location":"shards/GUI/PlotDigital/#definition","text":"","title":"Definition"},{"location":"shards/GUI/PlotDigital/#parameters","text":"Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color.","title":"Parameters"},{"location":"shards/GUI/PlotDigital/#input","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values.","title":"Input"},{"location":"shards/GUI/PlotDigital/#output","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/PlotLine/","text":"GUI.PlotLine \u00b6 ( GUI.PlotLine :Label [( String )] :Color [( None ) ( Color )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color. Input \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values. Output \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"GUI.PlotLine"},{"location":"shards/GUI/PlotLine/#guiplotline","text":"( GUI.PlotLine :Label [( String )] :Color [( None ) ( Color )] )","title":"GUI.PlotLine"},{"location":"shards/GUI/PlotLine/#definition","text":"","title":"Definition"},{"location":"shards/GUI/PlotLine/#parameters","text":"Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color.","title":"Parameters"},{"location":"shards/GUI/PlotLine/#input","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values.","title":"Input"},{"location":"shards/GUI/PlotLine/#output","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/PlotScatter/","text":"GUI.PlotScatter \u00b6 ( GUI.PlotScatter :Label [( String )] :Color [( None ) ( Color )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color. Input \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values. Output \u00b6 Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"GUI.PlotScatter"},{"location":"shards/GUI/PlotScatter/#guiplotscatter","text":"( GUI.PlotScatter :Label [( String )] :Color [( None ) ( Color )] )","title":"GUI.PlotScatter"},{"location":"shards/GUI/PlotScatter/#definition","text":"","title":"Definition"},{"location":"shards/GUI/PlotScatter/#parameters","text":"Name Type Default Description Label [(String)] \"\" The plot's label. Color [(None) (Color)] None The plot's color.","title":"Parameters"},{"location":"shards/GUI/PlotScatter/#input","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] A sequence of values.","title":"Input"},{"location":"shards/GUI/PlotScatter/#output","text":"Type Description [(Seq [(Float)]) (Seq [(Float2)])] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/ProgressBar/","text":"GUI.ProgressBar \u00b6 ( GUI.ProgressBar :Overlay [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Overlay [(String)] None The text displayed inside the progress bar. Input \u00b6 Type Description [(Float)] The value to display. Output \u00b6 Type Description [(Float)] The output of this shard will be its input.","title":"GUI.ProgressBar"},{"location":"shards/GUI/ProgressBar/#guiprogressbar","text":"( GUI.ProgressBar :Overlay [( String )] )","title":"GUI.ProgressBar"},{"location":"shards/GUI/ProgressBar/#definition","text":"","title":"Definition"},{"location":"shards/GUI/ProgressBar/#parameters","text":"Name Type Default Description Overlay [(String)] None The text displayed inside the progress bar.","title":"Parameters"},{"location":"shards/GUI/ProgressBar/#input","text":"Type Description [(Float)] The value to display.","title":"Input"},{"location":"shards/GUI/ProgressBar/#output","text":"Type Description [(Float)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/RadioButton/","text":"GUI.RadioButton \u00b6 ( GUI.RadioButton :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Value [(Any)] None The value to compare with. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the radio button changed state during that frame.","title":"GUI.RadioButton"},{"location":"shards/GUI/RadioButton/#guiradiobutton","text":"( GUI.RadioButton :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Value [( Any )] )","title":"GUI.RadioButton"},{"location":"shards/GUI/RadioButton/#definition","text":"","title":"Definition"},{"location":"shards/GUI/RadioButton/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Value [(Any)] None The value to compare with.","title":"Parameters"},{"location":"shards/GUI/RadioButton/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/RadioButton/#output","text":"Type Description [(Bool)] A boolean indicating whether the radio button changed state during that frame.","title":"Output"},{"location":"shards/GUI/SameLine/","text":"GUI.SameLine \u00b6 ( GUI.SameLine ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.SameLine"},{"location":"shards/GUI/SameLine/#guisameline","text":"( GUI.SameLine )","title":"GUI.SameLine"},{"location":"shards/GUI/SameLine/#definition","text":"","title":"Definition"},{"location":"shards/GUI/SameLine/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/SameLine/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Selectable/","text":"GUI.Selectable \u00b6 ( GUI.Selectable :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(Bool)] A boolean indicating whether this item is currently selected.","title":"GUI.Selectable"},{"location":"shards/GUI/Selectable/#guiselectable","text":"( GUI.Selectable :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] )","title":"GUI.Selectable"},{"location":"shards/GUI/Selectable/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Selectable/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value.","title":"Parameters"},{"location":"shards/GUI/Selectable/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/Selectable/#output","text":"Type Description [(Bool)] A boolean indicating whether this item is currently selected.","title":"Output"},{"location":"shards/GUI/Separator/","text":"GUI.Separator \u00b6 ( GUI.Separator ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Separator"},{"location":"shards/GUI/Separator/#guiseparator","text":"( GUI.Separator )","title":"GUI.Separator"},{"location":"shards/GUI/Separator/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Separator/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/Separator/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/SetClipboard/","text":"GUI.SetClipboard \u00b6 ( GUI.SetClipboard ) Definition \u00b6 Input \u00b6 Type Description [(String)] The value to set in the clipboard. Output \u00b6 Type Description [(String)] The output of this shard will be its input.","title":"GUI.SetClipboard"},{"location":"shards/GUI/SetClipboard/#guisetclipboard","text":"( GUI.SetClipboard )","title":"GUI.SetClipboard"},{"location":"shards/GUI/SetClipboard/#definition","text":"","title":"Definition"},{"location":"shards/GUI/SetClipboard/#input","text":"Type Description [(String)] The value to set in the clipboard.","title":"Input"},{"location":"shards/GUI/SetClipboard/#output","text":"Type Description [(String)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/SetColumnIndex/","text":"GUI.SetColumnIndex \u00b6 ( GUI.SetColumnIndex ) Definition \u00b6 Input \u00b6 Type Description [(Int)] The table index. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the table column is visible.","title":"GUI.SetColumnIndex"},{"location":"shards/GUI/SetColumnIndex/#guisetcolumnindex","text":"( GUI.SetColumnIndex )","title":"GUI.SetColumnIndex"},{"location":"shards/GUI/SetColumnIndex/#definition","text":"","title":"Definition"},{"location":"shards/GUI/SetColumnIndex/#input","text":"Type Description [(Int)] The table index.","title":"Input"},{"location":"shards/GUI/SetColumnIndex/#output","text":"Type Description [(Bool)] A boolean indicating whether the table column is visible.","title":"Output"},{"location":"shards/GUI/SetupColumn/","text":"GUI.SetupColumn \u00b6 ( GUI.SetupColumn :Label [( String )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" Column header Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] None Flags to enable column options. Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.SetupColumn"},{"location":"shards/GUI/SetupColumn/#guisetupcolumn","text":"( GUI.SetupColumn :Label [( String )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] )","title":"GUI.SetupColumn"},{"location":"shards/GUI/SetupColumn/#definition","text":"","title":"Definition"},{"location":"shards/GUI/SetupColumn/#parameters","text":"Name Type Default Description Label [(String)] \"\" Column header Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] None Flags to enable column options.","title":"Parameters"},{"location":"shards/GUI/SetupColumn/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/SetupColumn/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Spacing/","text":"GUI.Spacing \u00b6 ( GUI.Spacing ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Spacing"},{"location":"shards/GUI/Spacing/#guispacing","text":"( GUI.Spacing )","title":"GUI.Spacing"},{"location":"shards/GUI/Spacing/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Spacing/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/Spacing/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Style/","text":"GUI.Style \u00b6 ( GUI.Style :Style [( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Style [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x67756953 A style key to set. Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Style"},{"location":"shards/GUI/Style/#guistyle","text":"( GUI.Style :Style [( Enum )] )","title":"GUI.Style"},{"location":"shards/GUI/Style/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Style/#parameters","text":"Name Type Default Description Style [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x67756953 A style key to set.","title":"Parameters"},{"location":"shards/GUI/Style/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/Style/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/TabBar/","text":"GUI.TabBar \u00b6 ( GUI.TabBar :Name [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" A unique name for this tab bar. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the tab is visible.","title":"GUI.TabBar"},{"location":"shards/GUI/TabBar/#guitabbar","text":"( GUI.TabBar :Name [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.TabBar"},{"location":"shards/GUI/TabBar/#definition","text":"","title":"Definition"},{"location":"shards/GUI/TabBar/#parameters","text":"Name Type Default Description Name [(String)] \"\" A unique name for this tab bar. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/TabBar/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/TabBar/#output","text":"Type Description [(Bool)] A boolean indicating whether the tab is visible.","title":"Output"},{"location":"shards/GUI/TabItem/","text":"GUI.TabItem \u00b6 ( GUI.TabItem :Label [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The label of the tab Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the tab is visible.","title":"GUI.TabItem"},{"location":"shards/GUI/TabItem/#guitabitem","text":"( GUI.TabItem :Label [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.TabItem"},{"location":"shards/GUI/TabItem/#definition","text":"","title":"Definition"},{"location":"shards/GUI/TabItem/#parameters","text":"Name Type Default Description Label [(String)] \"\" The label of the tab Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/TabItem/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/TabItem/#output","text":"Type Description [(Bool)] A boolean indicating whether the tab is visible.","title":"Output"},{"location":"shards/GUI/Table/","text":"GUI.Table \u00b6 ( GUI.Table :Name [( String )] :Columns [( Int )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" A unique name for this table. Columns [(Int)] 0 The number of columns. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] None Flags to enable table options. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the table is visible.","title":"GUI.Table"},{"location":"shards/GUI/Table/#guitable","text":"( GUI.Table :Name [( String )] :Columns [( Int )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] )","title":"GUI.Table"},{"location":"shards/GUI/Table/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Table/#parameters","text":"Name Type Default Description Name [(String)] \"\" A unique name for this table. Columns [(Int)] 0 The number of columns. Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] None Flags to enable table options.","title":"Parameters"},{"location":"shards/GUI/Table/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/Table/#output","text":"Type Description [(Bool)] A boolean indicating whether the table is visible.","title":"Output"},{"location":"shards/GUI/Text/","text":"GUI.Text \u00b6 ( GUI.Text :Label [( String ) ( None )] :Color [( Color ) ( None )] :Format [( String ) ( None )] :Wrap [( Bool )] :Bullet [( Bool )] ) Definition \u00b6 Displays the input string as GUI text. Parameters \u00b6 Name Type Default Description Label [(String) (None)] None Optional label for the displayed string. Prints to the screen. Color [(Color) (None)] None Optional color of the displayed text. Default is white. Format [(String) (None)] None Optional string containing a placeholder {} for the input string text. The output is a composite string to display. Wrap [(Bool)] false Either wraps the text into the next line (if set to true ) or truncates it (if set to false ) when the text doesn't fit horizontally. Bullet [(Bool)] false Prints the text as a bullet-point (i.e. displays a small circle before the text), if set to true . Input \u00b6 Type Description [(Any)] The text/ string to display. Output \u00b6 Type Description [(Any)] The output of this shard will be its input. Details \u00b6 The :Label parameter is useful for conveying more information to the user about a displayed text string. For example, you may want to give labels to input fields of a UI form. This parameter takes the intended label-name as a string value argument and prints this label to the right of the displayed text string. The :Color parameter can be used to control the color of the displayed text. The argument to this parameter is the function color which represents the required color in terms of its RGBA values. If this parameter is not used, the default text color is white on a black GUI background. The :Format parameter is useful when you need to display the input string as part of a larger text string. The argument to this parameter is the larger text string which should contain a placeholder i.e. {} where you want the input string to display. This parameter then replaces the {} with the input string and returns the composite string as output to display. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( defloop main-wire ( GFX.MainWindow :Title \"Code Output\" :Width 480 :Height 360 :Contents ( -> ( GUI.Window :Title \"canvas\" :Width 1.0 :Height 1.0 :Pos ( int2 0 0 ) :Flags [ GuiWindowFlags.NoTitleBar GuiWindowFlags.NoResize GuiWindowFlags.NoMove GuiWindowFlags.NoCollapse ] :Contents ;; Display a text string and its label ( -> \"Display text.\" ( GUI.Text :Label \"<Display text's label>\" ) ;; Set text color to yellow \"Yellow colored text.\" ( GUI.Text :Color ( color 255 255 0 255 )) ;; Embed the input string within an existing string using placeholder {} \"*substitute text*\" ( GUI.Text :Format \"This is the {} that was passed as input.\" ) ;; Truncate the text if it doesn't fit horizontally \"Wrap is false by default hence the sentence will truncate once it reaches the end of the available space for this line.\" ( GUI.Text ) ;; Wrap the text if it doesn't fit horizontally \"Wrap is set to true hence sentence will wrap around to continue in the next line once it reaches the end of the available space for this line.\" ( GUI.Text :Wrap true ) ;; Display text as bullet-point \"Bullet-point style text\" ( GUI.Text :Bullet true )))))) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) [info] [2022-08-15 10:09:28.623] [T-4008] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"GUI.Text"},{"location":"shards/GUI/Text/#guitext","text":"( GUI.Text :Label [( String ) ( None )] :Color [( Color ) ( None )] :Format [( String ) ( None )] :Wrap [( Bool )] :Bullet [( Bool )] )","title":"GUI.Text"},{"location":"shards/GUI/Text/#definition","text":"Displays the input string as GUI text.","title":"Definition"},{"location":"shards/GUI/Text/#parameters","text":"Name Type Default Description Label [(String) (None)] None Optional label for the displayed string. Prints to the screen. Color [(Color) (None)] None Optional color of the displayed text. Default is white. Format [(String) (None)] None Optional string containing a placeholder {} for the input string text. The output is a composite string to display. Wrap [(Bool)] false Either wraps the text into the next line (if set to true ) or truncates it (if set to false ) when the text doesn't fit horizontally. Bullet [(Bool)] false Prints the text as a bullet-point (i.e. displays a small circle before the text), if set to true .","title":"Parameters"},{"location":"shards/GUI/Text/#input","text":"Type Description [(Any)] The text/ string to display.","title":"Input"},{"location":"shards/GUI/Text/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Text/#details","text":"The :Label parameter is useful for conveying more information to the user about a displayed text string. For example, you may want to give labels to input fields of a UI form. This parameter takes the intended label-name as a string value argument and prints this label to the right of the displayed text string. The :Color parameter can be used to control the color of the displayed text. The argument to this parameter is the function color which represents the required color in terms of its RGBA values. If this parameter is not used, the default text color is white on a black GUI background. The :Format parameter is useful when you need to display the input string as part of a larger text string. The argument to this parameter is the larger text string which should contain a placeholder i.e. {} where you want the input string to display. This parameter then replaces the {} with the input string and returns the composite string as output to display.","title":"Details"},{"location":"shards/GUI/Text/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( defloop main-wire ( GFX.MainWindow :Title \"Code Output\" :Width 480 :Height 360 :Contents ( -> ( GUI.Window :Title \"canvas\" :Width 1.0 :Height 1.0 :Pos ( int2 0 0 ) :Flags [ GuiWindowFlags.NoTitleBar GuiWindowFlags.NoResize GuiWindowFlags.NoMove GuiWindowFlags.NoCollapse ] :Contents ;; Display a text string and its label ( -> \"Display text.\" ( GUI.Text :Label \"<Display text's label>\" ) ;; Set text color to yellow \"Yellow colored text.\" ( GUI.Text :Color ( color 255 255 0 255 )) ;; Embed the input string within an existing string using placeholder {} \"*substitute text*\" ( GUI.Text :Format \"This is the {} that was passed as input.\" ) ;; Truncate the text if it doesn't fit horizontally \"Wrap is false by default hence the sentence will truncate once it reaches the end of the available space for this line.\" ( GUI.Text ) ;; Wrap the text if it doesn't fit horizontally \"Wrap is set to true hence sentence will wrap around to continue in the next line once it reaches the end of the available space for this line.\" ( GUI.Text :Wrap true ) ;; Display text as bullet-point \"Bullet-point style text\" ( GUI.Text :Bullet true )))))) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) [info] [2022-08-15 10:09:28.623] [T-4008] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"Examples"},{"location":"shards/GUI/TextInput/","text":"GUI.TextInput \u00b6 ( GUI.TextInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Hint [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Hint [(String)] \"\" A hint text displayed when the control is empty. Input \u00b6 Type Description [(None)] The input value is ignored. Output \u00b6 Type Description [(String)] The string that was input.","title":"GUI.TextInput"},{"location":"shards/GUI/TextInput/#guitextinput","text":"( GUI.TextInput :Label [( String ) ( None )] :Variable [( ContextVar [( Any )]) ( None )] :Hint [( String )] )","title":"GUI.TextInput"},{"location":"shards/GUI/TextInput/#definition","text":"","title":"Definition"},{"location":"shards/GUI/TextInput/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(ContextVar [(Any)]) (None)] None The variable that holds the input value. Hint [(String)] \"\" A hint text displayed when the control is empty.","title":"Parameters"},{"location":"shards/GUI/TextInput/#input","text":"Type Description [(None)] The input value is ignored.","title":"Input"},{"location":"shards/GUI/TextInput/#output","text":"Type Description [(String)] The string that was input.","title":"Output"},{"location":"shards/GUI/Tooltip/","text":"GUI.Tooltip \u00b6 ( GUI.Tooltip :Contents [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Tooltip"},{"location":"shards/GUI/Tooltip/#guitooltip","text":"( GUI.Tooltip :Contents [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"GUI.Tooltip"},{"location":"shards/GUI/Tooltip/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Tooltip/#parameters","text":"Name Type Default Description Contents [(Shard) (Seq [(Shard)]) (None)] None The inner contents shards.","title":"Parameters"},{"location":"shards/GUI/Tooltip/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/Tooltip/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/TreeNode/","text":"GUI.TreeNode \u00b6 ( GUI.TreeNode :Label [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :StartOpen [( Bool )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Label [(String)] \"\" The label of this node. Contents [(Shard) (Seq [(Shard)]) (None)] None The contents of this node. StartOpen [(Bool)] false If this node should start in the open state. Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] None Flags to enable tree node options. Input \u00b6 Type Description [(Any)] The value will be passed to the Contents shards. Output \u00b6 Type Description [(Bool)] A boolean indicating whether the tree node is open.","title":"GUI.TreeNode"},{"location":"shards/GUI/TreeNode/#guitreenode","text":"( GUI.TreeNode :Label [( String )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :StartOpen [( Bool )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] )","title":"GUI.TreeNode"},{"location":"shards/GUI/TreeNode/#definition","text":"","title":"Definition"},{"location":"shards/GUI/TreeNode/#parameters","text":"Name Type Default Description Label [(String)] \"\" The label of this node. Contents [(Shard) (Seq [(Shard)]) (None)] None The contents of this node. StartOpen [(Bool)] false If this node should start in the open state. Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] None Flags to enable tree node options.","title":"Parameters"},{"location":"shards/GUI/TreeNode/#input","text":"Type Description [(Any)] The value will be passed to the Contents shards.","title":"Input"},{"location":"shards/GUI/TreeNode/#output","text":"Type Description [(Bool)] A boolean indicating whether the tree node is open.","title":"Output"},{"location":"shards/GUI/Unindent/","text":"GUI.Unindent \u00b6 ( GUI.Unindent ) Definition \u00b6 Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"GUI.Unindent"},{"location":"shards/GUI/Unindent/#guiunindent","text":"( GUI.Unindent )","title":"GUI.Unindent"},{"location":"shards/GUI/Unindent/#definition","text":"","title":"Definition"},{"location":"shards/GUI/Unindent/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/GUI/Unindent/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Window/","text":"GUI.Window \u00b6 ( GUI.Window :Title [( String )] :Pos [( Int2 ) ( Float2 ) ( None )] :Width [( Int ) ( Float ) ( None )] :Height [( Int ) ( Float ) ( None )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] :OnClose [( ContextVar [( Bool )])] ) Definition \u00b6 Renders a GUI window within the main container window GFX.MainWindow . Parameters \u00b6 Name Type Default Description Title [(String)] \"\" The title to be displayed on the title-bar of the rendered window. Pos [(Int2) (Float2) (None)] None The (x,y) position of the rendered window as pixels (type Int2) or as a fraction of container's position (type Float2). Width [(Int) (Float) (None)] None The width of the rendered window as pixels (type Int) or as a fraction of container's width (type Float). Height [(Int) (Float) (None)] None The height of the rendered window as pixels (type Int) or as a fraction of container's height (type Float). Contents [(Shard) (Seq [(Shard)]) (None)] None Code to generate and control the UI elements that will be displayed in the rendered window. Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] Enum: 38 vendor: 0x66726167 type: 0x67756957 Flags to control the rendered window attributes like menu-bar, title-bar, resize, move, collapse etc. Defaults are show and allow. OnClose [(ContextVar [(Bool)])] true Flag that shows a close [x] button on the rendered window based on an input boolean variable (show if boolean true ). Rendered window is hidden and boolean set to false if the close button is clicked. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the rendered window. Output \u00b6 Type Description [(Any)] The output of this shard will be its input. Details \u00b6 A GUI.Window is a graphical user-interface window that can be used to display contents to, as well as to recieve inputs from, the user. Multiple GUI.Window s can be rendered within the GFX.MainWindow container. :Title Text \u00b6 The :Title parameter value displays as text on the title-bar of the rendered window and hence can identify the window. However, for this to work, the title-bar display must not be suppressed (i.e. the flag GuiWindowFlags.NoTitleBar should not be passed to the :Flag parameter). :Pos , :Height and :Width \u00b6 The :Pos parameter defines the 2D coordinates of the top-left corner of the rendered window, whereas the :Width and :Height parameters define the rendered window's dimensions. The area available to the rendered window is bounded by the container window. Hence if w and h are the width and height of the container window (in pixels), the rendered window should lie within these four vertices: (0 0) , (0 h) , (w 0) , and (h w) . If any part of the rendered window is outside this area, that part will not be visible. Integer inputs to these parameters are interpreted directly as pixel value coordinates (for position), or as pixel value of dimensions (for height and width), of the rendered window. Float inputs, however, must lie between values 0 and 1 (inclusive) and are multiplied with the container window's height and width pixel values to get the rendered window's height. width and position. For example, let a container window have a height of 800 pixels and a width of 200 pixels. :Pos \u00b6 Now :Pos (int2 200 100) and :Pos (float2 0.25 0.5) will be equivalent as they both evaluate to (10 10) for the pixel coordinates of the top left corner of the rendered window (0.25 * 800 = 200; 0.5 * 200 = 100). Also, :Pos (int2 400 100) and :Pos (float2 0.5 0.5) , will both compute the rendered window's top left corner to be in the center of the container window i.e. (400 100) (0.5 * 800 = 400, 0.5 * 200 = 100). :Height and :Width \u00b6 Similarly :Height (int 160) and :Height (float 0.2) will compute a height of 160 pixels for the rendered window (0.2 * 800 = 160). In the same way :Width (int 150) and :Width (float 0.75) will both compute the width of the rendered window as 150 pixels (0.75 * 200 = 150). Displayable :Contents \u00b6 The input to the :Contents parameter is code (in form of shards) that generates and controls UI elements (like text string, buttons, checkboxes etc.) that will get displayed in the rendered window. So while other parameters mostly define the attributes of the rendered window, :Contents controls the core user interaction. Attribute :Flags \u00b6 The :Flags parameter defines some attributes and behavior of the rendered window. Passing a flag indicator to the :Flags parameter will enable that behavior or attribute, whereas not passing it will result in the default behavior. This is a list of valid flag indicators and the behaviors they control. GuiWindowFlags.Menubar : show menu-bar (default is hide) GuiWindowFlags.NoTitleBar : hide title-bar (default is show) GuiWindowFlags.NoResize : prevent window resizing (default is allow) GuiWindowFlags.NoMove : prevent window movement (default is allow) GuiWindowFlags.NoCollapse : prevent window collapse (default is allow) :OnClose Flag \u00b6 The :OnClose parameter is a nifty way to control the visibility and state of the close [x] button (displayed on the title-bar of the rendered window). This parameter requires a boolean variable as input. The close [x] button is displayed If the variable is true and hidden if the variable is false . If this close [x] is clicked then window is closed and the state of the :OnClose parameter's variable is changed from true to false . Hence this variable acts as a state indicator for the rendered window (i.e. whether a given window is currently open or closed). Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ;; usage of parameters :Title, :Width, :Height, :Position, and :Contents ( defloop main-wire ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window :Title \"canvas1\" ;; displays title-text on title-bar of window :Width ( int 400 ) ;; rendered window width in pixels ;; :Width (float 0.25) ;; rendered window width is 1/4th of container window width :Height ( int 300 ) ;; rendered window height in pixels ;; :Height (float 0.30) ;; rendered window width is 1/3rd of container window width :Pos ( int2 10 10 ) ;; pixel position of top-left corner of window ;; :Pos (float2 0.5 0.5) ;; top-left corner of window placed in the center of container window :Contents ;; shard code to create and display entitites inside window ( -> ( -> \"A window\" ( GUI.Text )) ( GUI.Checkbox \"Demo Window\" ) ( GUI.Button \"Button\" ))))) ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:29.758] [T-5812] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;; usage of parameter :Flags ( defloop main-wire ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window :Title \"canvas1\" :Width 400 :Height 300 :Pos ( int2 10 10 ) :Flags [ ;; comment-out/ enable following flags to see effect on window GuiWindowFlags.MenuBar ;; displays a menu-bar below the title-bar GuiWindowFlags.NoTitleBar ;; supresses the title-bar GuiWindowFlags.NoResize ;; prevents resizing of the window GuiWindowFlags.NoMove ;; prevents moving the window around GuiWindowFlags.NoCollapse ;; prevents collapsing the window ] :Contents ( -> \"A window\" ( GUI.Text ))))) ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:30.899] [T-5656] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; usage of parameter :OnClose ( defloop main-wire ( Setup true >= .onCloseFlag ) ;; toggle flag to see effect on x button .onCloseFlag ( Log \".onCloseFlag before\" ) ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window :Title \"canvas1\" :Width 400 :Height 300 :Pos ( int2 10 10 ) :OnClose .onCloseFlag ;; :Flags [ ;; GuiWindowFlags.NoTitleBar ] ;; 'close' button displays on the title-bar :Contents ( -> \"A window\" ( GUI.Text ))))) .onCloseFlag ( Log \".onCloseFlag after\" ) ;; => 'false' on closing window ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:31.021] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag before: true [info] [2022-08-15 10:09:31.042] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag after: true [info] [2022-08-15 10:09:32.022] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag before: true [info] [2022-08-15 10:09:32.026] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag after: true [info] [2022-08-15 10:09:32.037] [T-7128] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; multiple GUI.Window rendering within one GFX.MainWindow container ( defloop main-wire ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window ;; the 1st window :Title \"canvas1\" :Width 200 :Height 400 :Pos ( Float2 0.01 0.2 ) :Contents ( -> \"A window\" ( GUI.Text ))) ( GUI.Window ;; the 2nd window :Title \"canvas2\" :Width ( Float 0.25 ) :Height ( Float 0.75 ) :Pos ( int2 300 10 ) :Contents ( -> \"Another window\" ( GUI.Text ))) ) ) ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:33.186] [T-4392] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"GUI.Window"},{"location":"shards/GUI/Window/#guiwindow","text":"( GUI.Window :Title [( String )] :Pos [( Int2 ) ( Float2 ) ( None )] :Width [( Int ) ( Float ) ( None )] :Height [( Int ) ( Float ) ( None )] :Contents [( Shard ) ( Seq [( Shard )]) ( None )] :Flags [( Enum ) ( ContextVar [( Enum )]) ( Seq [( Enum )]) ( ContextVar [( Seq [( Enum )])]) ( None )] :OnClose [( ContextVar [( Bool )])] )","title":"GUI.Window"},{"location":"shards/GUI/Window/#definition","text":"Renders a GUI window within the main container window GFX.MainWindow .","title":"Definition"},{"location":"shards/GUI/Window/#parameters","text":"Name Type Default Description Title [(String)] \"\" The title to be displayed on the title-bar of the rendered window. Pos [(Int2) (Float2) (None)] None The (x,y) position of the rendered window as pixels (type Int2) or as a fraction of container's position (type Float2). Width [(Int) (Float) (None)] None The width of the rendered window as pixels (type Int) or as a fraction of container's width (type Float). Height [(Int) (Float) (None)] None The height of the rendered window as pixels (type Int) or as a fraction of container's height (type Float). Contents [(Shard) (Seq [(Shard)]) (None)] None Code to generate and control the UI elements that will be displayed in the rendered window. Flags [(Enum) (ContextVar [(Enum)]) (Seq [(Enum)]) (ContextVar [(Seq [(Enum)])]) (None)] Enum: 38 vendor: 0x66726167 type: 0x67756957 Flags to control the rendered window attributes like menu-bar, title-bar, resize, move, collapse etc. Defaults are show and allow. OnClose [(ContextVar [(Bool)])] true Flag that shows a close [x] button on the rendered window based on an input boolean variable (show if boolean true ). Rendered window is hidden and boolean set to false if the close button is clicked.","title":"Parameters"},{"location":"shards/GUI/Window/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the rendered window.","title":"Input"},{"location":"shards/GUI/Window/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/GUI/Window/#details","text":"A GUI.Window is a graphical user-interface window that can be used to display contents to, as well as to recieve inputs from, the user. Multiple GUI.Window s can be rendered within the GFX.MainWindow container.","title":"Details"},{"location":"shards/GUI/Window/#title-text","text":"The :Title parameter value displays as text on the title-bar of the rendered window and hence can identify the window. However, for this to work, the title-bar display must not be suppressed (i.e. the flag GuiWindowFlags.NoTitleBar should not be passed to the :Flag parameter).","title":":Title Text"},{"location":"shards/GUI/Window/#pos-height-and-width","text":"The :Pos parameter defines the 2D coordinates of the top-left corner of the rendered window, whereas the :Width and :Height parameters define the rendered window's dimensions. The area available to the rendered window is bounded by the container window. Hence if w and h are the width and height of the container window (in pixels), the rendered window should lie within these four vertices: (0 0) , (0 h) , (w 0) , and (h w) . If any part of the rendered window is outside this area, that part will not be visible. Integer inputs to these parameters are interpreted directly as pixel value coordinates (for position), or as pixel value of dimensions (for height and width), of the rendered window. Float inputs, however, must lie between values 0 and 1 (inclusive) and are multiplied with the container window's height and width pixel values to get the rendered window's height. width and position. For example, let a container window have a height of 800 pixels and a width of 200 pixels.","title":":Pos, :Height and :Width"},{"location":"shards/GUI/Window/#pos","text":"Now :Pos (int2 200 100) and :Pos (float2 0.25 0.5) will be equivalent as they both evaluate to (10 10) for the pixel coordinates of the top left corner of the rendered window (0.25 * 800 = 200; 0.5 * 200 = 100). Also, :Pos (int2 400 100) and :Pos (float2 0.5 0.5) , will both compute the rendered window's top left corner to be in the center of the container window i.e. (400 100) (0.5 * 800 = 400, 0.5 * 200 = 100).","title":":Pos"},{"location":"shards/GUI/Window/#height-and-width","text":"Similarly :Height (int 160) and :Height (float 0.2) will compute a height of 160 pixels for the rendered window (0.2 * 800 = 160). In the same way :Width (int 150) and :Width (float 0.75) will both compute the width of the rendered window as 150 pixels (0.75 * 200 = 150).","title":":Height and :Width"},{"location":"shards/GUI/Window/#displayable-contents","text":"The input to the :Contents parameter is code (in form of shards) that generates and controls UI elements (like text string, buttons, checkboxes etc.) that will get displayed in the rendered window. So while other parameters mostly define the attributes of the rendered window, :Contents controls the core user interaction.","title":"Displayable :Contents"},{"location":"shards/GUI/Window/#attribute-flags","text":"The :Flags parameter defines some attributes and behavior of the rendered window. Passing a flag indicator to the :Flags parameter will enable that behavior or attribute, whereas not passing it will result in the default behavior. This is a list of valid flag indicators and the behaviors they control. GuiWindowFlags.Menubar : show menu-bar (default is hide) GuiWindowFlags.NoTitleBar : hide title-bar (default is show) GuiWindowFlags.NoResize : prevent window resizing (default is allow) GuiWindowFlags.NoMove : prevent window movement (default is allow) GuiWindowFlags.NoCollapse : prevent window collapse (default is allow)","title":"Attribute :Flags"},{"location":"shards/GUI/Window/#onclose-flag","text":"The :OnClose parameter is a nifty way to control the visibility and state of the close [x] button (displayed on the title-bar of the rendered window). This parameter requires a boolean variable as input. The close [x] button is displayed If the variable is true and hidden if the variable is false . If this close [x] is clicked then window is closed and the state of the :OnClose parameter's variable is changed from true to false . Hence this variable acts as a state indicator for the rendered window (i.e. whether a given window is currently open or closed).","title":":OnClose Flag"},{"location":"shards/GUI/Window/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ;; usage of parameters :Title, :Width, :Height, :Position, and :Contents ( defloop main-wire ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window :Title \"canvas1\" ;; displays title-text on title-bar of window :Width ( int 400 ) ;; rendered window width in pixels ;; :Width (float 0.25) ;; rendered window width is 1/4th of container window width :Height ( int 300 ) ;; rendered window height in pixels ;; :Height (float 0.30) ;; rendered window width is 1/3rd of container window width :Pos ( int2 10 10 ) ;; pixel position of top-left corner of window ;; :Pos (float2 0.5 0.5) ;; top-left corner of window placed in the center of container window :Contents ;; shard code to create and display entitites inside window ( -> ( -> \"A window\" ( GUI.Text )) ( GUI.Checkbox \"Demo Window\" ) ( GUI.Button \"Button\" ))))) ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:29.758] [T-5812] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;; usage of parameter :Flags ( defloop main-wire ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window :Title \"canvas1\" :Width 400 :Height 300 :Pos ( int2 10 10 ) :Flags [ ;; comment-out/ enable following flags to see effect on window GuiWindowFlags.MenuBar ;; displays a menu-bar below the title-bar GuiWindowFlags.NoTitleBar ;; supresses the title-bar GuiWindowFlags.NoResize ;; prevents resizing of the window GuiWindowFlags.NoMove ;; prevents moving the window around GuiWindowFlags.NoCollapse ;; prevents collapsing the window ] :Contents ( -> \"A window\" ( GUI.Text ))))) ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:30.899] [T-5656] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; usage of parameter :OnClose ( defloop main-wire ( Setup true >= .onCloseFlag ) ;; toggle flag to see effect on x button .onCloseFlag ( Log \".onCloseFlag before\" ) ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window :Title \"canvas1\" :Width 400 :Height 300 :Pos ( int2 10 10 ) :OnClose .onCloseFlag ;; :Flags [ ;; GuiWindowFlags.NoTitleBar ] ;; 'close' button displays on the title-bar :Contents ( -> \"A window\" ( GUI.Text ))))) .onCloseFlag ( Log \".onCloseFlag after\" ) ;; => 'false' on closing window ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:31.021] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag before: true [info] [2022-08-15 10:09:31.042] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag after: true [info] [2022-08-15 10:09:32.022] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag before: true [info] [2022-08-15 10:09:32.026] [T-7128] [logging.cpp::53] [main-wire] .onCloseFlag after: true [info] [2022-08-15 10:09:32.037] [T-7128] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; multiple GUI.Window rendering within one GFX.MainWindow container ( defloop main-wire ( GFX.MainWindow :Title \"Main Window\" :Width 800 :Height 600 :Contents ( -> ( GUI.Window ;; the 1st window :Title \"canvas1\" :Width 200 :Height 400 :Pos ( Float2 0.01 0.2 ) :Contents ( -> \"A window\" ( GUI.Text ))) ( GUI.Window ;; the 2nd window :Title \"canvas2\" :Width ( Float 0.25 ) :Height ( Float 0.75 ) :Pos ( int2 300 10 ) :Contents ( -> \"Another window\" ( GUI.Text ))) ) ) ) ( defmesh root ) ( schedule root main-wire ) ( run root 1 2 ) ;; increase value of `run` args to display window for longer [info] [2022-08-15 10:09:33.186] [T-4392] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"Examples"},{"location":"shards/General/All/","text":"All \u00b6 ( All :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"All"},{"location":"shards/General/All/#all","text":"( All :Value [( Any )] )","title":"All"},{"location":"shards/General/All/#definition","text":"","title":"Definition"},{"location":"shards/General/All/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/All/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/All/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AllLess/","text":"AllLess \u00b6 ( AllLess :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AllLess"},{"location":"shards/General/AllLess/#allless","text":"( AllLess :Value [( Any )] )","title":"AllLess"},{"location":"shards/General/AllLess/#definition","text":"","title":"Definition"},{"location":"shards/General/AllLess/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AllLess/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AllLess/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AllLessEqual/","text":"AllLessEqual \u00b6 ( AllLessEqual :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AllLessEqual"},{"location":"shards/General/AllLessEqual/#alllessequal","text":"( AllLessEqual :Value [( Any )] )","title":"AllLessEqual"},{"location":"shards/General/AllLessEqual/#definition","text":"","title":"Definition"},{"location":"shards/General/AllLessEqual/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AllLessEqual/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AllLessEqual/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AllMore/","text":"AllMore \u00b6 ( AllMore :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AllMore"},{"location":"shards/General/AllMore/#allmore","text":"( AllMore :Value [( Any )] )","title":"AllMore"},{"location":"shards/General/AllMore/#definition","text":"","title":"Definition"},{"location":"shards/General/AllMore/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AllMore/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AllMore/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AllMoreEqual/","text":"AllMoreEqual \u00b6 ( AllMoreEqual :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AllMoreEqual"},{"location":"shards/General/AllMoreEqual/#allmoreequal","text":"( AllMoreEqual :Value [( Any )] )","title":"AllMoreEqual"},{"location":"shards/General/AllMoreEqual/#definition","text":"","title":"Definition"},{"location":"shards/General/AllMoreEqual/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AllMoreEqual/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AllMoreEqual/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AllNot/","text":"AllNot \u00b6 ( AllNot :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AllNot"},{"location":"shards/General/AllNot/#allnot","text":"( AllNot :Value [( Any )] )","title":"AllNot"},{"location":"shards/General/AllNot/#definition","text":"","title":"Definition"},{"location":"shards/General/AllNot/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AllNot/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AllNot/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/And/","text":"And \u00b6 ( And ) Definition \u00b6 Computes the logical AND between the input of this shard and the output of the next shard. Input \u00b6 Type Description [(Bool)] The first operand to be evaluated. Output \u00b6 Type Description [(Bool)] The output of this shard will be its input. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 false ( And ) false ( Assert.Is false :Abort true ) false ( And ) true ( Assert.Is false :Abort true ) true ( And ) false ( Assert.Is false :Abort true ) true ( And ) true ( Assert.Is true :Abort true )","title":"And"},{"location":"shards/General/And/#and","text":"( And )","title":"And"},{"location":"shards/General/And/#definition","text":"Computes the logical AND between the input of this shard and the output of the next shard.","title":"Definition"},{"location":"shards/General/And/#input","text":"Type Description [(Bool)] The first operand to be evaluated.","title":"Input"},{"location":"shards/General/And/#output","text":"Type Description [(Bool)] The output of this shard will be its input.","title":"Output"},{"location":"shards/General/And/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 false ( And ) false ( Assert.Is false :Abort true ) false ( And ) true ( Assert.Is false :Abort true ) true ( And ) false ( Assert.Is false :Abort true ) true ( And ) true ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/Any/","text":"Any \u00b6 ( Any :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"Any"},{"location":"shards/General/Any/#any","text":"( Any :Value [( Any )] )","title":"Any"},{"location":"shards/General/Any/#definition","text":"","title":"Definition"},{"location":"shards/General/Any/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/Any/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Any/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AnyLess/","text":"AnyLess \u00b6 ( AnyLess :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AnyLess"},{"location":"shards/General/AnyLess/#anyless","text":"( AnyLess :Value [( Any )] )","title":"AnyLess"},{"location":"shards/General/AnyLess/#definition","text":"","title":"Definition"},{"location":"shards/General/AnyLess/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AnyLess/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AnyLess/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AnyLessEqual/","text":"AnyLessEqual \u00b6 ( AnyLessEqual :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AnyLessEqual"},{"location":"shards/General/AnyLessEqual/#anylessequal","text":"( AnyLessEqual :Value [( Any )] )","title":"AnyLessEqual"},{"location":"shards/General/AnyLessEqual/#definition","text":"","title":"Definition"},{"location":"shards/General/AnyLessEqual/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AnyLessEqual/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AnyLessEqual/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AnyMore/","text":"AnyMore \u00b6 ( AnyMore :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AnyMore"},{"location":"shards/General/AnyMore/#anymore","text":"( AnyMore :Value [( Any )] )","title":"AnyMore"},{"location":"shards/General/AnyMore/#definition","text":"","title":"Definition"},{"location":"shards/General/AnyMore/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AnyMore/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AnyMore/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AnyMoreEqual/","text":"AnyMoreEqual \u00b6 ( AnyMoreEqual :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AnyMoreEqual"},{"location":"shards/General/AnyMoreEqual/#anymoreequal","text":"( AnyMoreEqual :Value [( Any )] )","title":"AnyMoreEqual"},{"location":"shards/General/AnyMoreEqual/#definition","text":"","title":"Definition"},{"location":"shards/General/AnyMoreEqual/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AnyMoreEqual/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AnyMoreEqual/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AnyNot/","text":"AnyNot \u00b6 ( AnyNot :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"AnyNot"},{"location":"shards/General/AnyNot/#anynot","text":"( AnyNot :Value [( Any )] )","title":"AnyNot"},{"location":"shards/General/AnyNot/#definition","text":"","title":"Definition"},{"location":"shards/General/AnyNot/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/AnyNot/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/AnyNot/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/AppendTo/","text":"AppendTo \u00b6 ( AppendTo :Collection [( ContextVar [( Seq [( Any )])]) ( ContextVar [( String )]) ( ContextVar [( Bytes )])] ) Definition \u00b6 Appends the input to the context variable passed to :Collection . Parameters \u00b6 Name Type Default Description Collection [(ContextVar [(Seq [(Any)])]) (ContextVar [(String)]) (ContextVar [(Bytes)])] None The collection to add the input to. Input \u00b6 Type Description [(Any)] The value to append to the collection. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 AppendTo appends (i.e., adds to the end) its input to the variable it receives in its :Collection parameter. This shard works on string and sequence variables. The input to this shard is also passed through as its output. See also Drop Pop Push Set Update Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 ;; append element to sequence [ 1 2 3 ] >= .seq 4 ( AppendTo .seq ) ;; appends element to sequence .seq ( Log ) ;; updated sequence => [1, 2, 3, 4] ;; append character to string \"Hell\" >= .str \"o\" ( AppendTo .str ) ;; appends character to string .str ( Log ) ;; updated string => Hello [info] [2022-08-15 10:09:08.360] [T-2140] [logging.cpp::55] [shards/General/AppendTo/AppendTo.edn] [1, 2, 3, 4] [info] [2022-08-15 10:09:08.361] [T-2140] [logging.cpp::55] [shards/General/AppendTo/AppendTo.edn] Hello","title":"AppendTo"},{"location":"shards/General/AppendTo/#appendto","text":"( AppendTo :Collection [( ContextVar [( Seq [( Any )])]) ( ContextVar [( String )]) ( ContextVar [( Bytes )])] )","title":"AppendTo"},{"location":"shards/General/AppendTo/#definition","text":"Appends the input to the context variable passed to :Collection .","title":"Definition"},{"location":"shards/General/AppendTo/#parameters","text":"Name Type Default Description Collection [(ContextVar [(Seq [(Any)])]) (ContextVar [(String)]) (ContextVar [(Bytes)])] None The collection to add the input to.","title":"Parameters"},{"location":"shards/General/AppendTo/#input","text":"Type Description [(Any)] The value to append to the collection.","title":"Input"},{"location":"shards/General/AppendTo/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/AppendTo/#details","text":"AppendTo appends (i.e., adds to the end) its input to the variable it receives in its :Collection parameter. This shard works on string and sequence variables. The input to this shard is also passed through as its output. See also Drop Pop Push Set Update","title":"Details"},{"location":"shards/General/AppendTo/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 ;; append element to sequence [ 1 2 3 ] >= .seq 4 ( AppendTo .seq ) ;; appends element to sequence .seq ( Log ) ;; updated sequence => [1, 2, 3, 4] ;; append character to string \"Hell\" >= .str \"o\" ( AppendTo .str ) ;; appends character to string .str ( Log ) ;; updated string => Hello [info] [2022-08-15 10:09:08.360] [T-2140] [logging.cpp::55] [shards/General/AppendTo/AppendTo.edn] [1, 2, 3, 4] [info] [2022-08-15 10:09:08.361] [T-2140] [logging.cpp::55] [shards/General/AppendTo/AppendTo.edn] Hello","title":"Examples"},{"location":"shards/General/Assoc/","text":"Assoc \u00b6 ( Assoc :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Updates a sequence (array) or a table (associative array/ dictionary) on the basis of an input sequence. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the sequence or table to be updated. Key [(String) (ContextVar [(String)]) (None)] None Table key for the value that is to be updated. Parameter applicable if target is table. Global [(Bool)] false If the variable is or should be available to all the wires in the same mesh. The default value (false) makes the variable local to the wire. Input \u00b6 Type Description [(Seq [(Any)])] Input sequence that defines which element in the target sequence or table needs to be updated and with what value. Should have even number of elements. Output \u00b6 Type Description [(Seq [(Any)])] Modified array or table. Has the same type as the array or table on which Assoc was applied. Details \u00b6 This shard can be used to update specific member elements within a sequence or a table with new values. The input sequence identifies which elements are to be updated and their new/ updated values. To achieve this, the member elements of this input sequence are parsed in pairs. The 1st element of each pair gives the index of the target element to update, and the 2nd element of that pair gives the new value for the target element. Due to this, the input sequence must always contain an even number of elements. Examples \u00b6 Code Output 1 2 3 4 5 6 ;; Update a sequence [ 10 20 ] = .sequence ( Log ) ;; prints original target sequence => [10 20] [ 0 2 1 3 ] ( Assoc .sequence ) ;; input sequence updates target sequence [index-0 ele => 2, index-1 ele => 3] .sequence ( Log ) ;; prints updated target sequence => [2 3] .sequence ( Assert.Is [ 2 3 ] true ) [info] [2022-08-15 10:09:08.417] [T-4356] [logging.cpp::55] [shards/General/Assoc/1.edn] [10, 20] [info] [2022-08-15 10:09:08.417] [T-4356] [logging.cpp::55] [shards/General/Assoc/1.edn] [2, 3] Code Output 1 2 3 4 5 6 ;; Update a global-var table (Global = true; table available to all the wires in the same mesh) { :key1 [ 10 20 ] :key2 [ 30 40 ]} ( Set .tableG :Global true ) ( Log ) ;; prints original table => {:key1 [10 20] :key2 [30 40]} [ 0 2 1 3 ] ( Assoc .tableG \"key1\" ) ;; input sequence updates value of key \"key1\" in table .tableG ( Log ) ;; prints updated table => {:key1 [2 3] :key2 [30 40]} .tableG ( Assert.Is { :key1 [ 2 3 ] :key2 [ 30 40 ]} true ) [info] [2022-08-15 10:09:08.474] [T-6644] [logging.cpp::55] [shards/General/Assoc/2.edn] {key1: [10, 20], key2: [30, 40]} [info] [2022-08-15 10:09:08.475] [T-6644] [logging.cpp::55] [shards/General/Assoc/2.edn] {key2: [30, 40], key1: [2, 3]} Code Output 1 2 3 4 5 6 ;; Update a local-variable table (:Global = false, table available to only this wire in the mesh) { :key1 [ 10 20 ] :key2 [ 30 40 ]} = .table ( Log ) ;; prints original table => {:key1 [10 20] :key2 [30 40]} [ 0 2 1 3 ] ( Assoc .table \"key2\" ) ;; input sequence updates value of key \"key2\" in table .table ( Log ) ;; prints updated table => {:key1 [10 20] :key2 [2 3]} .table ( Assert.Is { :key1 [ 10 20 ] :key2 [ 2 3 ]} true ) [info] [2022-08-15 10:09:08.532] [T-1940] [logging.cpp::55] [shards/General/Assoc/3.edn] {key1: [10, 20], key2: [30, 40]} [info] [2022-08-15 10:09:08.533] [T-1940] [logging.cpp::55] [shards/General/Assoc/3.edn] {key1: [10, 20], key2: [2, 3]}","title":"Assoc"},{"location":"shards/General/Assoc/#assoc","text":"( Assoc :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Assoc"},{"location":"shards/General/Assoc/#definition","text":"Updates a sequence (array) or a table (associative array/ dictionary) on the basis of an input sequence.","title":"Definition"},{"location":"shards/General/Assoc/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the sequence or table to be updated. Key [(String) (ContextVar [(String)]) (None)] None Table key for the value that is to be updated. Parameter applicable if target is table. Global [(Bool)] false If the variable is or should be available to all the wires in the same mesh. The default value (false) makes the variable local to the wire.","title":"Parameters"},{"location":"shards/General/Assoc/#input","text":"Type Description [(Seq [(Any)])] Input sequence that defines which element in the target sequence or table needs to be updated and with what value. Should have even number of elements.","title":"Input"},{"location":"shards/General/Assoc/#output","text":"Type Description [(Seq [(Any)])] Modified array or table. Has the same type as the array or table on which Assoc was applied.","title":"Output"},{"location":"shards/General/Assoc/#details","text":"This shard can be used to update specific member elements within a sequence or a table with new values. The input sequence identifies which elements are to be updated and their new/ updated values. To achieve this, the member elements of this input sequence are parsed in pairs. The 1st element of each pair gives the index of the target element to update, and the 2nd element of that pair gives the new value for the target element. Due to this, the input sequence must always contain an even number of elements.","title":"Details"},{"location":"shards/General/Assoc/#examples","text":"Code Output 1 2 3 4 5 6 ;; Update a sequence [ 10 20 ] = .sequence ( Log ) ;; prints original target sequence => [10 20] [ 0 2 1 3 ] ( Assoc .sequence ) ;; input sequence updates target sequence [index-0 ele => 2, index-1 ele => 3] .sequence ( Log ) ;; prints updated target sequence => [2 3] .sequence ( Assert.Is [ 2 3 ] true ) [info] [2022-08-15 10:09:08.417] [T-4356] [logging.cpp::55] [shards/General/Assoc/1.edn] [10, 20] [info] [2022-08-15 10:09:08.417] [T-4356] [logging.cpp::55] [shards/General/Assoc/1.edn] [2, 3] Code Output 1 2 3 4 5 6 ;; Update a global-var table (Global = true; table available to all the wires in the same mesh) { :key1 [ 10 20 ] :key2 [ 30 40 ]} ( Set .tableG :Global true ) ( Log ) ;; prints original table => {:key1 [10 20] :key2 [30 40]} [ 0 2 1 3 ] ( Assoc .tableG \"key1\" ) ;; input sequence updates value of key \"key1\" in table .tableG ( Log ) ;; prints updated table => {:key1 [2 3] :key2 [30 40]} .tableG ( Assert.Is { :key1 [ 2 3 ] :key2 [ 30 40 ]} true ) [info] [2022-08-15 10:09:08.474] [T-6644] [logging.cpp::55] [shards/General/Assoc/2.edn] {key1: [10, 20], key2: [30, 40]} [info] [2022-08-15 10:09:08.475] [T-6644] [logging.cpp::55] [shards/General/Assoc/2.edn] {key2: [30, 40], key1: [2, 3]} Code Output 1 2 3 4 5 6 ;; Update a local-variable table (:Global = false, table available to only this wire in the mesh) { :key1 [ 10 20 ] :key2 [ 30 40 ]} = .table ( Log ) ;; prints original table => {:key1 [10 20] :key2 [30 40]} [ 0 2 1 3 ] ( Assoc .table \"key2\" ) ;; input sequence updates value of key \"key2\" in table .table ( Log ) ;; prints updated table => {:key1 [10 20] :key2 [2 3]} .table ( Assert.Is { :key1 [ 10 20 ] :key2 [ 2 3 ]} true ) [info] [2022-08-15 10:09:08.532] [T-1940] [logging.cpp::55] [shards/General/Assoc/3.edn] {key1: [10, 20], key2: [30, 40]} [info] [2022-08-15 10:09:08.533] [T-1940] [logging.cpp::55] [shards/General/Assoc/3.edn] {key1: [10, 20], key2: [2, 3]}","title":"Examples"},{"location":"shards/General/Await/","text":"Await \u00b6 ( Await :Shards [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Executes a shard or a sequence of shards asynchronously and awaits their completion. Parameters \u00b6 Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to activate. Input \u00b6 Type Description [(Any)] Must match the input types of the first shard in the sequence. Output \u00b6 Type Description [(Any)] Will match the output types of the first shard of the sequence. Details \u00b6 (Await) runs its shards (or sequence of shards) as a separate task that is sent directly to the thread pool, while the rest of the program continues executing (via other scheduled threads). Once this (Await) task thread completes its execution the result of the execution of these inner shards is made available to the program. This is called asynchronous computation and is used to prevent resource intensive processing (like downloading a large file data from an http server) from holding up the execution of the rest of the program. Note (Await) has an alias (||) which is more convenient to use. || also removes the need to use (->) as, unlike (Await) , it doesn't require the parameter shards to be grouped together. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ;; Asynchronous execution of shards (using keyword `Await`) ;; Printing order of messages not consistent across program runs -- ;; -- as asynchronous shards might complete at different times ( defmesh mesh ) ( defloop await-wire ( Await ;:Shards ( -> ( Msg \"Message 1\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ( Msg \"Message 2\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ))) ( defloop my-wire ( Msg \"Message 3\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ) ( schedule mesh await-wire ) ( schedule mesh my-wire ) ( run mesh 1 1 ) [info] [2022-08-15 10:09:08.590] [T-7128] [logging.cpp::98] [my-wire] Message 3 [info] [2022-08-15 10:09:08.590] [T-3988] [logging.cpp::98] [await-wire] Message 1 [info] [2022-08-15 10:09:08.591] [T-3988] [logging.cpp::98] [await-wire] Message 2 [info] [2022-08-15 10:09:08.591] [T-7128] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; Asynchronous execution of shards (using alias `||`) ;; Printing order of messages not consistent across program runs -- ;; -- as asynchronous shards might complete at different times ( defmesh mesh ) ( defloop await-wire ( || ;:Shards ( Msg \"Message 1\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ( Msg \"Message 2\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) )) ( defloop my-wire ( Msg \"Message 3\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ) ( schedule mesh await-wire ) ( schedule mesh my-wire ) ( run mesh 1 1 ) [info] [2022-08-15 10:09:08.648] [T-4632] [logging.cpp::98] [my-wire] Message 3 [info] [2022-08-15 10:09:08.648] [T-6472] [logging.cpp::98] [await-wire] Message 1 [info] [2022-08-15 10:09:08.648] [T-6472] [logging.cpp::98] [await-wire] Message 2 [info] [2022-08-15 10:09:08.648] [T-4632] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"Await"},{"location":"shards/General/Await/#await","text":"( Await :Shards [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Await"},{"location":"shards/General/Await/#definition","text":"Executes a shard or a sequence of shards asynchronously and awaits their completion.","title":"Definition"},{"location":"shards/General/Await/#parameters","text":"Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to activate.","title":"Parameters"},{"location":"shards/General/Await/#input","text":"Type Description [(Any)] Must match the input types of the first shard in the sequence.","title":"Input"},{"location":"shards/General/Await/#output","text":"Type Description [(Any)] Will match the output types of the first shard of the sequence.","title":"Output"},{"location":"shards/General/Await/#details","text":"(Await) runs its shards (or sequence of shards) as a separate task that is sent directly to the thread pool, while the rest of the program continues executing (via other scheduled threads). Once this (Await) task thread completes its execution the result of the execution of these inner shards is made available to the program. This is called asynchronous computation and is used to prevent resource intensive processing (like downloading a large file data from an http server) from holding up the execution of the rest of the program. Note (Await) has an alias (||) which is more convenient to use. || also removes the need to use (->) as, unlike (Await) , it doesn't require the parameter shards to be grouped together.","title":"Details"},{"location":"shards/General/Await/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ;; Asynchronous execution of shards (using keyword `Await`) ;; Printing order of messages not consistent across program runs -- ;; -- as asynchronous shards might complete at different times ( defmesh mesh ) ( defloop await-wire ( Await ;:Shards ( -> ( Msg \"Message 1\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ( Msg \"Message 2\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ))) ( defloop my-wire ( Msg \"Message 3\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ) ( schedule mesh await-wire ) ( schedule mesh my-wire ) ( run mesh 1 1 ) [info] [2022-08-15 10:09:08.590] [T-7128] [logging.cpp::98] [my-wire] Message 3 [info] [2022-08-15 10:09:08.590] [T-3988] [logging.cpp::98] [await-wire] Message 1 [info] [2022-08-15 10:09:08.591] [T-3988] [logging.cpp::98] [await-wire] Message 2 [info] [2022-08-15 10:09:08.591] [T-7128] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; Asynchronous execution of shards (using alias `||`) ;; Printing order of messages not consistent across program runs -- ;; -- as asynchronous shards might complete at different times ( defmesh mesh ) ( defloop await-wire ( || ;:Shards ( Msg \"Message 1\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ( Msg \"Message 2\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) )) ( defloop my-wire ( Msg \"Message 3\" ) ;; messages might print in any order (1/2/3, 1/3/2, 3/2/1, etc.) ) ( schedule mesh await-wire ) ( schedule mesh my-wire ) ( run mesh 1 1 ) [info] [2022-08-15 10:09:08.648] [T-4632] [logging.cpp::98] [my-wire] Message 3 [info] [2022-08-15 10:09:08.648] [T-6472] [logging.cpp::98] [await-wire] Message 1 [info] [2022-08-15 10:09:08.648] [T-6472] [logging.cpp::98] [await-wire] Message 2 [info] [2022-08-15 10:09:08.648] [T-4632] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"Examples"},{"location":"shards/General/BigInt/","text":"BigInt \u00b6 ( BigInt ) Definition \u00b6 Input \u00b6 Type Description [(Int) (Float) (String) (Bytes)] Output \u00b6 Type Description [(Bytes)] Big integer represented as bytes.","title":"BigInt"},{"location":"shards/General/BigInt/#bigint","text":"( BigInt )","title":"BigInt"},{"location":"shards/General/BigInt/#definition","text":"","title":"Definition"},{"location":"shards/General/BigInt/#input","text":"Type Description [(Int) (Float) (String) (Bytes)]","title":"Input"},{"location":"shards/General/BigInt/#output","text":"Type Description [(Bytes)] Big integer represented as bytes.","title":"Output"},{"location":"shards/General/BitSwap32/","text":"BitSwap32 \u00b6 ( BitSwap32 ) Definition \u00b6 Input \u00b6 Type Description [(Int)] Output \u00b6 Type Description [(Int)]","title":"BitSwap32"},{"location":"shards/General/BitSwap32/#bitswap32","text":"( BitSwap32 )","title":"BitSwap32"},{"location":"shards/General/BitSwap32/#definition","text":"","title":"Definition"},{"location":"shards/General/BitSwap32/#input","text":"Type Description [(Int)]","title":"Input"},{"location":"shards/General/BitSwap32/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/General/BitSwap64/","text":"BitSwap64 \u00b6 ( BitSwap64 ) Definition \u00b6 Input \u00b6 Type Description [(Int)] Output \u00b6 Type Description [(Int)]","title":"BitSwap64"},{"location":"shards/General/BitSwap64/#bitswap64","text":"( BitSwap64 )","title":"BitSwap64"},{"location":"shards/General/BitSwap64/#definition","text":"","title":"Definition"},{"location":"shards/General/BitSwap64/#input","text":"Type Description [(Int)]","title":"Input"},{"location":"shards/General/BitSwap64/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/General/Branch/","text":"Branch \u00b6 ( Branch :Wires [( Wire ) ( Seq [( Wire )]) ( None )] ) Definition \u00b6 A branch is a child mesh that runs and is ticked when this shard is activated, wires on this mesh will inherit all of the available exposed variables in the activator wire. Parameters \u00b6 Name Type Default Description Wires [(Wire) (Seq [(Wire)]) (None)] None The wires to schedule and run on this branch. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 ( defwire c1 .msg1 ( Log )) ( defwire c2 .msg2 ( Log )) ( defwire branch \"Hello\" = .msg1 \"World\" = .msg2 ( Branch [ c1 c2 ])) ( Do branch ) [info] [2022-08-15 10:09:08.705] [T-852] [logging.cpp::55] [c1] Hello [info] [2022-08-15 10:09:08.706] [T-852] [logging.cpp::55] [c2] World","title":"Branch"},{"location":"shards/General/Branch/#branch","text":"( Branch :Wires [( Wire ) ( Seq [( Wire )]) ( None )] )","title":"Branch"},{"location":"shards/General/Branch/#definition","text":"A branch is a child mesh that runs and is ticked when this shard is activated, wires on this mesh will inherit all of the available exposed variables in the activator wire.","title":"Definition"},{"location":"shards/General/Branch/#parameters","text":"Name Type Default Description Wires [(Wire) (Seq [(Wire)]) (None)] None The wires to schedule and run on this branch.","title":"Parameters"},{"location":"shards/General/Branch/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Branch/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Branch/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 ( defwire c1 .msg1 ( Log )) ( defwire c2 .msg2 ( Log )) ( defwire branch \"Hello\" = .msg1 \"World\" = .msg2 ( Branch [ c1 c2 ])) ( Do branch ) [info] [2022-08-15 10:09:08.705] [T-852] [logging.cpp::55] [c1] Hello [info] [2022-08-15 10:09:08.706] [T-852] [logging.cpp::55] [c2] World","title":"Examples"},{"location":"shards/General/Broadcast/","text":"Broadcast \u00b6 ( Broadcast :Name [( String )] :NoCopy!! [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the channel. NoCopy!! [(Bool)] false Unsafe flag that will improve performance by not copying values when sending them thru the channel. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Broadcast"},{"location":"shards/General/Broadcast/#broadcast","text":"( Broadcast :Name [( String )] :NoCopy!! [( Bool )] )","title":"Broadcast"},{"location":"shards/General/Broadcast/#definition","text":"","title":"Definition"},{"location":"shards/General/Broadcast/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the channel. NoCopy!! [(Bool)] false Unsafe flag that will improve performance by not copying values when sending them thru the channel.","title":"Parameters"},{"location":"shards/General/Broadcast/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Broadcast/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Browse/","text":"Browse \u00b6 ( Browse ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"Browse"},{"location":"shards/General/Browse/#browse","text":"( Browse )","title":"Browse"},{"location":"shards/General/Browse/#definition","text":"","title":"Definition"},{"location":"shards/General/Browse/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/Browse/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/BytesToInts/","text":"BytesToInts \u00b6 ( BytesToInts ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Seq [(Int)])]","title":"BytesToInts"},{"location":"shards/General/BytesToInts/#bytestoints","text":"( BytesToInts )","title":"BytesToInts"},{"location":"shards/General/BytesToInts/#definition","text":"","title":"Definition"},{"location":"shards/General/BytesToInts/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/General/BytesToInts/#output","text":"Type Description [(Seq [(Int)])]","title":"Output"},{"location":"shards/General/BytesToString/","text":"BytesToString \u00b6 ( BytesToString ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(String)]","title":"BytesToString"},{"location":"shards/General/BytesToString/#bytestostring","text":"( BytesToString )","title":"BytesToString"},{"location":"shards/General/BytesToString/#definition","text":"","title":"Definition"},{"location":"shards/General/BytesToString/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/General/BytesToString/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/Clear/","text":"Clear \u00b6 ( Clear :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Removes all the elements of the sequence passed to it in the :Name parameter. Applicable only to sequences. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(Any)] Any input is ignored. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Clear removes all the elements of the sequence that has been passed to it in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to clear. Any input to this shard is ignored and instead passed through as its output. See also Drop DropFront Erase Pop PopFront Remove Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [ 1 2 3 ] >= .seq ;; create local sequence [ 4 5 6 ] >== .seq ;; create global sequence with same name ( Get .seq ) ( Log ) ;; read local sequence => [1, 2, 3] ( Get .seq :Global true ) ( Log ) ;; read global sequence => [4, 5, 6] ;; clear local sequence ( Clear :Name .seq ) ;; clear local sequence ( Get .seq ) ( Log ) ;; local sequence cleared => [] ( Get .seq :Global true ) ( Log ) ;; same-name global sequence intact => [4, 5, 6] 100 ( AppendTo .seq ) ;; append something to local sequence ( Get .seq ) ( Log ) ;; local sequence no more empty => [100] ;; clear the same-named global sequence ( Clear :Name .seq :Global true ) ;; clear global sequence ( Get .seq :Global true ) ( Log ) ;; global sequence cleared => [] ( Get .seq ) ( Log ) ;; local sequence intact => [100] [info] [2022-08-15 10:09:10.873] [T-6852] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [1, 2, 3] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [4, 5, 6] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [4, 5, 6] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [100] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [100]","title":"Clear"},{"location":"shards/General/Clear/#clear","text":"( Clear :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Clear"},{"location":"shards/General/Clear/#definition","text":"Removes all the elements of the sequence passed to it in the :Name parameter. Applicable only to sequences.","title":"Definition"},{"location":"shards/General/Clear/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Clear/#input","text":"Type Description [(Any)] Any input is ignored.","title":"Input"},{"location":"shards/General/Clear/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Clear/#details","text":"Clear removes all the elements of the sequence that has been passed to it in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to clear. Any input to this shard is ignored and instead passed through as its output. See also Drop DropFront Erase Pop PopFront Remove","title":"Details"},{"location":"shards/General/Clear/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [ 1 2 3 ] >= .seq ;; create local sequence [ 4 5 6 ] >== .seq ;; create global sequence with same name ( Get .seq ) ( Log ) ;; read local sequence => [1, 2, 3] ( Get .seq :Global true ) ( Log ) ;; read global sequence => [4, 5, 6] ;; clear local sequence ( Clear :Name .seq ) ;; clear local sequence ( Get .seq ) ( Log ) ;; local sequence cleared => [] ( Get .seq :Global true ) ( Log ) ;; same-name global sequence intact => [4, 5, 6] 100 ( AppendTo .seq ) ;; append something to local sequence ( Get .seq ) ( Log ) ;; local sequence no more empty => [100] ;; clear the same-named global sequence ( Clear :Name .seq :Global true ) ;; clear global sequence ( Get .seq :Global true ) ( Log ) ;; global sequence cleared => [] ( Get .seq ) ( Log ) ;; local sequence intact => [100] [info] [2022-08-15 10:09:10.873] [T-6852] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [1, 2, 3] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [4, 5, 6] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [4, 5, 6] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [100] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [] [info] [2022-08-15 10:09:10.874] [T-6852] [logging.cpp::55] [shards/General/Clear/Clear.edn] [100]","title":"Examples"},{"location":"shards/General/Comment/","text":"Comment \u00b6 ( Comment :Text [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Text [(String)] \"\" The comment's text. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Comment"},{"location":"shards/General/Comment/#comment","text":"( Comment :Text [( String )] )","title":"Comment"},{"location":"shards/General/Comment/#definition","text":"","title":"Definition"},{"location":"shards/General/Comment/#parameters","text":"Name Type Default Description Text [(String)] \"\" The comment's text.","title":"Parameters"},{"location":"shards/General/Comment/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Comment/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Complete/","text":"Complete \u00b6 ( Complete :Name [( String )] :Buffer [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the channel. Buffer [(Int)] false The amount of values to buffer before outputting them. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Complete"},{"location":"shards/General/Complete/#complete","text":"( Complete :Name [( String )] :Buffer [( Int )] )","title":"Complete"},{"location":"shards/General/Complete/#definition","text":"","title":"Definition"},{"location":"shards/General/Complete/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the channel. Buffer [(Int)] false The amount of values to buffer before outputting them.","title":"Parameters"},{"location":"shards/General/Complete/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Complete/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Cond/","text":"Cond \u00b6 ( Cond :Wires [( Seq [( Shard ) ( Seq [( Shard )]) ( None )])] :Passthrough [( Bool )] :Threading [( Bool )] ) Definition \u00b6 Takes a sequence of conditions and predicates. Evaluates each condition one by one and if one matches, executes the associated action. Parameters \u00b6 Name Type Default Description Wires [(Seq [(Shard) (Seq [(Shard)]) (None)])] None A sequence of shards, interleaving condition test predicate and action to execute if the condition matches. Passthrough [(Bool)] true The output of this shard will be its input. Threading [(Bool)] false Will not short circuit after the first true test expression. The threaded value gets used in only the action and not the test part of the clause. Input \u00b6 Type Description [(Any)] The value that will be passed to each predicate and action to execute. Output \u00b6 Type Description [(Any)] The input of the shard if Passthrough is true ; otherwise, the output of the action of the first matching condition. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 0.5 ( Cond [( -> ( IsMore 0.7 )) ( -> \"fast\" ) ( -> ( IsLess 0.3 )) ( -> \"slow\" ) ; last case acts as default ( -> true ) ( -> \"normal\" )] ;:Passthrough false ) ( Assert.Is \"normal\" true )","title":"Cond"},{"location":"shards/General/Cond/#cond","text":"( Cond :Wires [( Seq [( Shard ) ( Seq [( Shard )]) ( None )])] :Passthrough [( Bool )] :Threading [( Bool )] )","title":"Cond"},{"location":"shards/General/Cond/#definition","text":"Takes a sequence of conditions and predicates. Evaluates each condition one by one and if one matches, executes the associated action.","title":"Definition"},{"location":"shards/General/Cond/#parameters","text":"Name Type Default Description Wires [(Seq [(Shard) (Seq [(Shard)]) (None)])] None A sequence of shards, interleaving condition test predicate and action to execute if the condition matches. Passthrough [(Bool)] true The output of this shard will be its input. Threading [(Bool)] false Will not short circuit after the first true test expression. The threaded value gets used in only the action and not the test part of the clause.","title":"Parameters"},{"location":"shards/General/Cond/#input","text":"Type Description [(Any)] The value that will be passed to each predicate and action to execute.","title":"Input"},{"location":"shards/General/Cond/#output","text":"Type Description [(Any)] The input of the shard if Passthrough is true ; otherwise, the output of the action of the first matching condition.","title":"Output"},{"location":"shards/General/Cond/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 0.5 ( Cond [( -> ( IsMore 0.7 )) ( -> \"fast\" ) ( -> ( IsLess 0.3 )) ( -> \"slow\" ) ; last case acts as default ( -> true ) ( -> \"normal\" )] ;:Passthrough false ) ( Assert.Is \"normal\" true )","title":"Examples"},{"location":"shards/General/Const/","text":"Const \u00b6 ( Const :Value [( Any )] ) Definition \u00b6 Declares an un-named constant value (of any data type). Parameters \u00b6 Name Type Default Description Value [(Any)] None The constant value to insert in the wire. Input \u00b6 Type Description [(None)] Any input is ignored. Output \u00b6 Type Description [(Any)] The declared constant value. Details \u00b6 Const declares a constant value (of any data type) by passing it into the parameter :Value . Such a value is usually declared for use as input in other shards. A constant value declared with Const is un-named i.e., it is not assigned to any variable or allocated any alias. Hence it cannot be invoked or referred to later. To create named constants see Ref . You can even skip this shard and pass the constant value directly but internally it will be translated to a Const shard that outputs this constant value. However, it's good practice to use this keyword in while passing constants in Shards programs. You can also use (Const nil) to overwrite/nullify (since nil stands for null data) the input to the subsequent shard, if required (see the last code sample). Input field is ignored and the output of this shard is the constant value defined by it. See also Ref Set Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ;; declare an int with `Const` and consume in `Math.Multiply` ( Const :Value 2 ) ( Math.Multiply 4 ) ( Log ) ;; => 8 ;; declare an int without `Const` and consume in `Math.Multiply` 2 ( Math.Multiply 4 ) ( Log ) ;; => 8 ;; declare a string with `Const` ( Const \"Hello World!\" ) ( Log ) ;; => \"Hello World!\" ;; declare a sequence with `Const` ( Const [ \"A\" \"B\" \"C\" ]) ( Log ) ;; => [\"A\" \"B\" \"C\"] ;; declare a Float4 with `Const` ( Const ( Float4 1 2 3 4 )) ( Log ) ;; => (Float4 1 2 3 4) ;; declare a table with `Const` ( Const { \"key1\" 10 \"key2\" 20.0 }) ( Log ) ;; => {\"key1\" 10 \"key2\" 20.0} ;; nullifying the input to a shard with (Const nil) \"Hello World\" ;; string input for Log ( Const nil ) ;; nulls the string input ( Log ) ;; Log gets no input => None [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] 8 [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] 8 [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] Hello World! [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] [A, B, C] [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] (1, 2, 3, 4) [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] {key1: 10, key2: 20} [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] None","title":"Const"},{"location":"shards/General/Const/#const","text":"( Const :Value [( Any )] )","title":"Const"},{"location":"shards/General/Const/#definition","text":"Declares an un-named constant value (of any data type).","title":"Definition"},{"location":"shards/General/Const/#parameters","text":"Name Type Default Description Value [(Any)] None The constant value to insert in the wire.","title":"Parameters"},{"location":"shards/General/Const/#input","text":"Type Description [(None)] Any input is ignored.","title":"Input"},{"location":"shards/General/Const/#output","text":"Type Description [(Any)] The declared constant value.","title":"Output"},{"location":"shards/General/Const/#details","text":"Const declares a constant value (of any data type) by passing it into the parameter :Value . Such a value is usually declared for use as input in other shards. A constant value declared with Const is un-named i.e., it is not assigned to any variable or allocated any alias. Hence it cannot be invoked or referred to later. To create named constants see Ref . You can even skip this shard and pass the constant value directly but internally it will be translated to a Const shard that outputs this constant value. However, it's good practice to use this keyword in while passing constants in Shards programs. You can also use (Const nil) to overwrite/nullify (since nil stands for null data) the input to the subsequent shard, if required (see the last code sample). Input field is ignored and the output of this shard is the constant value defined by it. See also Ref Set","title":"Details"},{"location":"shards/General/Const/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ;; declare an int with `Const` and consume in `Math.Multiply` ( Const :Value 2 ) ( Math.Multiply 4 ) ( Log ) ;; => 8 ;; declare an int without `Const` and consume in `Math.Multiply` 2 ( Math.Multiply 4 ) ( Log ) ;; => 8 ;; declare a string with `Const` ( Const \"Hello World!\" ) ( Log ) ;; => \"Hello World!\" ;; declare a sequence with `Const` ( Const [ \"A\" \"B\" \"C\" ]) ( Log ) ;; => [\"A\" \"B\" \"C\"] ;; declare a Float4 with `Const` ( Const ( Float4 1 2 3 4 )) ( Log ) ;; => (Float4 1 2 3 4) ;; declare a table with `Const` ( Const { \"key1\" 10 \"key2\" 20.0 }) ( Log ) ;; => {\"key1\" 10 \"key2\" 20.0} ;; nullifying the input to a shard with (Const nil) \"Hello World\" ;; string input for Log ( Const nil ) ;; nulls the string input ( Log ) ;; Log gets no input => None [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] 8 [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] 8 [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] Hello World! [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] [A, B, C] [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] (1, 2, 3, 4) [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] {key1: 10, key2: 20} [info] [2022-08-15 10:09:10.985] [T-4408] [logging.cpp::55] [shards/General/Const/Const.edn] None","title":"Examples"},{"location":"shards/General/Consume/","text":"Consume \u00b6 ( Consume :Name [( String )] :Buffer [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the channel. Buffer [(Int)] 1 The amount of values to buffer before outputting them. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Consume"},{"location":"shards/General/Consume/#consume","text":"( Consume :Name [( String )] :Buffer [( Int )] )","title":"Consume"},{"location":"shards/General/Consume/#definition","text":"","title":"Definition"},{"location":"shards/General/Consume/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the channel. Buffer [(Int)] 1 The amount of values to buffer before outputting them.","title":"Parameters"},{"location":"shards/General/Consume/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Consume/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Convolve/","text":"Convolve \u00b6 ( Convolve :Radius [( Int )] :Step [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Radius [(Int)] 1 The radius of the kernel, e.g. 1 = 1x1; 2 = 3x3; 3 = 5x5 and so on. Step [(Int)] 1 How many pixels to advance each activation. Input \u00b6 Type Description [(Image)] Output \u00b6 Type Description [(Image)]","title":"Convolve"},{"location":"shards/General/Convolve/#convolve","text":"( Convolve :Radius [( Int )] :Step [( Int )] )","title":"Convolve"},{"location":"shards/General/Convolve/#definition","text":"","title":"Definition"},{"location":"shards/General/Convolve/#parameters","text":"Name Type Default Description Radius [(Int)] 1 The radius of the kernel, e.g. 1 = 1x1; 2 = 3x3; 3 = 5x5 and so on. Step [(Int)] 1 How many pixels to advance each activation.","title":"Parameters"},{"location":"shards/General/Convolve/#input","text":"Type Description [(Image)]","title":"Input"},{"location":"shards/General/Convolve/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/General/Count/","text":"Count \u00b6 ( Count :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Parses the value in passed to in the :Name parameter and returns the count of characters (if string passed), elements (if sequence passed), or key-value pairs (if table passed). Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(None)] Any input is ignored. Output \u00b6 Type Description [(Int)] Count of characters, elements, or key-value pairs contained in the :Name parameter variable. Details \u00b6 Count parses the value passed to it in the :Name parameter, and returns the count of characters, elements, or key-value pairs depending on whether the data type passed to it was a string, a sequence, or a table. If this shard is applied to a number it returns zero as the count. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to count. Input field is ignored and the output of this shard is the count value in Int type. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; counting in locally scoped variables \"Shards\" >= .string ( Count :Name .string ) ( Log ) ;; no. of characters => 6 [ 10 20 30 ] >= .sequence ( Count .sequence ) ( Log ) ;; no. of elements => 3 { \"k1\" 11 \"k2\" 22 } >= .table ( Count .table ) ( Log ) ;; no. of key-value pairs => 2 12345 >= .number ( Count .number ) ( Log ) ;; zero count for numbers => 0 ;; counting in same-name local and global variables \"Local Shards\" >= .stringvar ;; create a local variable \"Global Shards\" >== .stringvar ;; create a same-name global variable ( Count .stringvar ) ( Log ) ;; characters in local var => 12 ( Count .stringvar :Global true ) ( Log ) ;; characters in global var => 13 [info] [2022-08-15 10:09:11.041] [T-6296] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: stringvar [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 6 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 3 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 2 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 0 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 12 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 13","title":"Count"},{"location":"shards/General/Count/#count","text":"( Count :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Count"},{"location":"shards/General/Count/#definition","text":"Parses the value in passed to in the :Name parameter and returns the count of characters (if string passed), elements (if sequence passed), or key-value pairs (if table passed).","title":"Definition"},{"location":"shards/General/Count/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Count/#input","text":"Type Description [(None)] Any input is ignored.","title":"Input"},{"location":"shards/General/Count/#output","text":"Type Description [(Int)] Count of characters, elements, or key-value pairs contained in the :Name parameter variable.","title":"Output"},{"location":"shards/General/Count/#details","text":"Count parses the value passed to it in the :Name parameter, and returns the count of characters, elements, or key-value pairs depending on whether the data type passed to it was a string, a sequence, or a table. If this shard is applied to a number it returns zero as the count. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to count. Input field is ignored and the output of this shard is the count value in Int type.","title":"Details"},{"location":"shards/General/Count/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; counting in locally scoped variables \"Shards\" >= .string ( Count :Name .string ) ( Log ) ;; no. of characters => 6 [ 10 20 30 ] >= .sequence ( Count .sequence ) ( Log ) ;; no. of elements => 3 { \"k1\" 11 \"k2\" 22 } >= .table ( Count .table ) ( Log ) ;; no. of key-value pairs => 2 12345 >= .number ( Count .number ) ( Log ) ;; zero count for numbers => 0 ;; counting in same-name local and global variables \"Local Shards\" >= .stringvar ;; create a local variable \"Global Shards\" >== .stringvar ;; create a same-name global variable ( Count .stringvar ) ( Log ) ;; characters in local var => 12 ( Count .stringvar :Global true ) ( Log ) ;; characters in global var => 13 [info] [2022-08-15 10:09:11.041] [T-6296] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: stringvar [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 6 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 3 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 2 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 0 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 12 [info] [2022-08-15 10:09:11.042] [T-6296] [logging.cpp::55] [shards/General/Count/Count.edn] 13","title":"Examples"},{"location":"shards/General/DShard/","text":"DShard \u00b6 ( DShard :Name [( String )] :Parameters [( Seq [( Any )])] ) Definition \u00b6 A dynamic shard. Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the shard to wrap. Parameters [(Seq [(Any)])] [] The parameters to pass to the wrapped shard. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(None)]","title":"DShard"},{"location":"shards/General/DShard/#dshard","text":"( DShard :Name [( String )] :Parameters [( Seq [( Any )])] )","title":"DShard"},{"location":"shards/General/DShard/#definition","text":"A dynamic shard.","title":"Definition"},{"location":"shards/General/DShard/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the shard to wrap. Parameters [(Seq [(Any)])] [] The parameters to pass to the wrapped shard.","title":"Parameters"},{"location":"shards/General/DShard/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/General/DShard/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/General/Detach/","text":"Detach \u00b6 ( Detach :Wire [( Wire ) ( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 ( defwire hello ( Msg \"Hello\" )) ( Detach ;:Wire hello ) ( Step hello ) [info] [2022-08-15 10:09:11.098] [T-988] [logging.cpp::98] [hello] Hello","title":"Detach"},{"location":"shards/General/Detach/#detach","text":"( Detach :Wire [( Wire ) ( String ) ( None )] )","title":"Detach"},{"location":"shards/General/Detach/#definition","text":"","title":"Definition"},{"location":"shards/General/Detach/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run.","title":"Parameters"},{"location":"shards/General/Detach/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Detach/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Detach/#examples","text":"Code Output 1 2 3 4 5 6 7 8 ( defwire hello ( Msg \"Hello\" )) ( Detach ;:Wire hello ) ( Step hello ) [info] [2022-08-15 10:09:11.098] [T-988] [logging.cpp::98] [hello] Hello","title":"Examples"},{"location":"shards/General/Dispatch/","text":"Dispatch \u00b6 ( Dispatch :Wire [( Wire ) ( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 ( defwire funcWire ( If ( -> ( Is 10 ) ( Or ) ( Is 20 )) ( Log ))) 10 ( Dispatch ;:Wire funcWire ) ( Assert.Is 10 true ) [info] [2022-08-15 10:09:11.154] [T-5672] [logging.cpp::55] [funcWire] 10","title":"Dispatch"},{"location":"shards/General/Dispatch/#dispatch","text":"( Dispatch :Wire [( Wire ) ( String ) ( None )] )","title":"Dispatch"},{"location":"shards/General/Dispatch/#definition","text":"","title":"Definition"},{"location":"shards/General/Dispatch/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run.","title":"Parameters"},{"location":"shards/General/Dispatch/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Dispatch/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Dispatch/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 ( defwire funcWire ( If ( -> ( Is 10 ) ( Or ) ( Is 20 )) ( Log ))) 10 ( Dispatch ;:Wire funcWire ) ( Assert.Is 10 true ) [info] [2022-08-15 10:09:11.154] [T-5672] [logging.cpp::55] [funcWire] 10","title":"Examples"},{"location":"shards/General/Do/","text":"Do \u00b6 ( Do :Wire [( Wire ) ( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ( def logicWire ( Wire \"dologic\" ( IsMore 10 ) ( Or ) ( IsLess 0 ))) -10 ( Do logicWire ) ( Assert.Is true true ) 5 ( Do \"dologic\" ) ( Assert.IsNot true true ) [warning] [2022-08-15 10:09:11.211] [T-4432] [runtime.cpp::2706] Warmup already run on wire: dologic, not supposed to happen!","title":"Do"},{"location":"shards/General/Do/#do","text":"( Do :Wire [( Wire ) ( String ) ( None )] )","title":"Do"},{"location":"shards/General/Do/#definition","text":"","title":"Definition"},{"location":"shards/General/Do/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run.","title":"Parameters"},{"location":"shards/General/Do/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Do/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Do/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ( def logicWire ( Wire \"dologic\" ( IsMore 10 ) ( Or ) ( IsLess 0 ))) -10 ( Do logicWire ) ( Assert.Is true true ) 5 ( Do \"dologic\" ) ( Assert.IsNot true true ) [warning] [2022-08-15 10:09:11.211] [T-4432] [runtime.cpp::2706] Warmup already run on wire: dologic, not supposed to happen!","title":"Examples"},{"location":"shards/General/Drop/","text":"Drop \u00b6 ( Drop :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Drops the last element of the sequence variable passed in the :Name parameter. Works only on sequences. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(Any)] Any input is ignored. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Drop drops (removes) the last element of the sequence variable that has been passed to in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to drop elements from. Any input to this shard is ignored and instead passed through as its output. See also AppendTo Clear DropFront Erase Pop PopFront Remove Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; drop last element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( Drop :Name .seq ) ;; drops the last element i.e., 40 ( Get .seq ) ( Log ) ;; updated sequence => [10, 20, 30] ;; drop last element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( Drop :Name .seq ) ;; drops the last element i.e., 41 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [11, 21, 31] [info] [2022-08-15 10:09:11.267] [T-6444] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [10, 20, 30] [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [11, 21, 31, 41]","title":"Drop"},{"location":"shards/General/Drop/#drop","text":"( Drop :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Drop"},{"location":"shards/General/Drop/#definition","text":"Drops the last element of the sequence variable passed in the :Name parameter. Works only on sequences.","title":"Definition"},{"location":"shards/General/Drop/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Drop/#input","text":"Type Description [(Any)] Any input is ignored.","title":"Input"},{"location":"shards/General/Drop/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Drop/#details","text":"Drop drops (removes) the last element of the sequence variable that has been passed to in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to drop elements from. Any input to this shard is ignored and instead passed through as its output. See also AppendTo Clear DropFront Erase Pop PopFront Remove","title":"Details"},{"location":"shards/General/Drop/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; drop last element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( Drop :Name .seq ) ;; drops the last element i.e., 40 ( Get .seq ) ( Log ) ;; updated sequence => [10, 20, 30] ;; drop last element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( Drop :Name .seq ) ;; drops the last element i.e., 41 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [11, 21, 31] [info] [2022-08-15 10:09:11.267] [T-6444] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [10, 20, 30] [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:11.268] [T-6444] [logging.cpp::55] [shards/General/Drop/Drop.edn] [11, 21, 31, 41]","title":"Examples"},{"location":"shards/General/DropFront/","text":"DropFront \u00b6 ( DropFront :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Drops the first element of the sequence variable passed in the :Name parameter. Works only on sequences. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(Any)] Any input is ignored. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 DropFront drops (removes) the first element of the sequence variable that has been passed to in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to drop elements from. Any input to this shard is ignored and instead passed through as its output. See also Clear Drop Erase Pop PopFront PrependTo Remove Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; drop first element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( DropFront :Name .seq ) ;; drops the first element i.e., 10 ( Get .seq ) ( Log ) ;; updated sequence => [20 30 40] ;; drop first element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( DropFront .seq :Global true ) ;; drops the first element i.e., 11 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [21, 31, 41] [info] [2022-08-15 10:09:11.325] [T-848] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [20, 30, 40] [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [21, 31, 41]","title":"DropFront"},{"location":"shards/General/DropFront/#dropfront","text":"( DropFront :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"DropFront"},{"location":"shards/General/DropFront/#definition","text":"Drops the first element of the sequence variable passed in the :Name parameter. Works only on sequences.","title":"Definition"},{"location":"shards/General/DropFront/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/DropFront/#input","text":"Type Description [(Any)] Any input is ignored.","title":"Input"},{"location":"shards/General/DropFront/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/DropFront/#details","text":"DropFront drops (removes) the first element of the sequence variable that has been passed to in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to drop elements from. Any input to this shard is ignored and instead passed through as its output. See also Clear Drop Erase Pop PopFront PrependTo Remove","title":"Details"},{"location":"shards/General/DropFront/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; drop first element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( DropFront :Name .seq ) ;; drops the first element i.e., 10 ( Get .seq ) ( Log ) ;; updated sequence => [20 30 40] ;; drop first element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( DropFront .seq :Global true ) ;; drops the first element i.e., 11 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [21, 31, 41] [info] [2022-08-15 10:09:11.325] [T-848] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [20, 30, 40] [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:11.325] [T-848] [logging.cpp::55] [shards/General/DropFront/DropFront.edn] [21, 31, 41]","title":"Examples"},{"location":"shards/General/Erase/","text":"Erase \u00b6 ( Erase :Indices [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])]) ( String ) ( Seq [( String )]) ( ContextVar [( String )]) ( ContextVar [( Seq [( String )])])] :Name [( String ) ( ContextVar [( Any )])] :Key [( String )] :Global [( Bool )] ) Definition \u00b6 Deletes identfied element(s) from a sequence or key-value pair(s) from a table. Parameters \u00b6 Name Type Default Description Indices [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])]) (String) (Seq [(String)]) (ContextVar [(String)]) (ContextVar [(Seq [(String)])])] None One or multiple indices to filter from a sequence. Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String)] None The key of the value to read/write from/in the table (this variable will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(Any)] Any input is ignored. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Erase deletes single or multiple elements (from sequences) and key-value pairs (from tables). For a sequence, this shard expects the index (or a sequence of indices in descending order) of the element(s) to be erased, followed by the name of the sequence variable in the :Name parameter. For a table, this shard expects the key (or a sequence of keys) of the key-value pair(s) to be erased, followed by the name of the table variable in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to erase. Any input to this shard is ignored and instead passed through as its output. See also Clear Drop DropFront Pop PopFront Remove Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ;; erase single element from sequence [ 100 200 300 400 ] >= .seq1 ( Erase [ 1 ] :Name .seq1 ) ( Log \"output\" ) ;; => output: [100 200 300 400] .seq1 ( Log \".seq1\" ) ;; => seq1: [100, 300, 400] ;; erase multiple elements from sequence [ 100 200 300 400 ] >= .seq2 ( Erase [ 2 0 ] :Name .seq2 ) .seq2 ( Log ) ;; => [200, 400] ;; erase single key-value pair from table { :k1 10 :k2 20 :k3 30 } >= .tab1 ( Erase \"k2\" :Name .tab1 ) .tab1 ( Log ) ;; => {:k3 30, :k1 10} ;; erase multiple key-value pairs from table { :k1 100 :k2 200 :k3 300 } >= .tab2 ( Erase [ \"k3\" \"k1\" ] .tab2 ) .tab2 ( Log ) ;; => {:k2 200} ;; erase from same-name local and global sequences [ 1 2 3 ] >= .seq ;; create local sequence [ 1 2 3 ] >== .seq ;; create same-name global sequence ( Erase [ 2 0 ] .seq ) ;; erase from local sequence ( Get .seq ) ( Log ) ;; => [2] ( Erase [ 1 ] .seq :Global true ) ;; erase from same-name global sequence ( Get .seq :Global true ) ( Log ) ;; => [1, 3] ;; erase from same-name local and global tables { :k1 1 :k2 2 :k3 3 } >= .tab ;; create local table { :k1 1 :k2 2 :k3 3 } >== .tab ;; create same-name global table ( Erase [ \"k3\" \"k1\" ] .tab ) ;; erase from local table ( Get .tab ) ( Log ) ;; => {:k2 2} ( Erase [ \"k2\" ] .tab :Global true ) ;; erase from same-name global table ( Get .tab :Global true ) ( Log ) ;; => {:k3 3 :k1 1} [info] [2022-08-15 10:09:11.383] [T-7040] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:11.384] [T-7040] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: tab [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::53] [shards/General/Erase/Erase.edn] output: [100, 200, 300, 400] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::53] [shards/General/Erase/Erase.edn] .seq1: [100, 300, 400] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] [200, 400] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k3: 30, k1: 10} [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k2: 200} [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] [2] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] [1, 3] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k2: 2} [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k3: 3, k1: 1}","title":"Erase"},{"location":"shards/General/Erase/#erase","text":"( Erase :Indices [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])]) ( String ) ( Seq [( String )]) ( ContextVar [( String )]) ( ContextVar [( Seq [( String )])])] :Name [( String ) ( ContextVar [( Any )])] :Key [( String )] :Global [( Bool )] )","title":"Erase"},{"location":"shards/General/Erase/#definition","text":"Deletes identfied element(s) from a sequence or key-value pair(s) from a table.","title":"Definition"},{"location":"shards/General/Erase/#parameters","text":"Name Type Default Description Indices [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])]) (String) (Seq [(String)]) (ContextVar [(String)]) (ContextVar [(Seq [(String)])])] None One or multiple indices to filter from a sequence. Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String)] None The key of the value to read/write from/in the table (this variable will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Erase/#input","text":"Type Description [(Any)] Any input is ignored.","title":"Input"},{"location":"shards/General/Erase/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Erase/#details","text":"Erase deletes single or multiple elements (from sequences) and key-value pairs (from tables). For a sequence, this shard expects the index (or a sequence of indices in descending order) of the element(s) to be erased, followed by the name of the sequence variable in the :Name parameter. For a table, this shard expects the key (or a sequence of keys) of the key-value pair(s) to be erased, followed by the name of the table variable in the :Name parameter. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to erase. Any input to this shard is ignored and instead passed through as its output. See also Clear Drop DropFront Pop PopFront Remove","title":"Details"},{"location":"shards/General/Erase/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ;; erase single element from sequence [ 100 200 300 400 ] >= .seq1 ( Erase [ 1 ] :Name .seq1 ) ( Log \"output\" ) ;; => output: [100 200 300 400] .seq1 ( Log \".seq1\" ) ;; => seq1: [100, 300, 400] ;; erase multiple elements from sequence [ 100 200 300 400 ] >= .seq2 ( Erase [ 2 0 ] :Name .seq2 ) .seq2 ( Log ) ;; => [200, 400] ;; erase single key-value pair from table { :k1 10 :k2 20 :k3 30 } >= .tab1 ( Erase \"k2\" :Name .tab1 ) .tab1 ( Log ) ;; => {:k3 30, :k1 10} ;; erase multiple key-value pairs from table { :k1 100 :k2 200 :k3 300 } >= .tab2 ( Erase [ \"k3\" \"k1\" ] .tab2 ) .tab2 ( Log ) ;; => {:k2 200} ;; erase from same-name local and global sequences [ 1 2 3 ] >= .seq ;; create local sequence [ 1 2 3 ] >== .seq ;; create same-name global sequence ( Erase [ 2 0 ] .seq ) ;; erase from local sequence ( Get .seq ) ( Log ) ;; => [2] ( Erase [ 1 ] .seq :Global true ) ;; erase from same-name global sequence ( Get .seq :Global true ) ( Log ) ;; => [1, 3] ;; erase from same-name local and global tables { :k1 1 :k2 2 :k3 3 } >= .tab ;; create local table { :k1 1 :k2 2 :k3 3 } >== .tab ;; create same-name global table ( Erase [ \"k3\" \"k1\" ] .tab ) ;; erase from local table ( Get .tab ) ( Log ) ;; => {:k2 2} ( Erase [ \"k2\" ] .tab :Global true ) ;; erase from same-name global table ( Get .tab :Global true ) ( Log ) ;; => {:k3 3 :k1 1} [info] [2022-08-15 10:09:11.383] [T-7040] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:11.384] [T-7040] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: tab [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::53] [shards/General/Erase/Erase.edn] output: [100, 200, 300, 400] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::53] [shards/General/Erase/Erase.edn] .seq1: [100, 300, 400] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] [200, 400] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k3: 30, k1: 10} [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k2: 200} [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] [2] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] [1, 3] [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k2: 2} [info] [2022-08-15 10:09:11.384] [T-7040] [logging.cpp::55] [shards/General/Erase/Erase.edn] {k3: 3, k1: 1}","title":"Examples"},{"location":"shards/General/Evolve/","text":"Evolve \u00b6 ( Evolve :Wire [( Wire )] :Fitness [( Wire )] :Population [( Int )] :Mutation [( Float )] :Crossover [( Float )] :Extinction [( Float )] :Elitism [( Float )] :Threads [( Int )] :Coroutines [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(Wire)] None The wire to optimize and evolve. Fitness [(Wire)] None The fitness wire to run at the end of the main wire evaluation and using its last output; should output a Float fitness value. Population [(Int)] 64 The population size. Mutation [(Float)] 0.2 The rate of mutation, 0.1 = 10%. Crossover [(Float)] 0.2 The rate of crossover, 0.1 = 10%. Extinction [(Float)] 0.1 The rate of extinction, 0.1 = 10%. Elitism [(Float)] 0.1 The rate of elitism, 0.1 = 10%. Threads [(Int)] 2 The number of cpu threads to use. Coroutines [(Int)] 8 The number of coroutines to run on each thread. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Seq [(Float) (Wire)])]","title":"Evolve"},{"location":"shards/General/Evolve/#evolve","text":"( Evolve :Wire [( Wire )] :Fitness [( Wire )] :Population [( Int )] :Mutation [( Float )] :Crossover [( Float )] :Extinction [( Float )] :Elitism [( Float )] :Threads [( Int )] :Coroutines [( Int )] )","title":"Evolve"},{"location":"shards/General/Evolve/#definition","text":"","title":"Definition"},{"location":"shards/General/Evolve/#parameters","text":"Name Type Default Description Wire [(Wire)] None The wire to optimize and evolve. Fitness [(Wire)] None The fitness wire to run at the end of the main wire evaluation and using its last output; should output a Float fitness value. Population [(Int)] 64 The population size. Mutation [(Float)] 0.2 The rate of mutation, 0.1 = 10%. Crossover [(Float)] 0.2 The rate of crossover, 0.1 = 10%. Extinction [(Float)] 0.1 The rate of extinction, 0.1 = 10%. Elitism [(Float)] 0.1 The rate of elitism, 0.1 = 10%. Threads [(Int)] 2 The number of cpu threads to use. Coroutines [(Int)] 8 The number of coroutines to run on each thread.","title":"Parameters"},{"location":"shards/General/Evolve/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Evolve/#output","text":"Type Description [(Seq [(Float) (Wire)])]","title":"Output"},{"location":"shards/General/Exit/","text":"Exit \u00b6 ( Exit ) Definition \u00b6 Input \u00b6 Type Description [(Int)] Output \u00b6 Type Description [(None)]","title":"Exit"},{"location":"shards/General/Exit/#exit","text":"( Exit )","title":"Exit"},{"location":"shards/General/Exit/#definition","text":"","title":"Definition"},{"location":"shards/General/Exit/#input","text":"Type Description [(Int)]","title":"Input"},{"location":"shards/General/Exit/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/General/Expand/","text":"Expand \u00b6 ( Expand :Size [( Int )] :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Policy [( Enum )] :Threads [( Int )] :Coroutines [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Size [(Int)] 10 The maximum expansion size. Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to spawn and try to run many times concurrently. Policy [(Enum)] Enum: 1 vendor: 0x66726167 type: 0x7472794d The execution policy in terms of wires success. Threads [(Int)] 1 The number of cpu threads to use. Coroutines [(Int)] 1 The number of coroutines to run on each thread. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Seq [(Any)])] Examples \u00b6 Code Output 1 2 3 4 5 6 21 ( Expand :Size 10 :Wire ( defwire wide-test ( Math.Multiply 2 )) :Threads 5 ) ( Assert.Is [ 42 42 42 42 42 42 42 42 42 42 ] true )","title":"Expand"},{"location":"shards/General/Expand/#expand","text":"( Expand :Size [( Int )] :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Policy [( Enum )] :Threads [( Int )] :Coroutines [( Int )] )","title":"Expand"},{"location":"shards/General/Expand/#definition","text":"","title":"Definition"},{"location":"shards/General/Expand/#parameters","text":"Name Type Default Description Size [(Int)] 10 The maximum expansion size. Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to spawn and try to run many times concurrently. Policy [(Enum)] Enum: 1 vendor: 0x66726167 type: 0x7472794d The execution policy in terms of wires success. Threads [(Int)] 1 The number of cpu threads to use. Coroutines [(Int)] 1 The number of coroutines to run on each thread.","title":"Parameters"},{"location":"shards/General/Expand/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Expand/#output","text":"Type Description [(Seq [(Any)])]","title":"Output"},{"location":"shards/General/Expand/#examples","text":"Code Output 1 2 3 4 5 6 21 ( Expand :Size 10 :Wire ( defwire wide-test ( Math.Multiply 2 )) :Threads 5 ) ( Assert.Is [ 42 42 42 42 42 42 42 42 42 42 ] true )","title":"Examples"},{"location":"shards/General/ExpectAny/","text":"ExpectAny \u00b6 ( ExpectAny ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ExpectAny"},{"location":"shards/General/ExpectAny/#expectany","text":"( ExpectAny )","title":"ExpectAny"},{"location":"shards/General/ExpectAny/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectAny/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectAny/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ExpectBool/","text":"ExpectBool \u00b6 ( ExpectBool ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)]","title":"ExpectBool"},{"location":"shards/General/ExpectBool/#expectbool","text":"( ExpectBool )","title":"ExpectBool"},{"location":"shards/General/ExpectBool/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectBool/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectBool/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/ExpectBytes/","text":"ExpectBytes \u00b6 ( ExpectBytes ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bytes)]","title":"ExpectBytes"},{"location":"shards/General/ExpectBytes/#expectbytes","text":"( ExpectBytes )","title":"ExpectBytes"},{"location":"shards/General/ExpectBytes/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectBytes/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectBytes/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/ExpectBytesSeq/","text":"ExpectBytesSeq \u00b6 ( ExpectBytesSeq ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Seq [(Bytes)])]","title":"ExpectBytesSeq"},{"location":"shards/General/ExpectBytesSeq/#expectbytesseq","text":"( ExpectBytesSeq )","title":"ExpectBytesSeq"},{"location":"shards/General/ExpectBytesSeq/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectBytesSeq/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectBytesSeq/#output","text":"Type Description [(Seq [(Bytes)])]","title":"Output"},{"location":"shards/General/ExpectFloat/","text":"ExpectFloat \u00b6 ( ExpectFloat ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Float)]","title":"ExpectFloat"},{"location":"shards/General/ExpectFloat/#expectfloat","text":"( ExpectFloat )","title":"ExpectFloat"},{"location":"shards/General/ExpectFloat/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectFloat/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectFloat/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/General/ExpectFloat2/","text":"ExpectFloat2 \u00b6 ( ExpectFloat2 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Float2)]","title":"ExpectFloat2"},{"location":"shards/General/ExpectFloat2/#expectfloat2","text":"( ExpectFloat2 )","title":"ExpectFloat2"},{"location":"shards/General/ExpectFloat2/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectFloat2/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectFloat2/#output","text":"Type Description [(Float2)]","title":"Output"},{"location":"shards/General/ExpectFloat3/","text":"ExpectFloat3 \u00b6 ( ExpectFloat3 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Float3)]","title":"ExpectFloat3"},{"location":"shards/General/ExpectFloat3/#expectfloat3","text":"( ExpectFloat3 )","title":"ExpectFloat3"},{"location":"shards/General/ExpectFloat3/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectFloat3/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectFloat3/#output","text":"Type Description [(Float3)]","title":"Output"},{"location":"shards/General/ExpectFloat4/","text":"ExpectFloat4 \u00b6 ( ExpectFloat4 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Float4)]","title":"ExpectFloat4"},{"location":"shards/General/ExpectFloat4/#expectfloat4","text":"( ExpectFloat4 )","title":"ExpectFloat4"},{"location":"shards/General/ExpectFloat4/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectFloat4/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectFloat4/#output","text":"Type Description [(Float4)]","title":"Output"},{"location":"shards/General/ExpectFloatSeq/","text":"ExpectFloatSeq \u00b6 ( ExpectFloatSeq ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Seq [(Float)])]","title":"ExpectFloatSeq"},{"location":"shards/General/ExpectFloatSeq/#expectfloatseq","text":"( ExpectFloatSeq )","title":"ExpectFloatSeq"},{"location":"shards/General/ExpectFloatSeq/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectFloatSeq/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectFloatSeq/#output","text":"Type Description [(Seq [(Float)])]","title":"Output"},{"location":"shards/General/ExpectImage/","text":"ExpectImage \u00b6 ( ExpectImage ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Image)]","title":"ExpectImage"},{"location":"shards/General/ExpectImage/#expectimage","text":"( ExpectImage )","title":"ExpectImage"},{"location":"shards/General/ExpectImage/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectImage/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectImage/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/General/ExpectInt/","text":"ExpectInt \u00b6 ( ExpectInt ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Int)]","title":"ExpectInt"},{"location":"shards/General/ExpectInt/#expectint","text":"( ExpectInt )","title":"ExpectInt"},{"location":"shards/General/ExpectInt/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectInt/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectInt/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/General/ExpectInt2/","text":"ExpectInt2 \u00b6 ( ExpectInt2 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Int2)]","title":"ExpectInt2"},{"location":"shards/General/ExpectInt2/#expectint2","text":"( ExpectInt2 )","title":"ExpectInt2"},{"location":"shards/General/ExpectInt2/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectInt2/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectInt2/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/General/ExpectInt3/","text":"ExpectInt3 \u00b6 ( ExpectInt3 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Int3)]","title":"ExpectInt3"},{"location":"shards/General/ExpectInt3/#expectint3","text":"( ExpectInt3 )","title":"ExpectInt3"},{"location":"shards/General/ExpectInt3/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectInt3/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectInt3/#output","text":"Type Description [(Int3)]","title":"Output"},{"location":"shards/General/ExpectInt4/","text":"ExpectInt4 \u00b6 ( ExpectInt4 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Int4)]","title":"ExpectInt4"},{"location":"shards/General/ExpectInt4/#expectint4","text":"( ExpectInt4 )","title":"ExpectInt4"},{"location":"shards/General/ExpectInt4/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectInt4/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectInt4/#output","text":"Type Description [(Int4)]","title":"Output"},{"location":"shards/General/ExpectIntSeq/","text":"ExpectIntSeq \u00b6 ( ExpectIntSeq ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Seq [(Int)])]","title":"ExpectIntSeq"},{"location":"shards/General/ExpectIntSeq/#expectintseq","text":"( ExpectIntSeq )","title":"ExpectIntSeq"},{"location":"shards/General/ExpectIntSeq/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectIntSeq/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectIntSeq/#output","text":"Type Description [(Seq [(Int)])]","title":"Output"},{"location":"shards/General/ExpectLike/","text":"ExpectLike \u00b6 ( ExpectLike :Example [( Any )] :Unsafe [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Example [(Any)] None The example value to expect, in the case of a used wire, the output type of that wire will be used. Unsafe [(Bool)] false If we should skip performing deep type hashing and comparison. (generally fast but this might improve performance) Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ExpectLike"},{"location":"shards/General/ExpectLike/#expectlike","text":"( ExpectLike :Example [( Any )] :Unsafe [( Bool )] )","title":"ExpectLike"},{"location":"shards/General/ExpectLike/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectLike/#parameters","text":"Name Type Default Description Example [(Any)] None The example value to expect, in the case of a used wire, the output type of that wire will be used. Unsafe [(Bool)] false If we should skip performing deep type hashing and comparison. (generally fast but this might improve performance)","title":"Parameters"},{"location":"shards/General/ExpectLike/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectLike/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ExpectNone/","text":"ExpectNone \u00b6 ( ExpectNone ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(None)]","title":"ExpectNone"},{"location":"shards/General/ExpectNone/#expectnone","text":"( ExpectNone )","title":"ExpectNone"},{"location":"shards/General/ExpectNone/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectNone/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectNone/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/General/ExpectSeq/","text":"ExpectSeq \u00b6 ( ExpectSeq ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Seq [])]","title":"ExpectSeq"},{"location":"shards/General/ExpectSeq/#expectseq","text":"( ExpectSeq )","title":"ExpectSeq"},{"location":"shards/General/ExpectSeq/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectSeq/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectSeq/#output","text":"Type Description [(Seq [])]","title":"Output"},{"location":"shards/General/ExpectString/","text":"ExpectString \u00b6 ( ExpectString ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(String)]","title":"ExpectString"},{"location":"shards/General/ExpectString/#expectstring","text":"( ExpectString )","title":"ExpectString"},{"location":"shards/General/ExpectString/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectString/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectString/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/ExpectStringSeq/","text":"ExpectStringSeq \u00b6 ( ExpectStringSeq ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Seq [(String)])]","title":"ExpectStringSeq"},{"location":"shards/General/ExpectStringSeq/#expectstringseq","text":"( ExpectStringSeq )","title":"ExpectStringSeq"},{"location":"shards/General/ExpectStringSeq/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectStringSeq/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectStringSeq/#output","text":"Type Description [(Seq [(String)])]","title":"Output"},{"location":"shards/General/ExpectTable/","text":"ExpectTable \u00b6 ( ExpectTable ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Table {})]","title":"ExpectTable"},{"location":"shards/General/ExpectTable/#expecttable","text":"( ExpectTable )","title":"ExpectTable"},{"location":"shards/General/ExpectTable/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectTable/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectTable/#output","text":"Type Description [(Table {})]","title":"Output"},{"location":"shards/General/ExpectWire/","text":"ExpectWire \u00b6 ( ExpectWire ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Wire)]","title":"ExpectWire"},{"location":"shards/General/ExpectWire/#expectwire","text":"( ExpectWire )","title":"ExpectWire"},{"location":"shards/General/ExpectWire/#definition","text":"","title":"Definition"},{"location":"shards/General/ExpectWire/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ExpectWire/#output","text":"Type Description [(Wire)]","title":"Output"},{"location":"shards/General/Fail/","text":"Fail \u00b6 ( Fail ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(None)]","title":"Fail"},{"location":"shards/General/Fail/#fail","text":"( Fail )","title":"Fail"},{"location":"shards/General/Fail/#definition","text":"","title":"Definition"},{"location":"shards/General/Fail/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/Fail/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/General/FillAlpha/","text":"FillAlpha \u00b6 ( FillAlpha ) Definition \u00b6 Input \u00b6 Type Description [(Image)] Output \u00b6 Type Description [(Image)]","title":"FillAlpha"},{"location":"shards/General/FillAlpha/#fillalpha","text":"( FillAlpha )","title":"FillAlpha"},{"location":"shards/General/FillAlpha/#definition","text":"","title":"Definition"},{"location":"shards/General/FillAlpha/#input","text":"Type Description [(Image)]","title":"Input"},{"location":"shards/General/FillAlpha/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/General/Flatten/","text":"Flatten \u00b6 ( Flatten ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Flatten"},{"location":"shards/General/Flatten/#flatten","text":"( Flatten )","title":"Flatten"},{"location":"shards/General/Flatten/#definition","text":"","title":"Definition"},{"location":"shards/General/Flatten/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Flatten/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/FloatsToImage/","text":"FloatsToImage \u00b6 ( FloatsToImage :Width [( Int )] :Height [( Int )] :Channels [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Width [(Int)] 16 The width of the output image. Height [(Int)] 16 The height of the output image. Channels [(Int)] 1 The channels of the output image. Input \u00b6 Type Description [(Seq [(Float)])] Output \u00b6 Type Description [(Image)]","title":"FloatsToImage"},{"location":"shards/General/FloatsToImage/#floatstoimage","text":"( FloatsToImage :Width [( Int )] :Height [( Int )] :Channels [( Int )] )","title":"FloatsToImage"},{"location":"shards/General/FloatsToImage/#definition","text":"","title":"Definition"},{"location":"shards/General/FloatsToImage/#parameters","text":"Name Type Default Description Width [(Int)] 16 The width of the output image. Height [(Int)] 16 The height of the output image. Channels [(Int)] 1 The channels of the output image.","title":"Parameters"},{"location":"shards/General/FloatsToImage/#input","text":"Type Description [(Seq [(Float)])]","title":"Input"},{"location":"shards/General/FloatsToImage/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/General/ForEach/","text":"ForEach \u00b6 ( ForEach :Apply [( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Processes every element or key-value pair of a sequence/table with a given shard or sequence of shards. Parameters \u00b6 Name Type Default Description Apply [(Shard) (Seq [(Shard)])] None The processing logic (in the form of a shard or sequence of shards) to apply to the input sequence/table. Input \u00b6 Type Description [(Seq [(Any)]) (Table [(Any)])] Sequence/table whose elements or key-value pairs need to be processed. Output \u00b6 Type Description [(Seq [(Any)]) (Table [(Any)])] The output from processing the sequence/table elements or key-value pairs. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 ;; ForEach on a sequence: processes every element in seq order [ 2 4 8 10 ] ( ForEach ( -> ( | ( Math.Multiply 10 ) ( Log )) ;; => 20, 40, 80, 100 ( | ( Math.Multiply 100 ) ( Log )) ;; => 200, 400, 800, 1000 )) [info] [2022-08-15 10:09:11.499] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 20 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 200 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 40 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 400 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 80 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 800 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 100 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 1000 Code Output 1 2 3 4 5 6 7 8 9 ;; ForEach on a table: processes every key in alphabetic order { \"Name\" \"Universe\" \"Age\" \"13.8B Yrs\" } ( ForEach ;; receives each key/value pair as a sequence in alphabetic order of key ( -> ( | ( Slice 0 1 1 ) ;; seq => every element starting from 0 till 0 => key of that pair ( Log )) ;; => [\"Age\"], [\"Name\"] ( | ( Slice 1 2 1 ) ;; seq => every element starting from 1 till 1 => value of that pair ( Log )) ;; => [\"13.8 B Yrs\"], [\"Universe\"] )) [info] [2022-08-15 10:09:11.557] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [Age] [info] [2022-08-15 10:09:11.558] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [13.8B Yrs] [info] [2022-08-15 10:09:11.558] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [Name] [info] [2022-08-15 10:09:11.558] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [Universe]","title":"ForEach"},{"location":"shards/General/ForEach/#foreach","text":"( ForEach :Apply [( Shard ) ( Seq [( Shard )])] )","title":"ForEach"},{"location":"shards/General/ForEach/#definition","text":"Processes every element or key-value pair of a sequence/table with a given shard or sequence of shards.","title":"Definition"},{"location":"shards/General/ForEach/#parameters","text":"Name Type Default Description Apply [(Shard) (Seq [(Shard)])] None The processing logic (in the form of a shard or sequence of shards) to apply to the input sequence/table.","title":"Parameters"},{"location":"shards/General/ForEach/#input","text":"Type Description [(Seq [(Any)]) (Table [(Any)])] Sequence/table whose elements or key-value pairs need to be processed.","title":"Input"},{"location":"shards/General/ForEach/#output","text":"Type Description [(Seq [(Any)]) (Table [(Any)])] The output from processing the sequence/table elements or key-value pairs.","title":"Output"},{"location":"shards/General/ForEach/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 ;; ForEach on a sequence: processes every element in seq order [ 2 4 8 10 ] ( ForEach ( -> ( | ( Math.Multiply 10 ) ( Log )) ;; => 20, 40, 80, 100 ( | ( Math.Multiply 100 ) ( Log )) ;; => 200, 400, 800, 1000 )) [info] [2022-08-15 10:09:11.499] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 20 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 200 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 40 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 400 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 80 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 800 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 100 [info] [2022-08-15 10:09:11.500] [T-1880] [logging.cpp::55] [shards/General/ForEach/1.edn] 1000 Code Output 1 2 3 4 5 6 7 8 9 ;; ForEach on a table: processes every key in alphabetic order { \"Name\" \"Universe\" \"Age\" \"13.8B Yrs\" } ( ForEach ;; receives each key/value pair as a sequence in alphabetic order of key ( -> ( | ( Slice 0 1 1 ) ;; seq => every element starting from 0 till 0 => key of that pair ( Log )) ;; => [\"Age\"], [\"Name\"] ( | ( Slice 1 2 1 ) ;; seq => every element starting from 1 till 1 => value of that pair ( Log )) ;; => [\"13.8 B Yrs\"], [\"Universe\"] )) [info] [2022-08-15 10:09:11.557] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [Age] [info] [2022-08-15 10:09:11.558] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [13.8B Yrs] [info] [2022-08-15 10:09:11.558] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [Name] [info] [2022-08-15 10:09:11.558] [T-6724] [logging.cpp::55] [shards/General/ForEach/2.edn] [Universe]","title":"Examples"},{"location":"shards/General/ForRange/","text":"ForRange \u00b6 ( ForRange :From [( Int ) ( ContextVar [( Int )])] :To [( Int ) ( ContextVar [( Int )])] :Action [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Executes a shard while an iteration value is within a range. Parameters \u00b6 Name Type Default Description From [(Int) (ContextVar [(Int)])] 0 The initial iteration value (inclusive). To [(Int) (ContextVar [(Int)])] 1 The final iteration value (inclusive). Action [(Shard) (Seq [(Shard)]) (None)] None The action to perform at each iteration. The current iteration value will be passed as input. Input \u00b6 Type Description [(Any)] The input value is not used and will pass through. Output \u00b6 Type Description [(Any)] The output of this shard will be its input. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 ;; Sum all positive integers below 1000 0 >= .sum ( ForRange 1 999 ( -> ( Math.Add .sum ) > .sum )) .sum ( Assert.Is 499500 true )","title":"ForRange"},{"location":"shards/General/ForRange/#forrange","text":"( ForRange :From [( Int ) ( ContextVar [( Int )])] :To [( Int ) ( ContextVar [( Int )])] :Action [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"ForRange"},{"location":"shards/General/ForRange/#definition","text":"Executes a shard while an iteration value is within a range.","title":"Definition"},{"location":"shards/General/ForRange/#parameters","text":"Name Type Default Description From [(Int) (ContextVar [(Int)])] 0 The initial iteration value (inclusive). To [(Int) (ContextVar [(Int)])] 1 The final iteration value (inclusive). Action [(Shard) (Seq [(Shard)]) (None)] None The action to perform at each iteration. The current iteration value will be passed as input.","title":"Parameters"},{"location":"shards/General/ForRange/#input","text":"Type Description [(Any)] The input value is not used and will pass through.","title":"Input"},{"location":"shards/General/ForRange/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/General/ForRange/#examples","text":"Code Output 1 2 3 4 5 6 7 8 ;; Sum all positive integers below 1000 0 >= .sum ( ForRange 1 999 ( -> ( Math.Add .sum ) > .sum )) .sum ( Assert.Is 499500 true )","title":"Examples"},{"location":"shards/General/FromBase58/","text":"FromBase58 \u00b6 ( FromBase58 ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bytes)]","title":"FromBase58"},{"location":"shards/General/FromBase58/#frombase58","text":"( FromBase58 )","title":"FromBase58"},{"location":"shards/General/FromBase58/#definition","text":"","title":"Definition"},{"location":"shards/General/FromBase58/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/FromBase58/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/FromBase64/","text":"FromBase64 \u00b6 ( FromBase64 ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bytes)]","title":"FromBase64"},{"location":"shards/General/FromBase64/#frombase64","text":"( FromBase64 )","title":"FromBase64"},{"location":"shards/General/FromBase64/#definition","text":"","title":"Definition"},{"location":"shards/General/FromBase64/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/FromBase64/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/FromBytes/","text":"FromBytes \u00b6 ( FromBytes ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Any)]","title":"FromBytes"},{"location":"shards/General/FromBytes/#frombytes","text":"( FromBytes )","title":"FromBytes"},{"location":"shards/General/FromBytes/#definition","text":"","title":"Definition"},{"location":"shards/General/FromBytes/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/General/FromBytes/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/FromJson/","text":"FromJson \u00b6 ( FromJson :Pure [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Pure [(Bool)] true If the input string is generic pure json rather then shards flavored json. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Any)]","title":"FromJson"},{"location":"shards/General/FromJson/#fromjson","text":"( FromJson :Pure [( Bool )] )","title":"FromJson"},{"location":"shards/General/FromJson/#definition","text":"","title":"Definition"},{"location":"shards/General/FromJson/#parameters","text":"Name Type Default Description Pure [(Bool)] true If the input string is generic pure json rather then shards flavored json.","title":"Parameters"},{"location":"shards/General/FromJson/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/FromJson/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/FromLEB128/","text":"FromLEB128 \u00b6 ( FromLEB128 :Signed [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Signed [(Bool)] false If the integer to encode/decode is signed and can be negative. Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Int)]","title":"FromLEB128"},{"location":"shards/General/FromLEB128/#fromleb128","text":"( FromLEB128 :Signed [( Bool )] )","title":"FromLEB128"},{"location":"shards/General/FromLEB128/#definition","text":"","title":"Definition"},{"location":"shards/General/FromLEB128/#parameters","text":"Name Type Default Description Signed [(Bool)] false If the integer to encode/decode is signed and can be negative.","title":"Parameters"},{"location":"shards/General/FromLEB128/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/General/FromLEB128/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/General/Get/","text":"Get \u00b6 ( Get :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Default [( Any )] ) Definition \u00b6 Reads the value of the variable passed to it. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Default [(Any)] None The default value to use to infer types and output if the variable is not set, key is not there and/or type mismatches. Input \u00b6 Type Description [(None)] Any input is ignored. Output \u00b6 Type Description [(Any)] The output is the value read from the variable. Details \u00b6 Get is used read the value of an existing variable. All sorts of variables that can be created by Set , can be read by Get . The :Name parameter should contain the name of the variable that's being read. If the variable is a string/numeric variable or a sequence it will be read directly. But for a table to be read its key should be passed in the parameter :Key . This will allow Get to access the particular key in the table and read it's value. The :Default parameter specifies a value to return in case the variable being read doesn't yeild a valid value, or the sequence is malformed, or the required key is missing from the table, etc. This allows the program to continue processing even if some expected data is missing. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to read. Any input to this shard is ignored and its output contains the value of the variable read by Get . Note Get has an alias ?? . This symbol represents the logical operator OR . Hence, ?? functions as an alias for Get with a default value. For example, .var1 ?? 40 means .var1 or 40 and this is effectively an alias for (Get .var1 :Default 40) . See the code examples at the end to understand how this alias is used. See also Const Ref Sequence Set Table Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ;; create a mutable string variable and get its value \"Hello\" ( Set :Name .svar ) ;; set value ( Get :Name .svar ) >= .gotSvar ;; get value and store it .gotSvar ( Log \"gotten value\" ) ;; => gotten value: Hello ;; create an immutable numeric variable and get its value 100 ( Ref :Name .nvar ) ;; set value ( Get :Name .nvar ) >= .gotNvar ;; modify numeric variable .gotNvar ( Log \"gotten value\" ) ;; => gotten value: 100 ;; create a mutable sequence and get it [ 10 20 30 ] ( Set :Name .sequence ) ( Get .sequence ) ( Log ) ;; => [10, 20, 30] ;; create an empty sequence and try reading it with the :Default failsafe [] ( Set :Name .seqEmpty ) ( Get .seqEmpty :Default \"Void\" ) ( Log ) ;; => Void ;; create a table and get one of it's key-values pairs [ \"a\" \"b\" ] ( Set :Name \"table\" :Key \"key1\" ) ( Get .table :Key \"key1\" ) ( Log ) ;; => [a, b] ;; create a table and try to get a non-existent key-value using the :Default parameter [ \"a\" \"b\" ] ( Set :Name \"table\" :Key \"key1\" ) ( Get .table :Key \"key2\" :Default \"Key missing\" ) ( Log ) ;; => \"Key missing\" ;; Using a `Get` alias ;; `??` is `OR` hence alias for `(Get :Default ...)` ;; try getting a non-existent key-value again [ \"a\" \"b\" ] ( Set :Name .tableA :Key \"key1\" ) ( Get .tableA :Key \"key2\" ) ?? \"Key still missing\" ( Log ) ;; => \"Key still missing\" ;; create mutable local/global variables and get their values \"Local\" ( Set .str ) ;; create local variable \"Global\" ( Set .str :Global true ) ;; create same-name global variable ( Get .str ) ( Log ) ;; get local variable => \"Local\" ( Get .str :Global true ) ( Log ) ;; get same-name global variable => \"Global\" [info] [2022-08-15 10:09:11.672] [T-6516] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::53] [shards/General/Get/Get.edn] gotten value: Hello [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::53] [shards/General/Get/Get.edn] gotten value: 100 [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] [10, 20, 30] [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Void [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] [a, b] [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Key missing [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Key still missing [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Local [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Global","title":"Get"},{"location":"shards/General/Get/#get","text":"( Get :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Default [( Any )] )","title":"Get"},{"location":"shards/General/Get/#definition","text":"Reads the value of the variable passed to it.","title":"Definition"},{"location":"shards/General/Get/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Default [(Any)] None The default value to use to infer types and output if the variable is not set, key is not there and/or type mismatches.","title":"Parameters"},{"location":"shards/General/Get/#input","text":"Type Description [(None)] Any input is ignored.","title":"Input"},{"location":"shards/General/Get/#output","text":"Type Description [(Any)] The output is the value read from the variable.","title":"Output"},{"location":"shards/General/Get/#details","text":"Get is used read the value of an existing variable. All sorts of variables that can be created by Set , can be read by Get . The :Name parameter should contain the name of the variable that's being read. If the variable is a string/numeric variable or a sequence it will be read directly. But for a table to be read its key should be passed in the parameter :Key . This will allow Get to access the particular key in the table and read it's value. The :Default parameter specifies a value to return in case the variable being read doesn't yeild a valid value, or the sequence is malformed, or the required key is missing from the table, etc. This allows the program to continue processing even if some expected data is missing. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to read. Any input to this shard is ignored and its output contains the value of the variable read by Get . Note Get has an alias ?? . This symbol represents the logical operator OR . Hence, ?? functions as an alias for Get with a default value. For example, .var1 ?? 40 means .var1 or 40 and this is effectively an alias for (Get .var1 :Default 40) . See the code examples at the end to understand how this alias is used. See also Const Ref Sequence Set Table","title":"Details"},{"location":"shards/General/Get/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ;; create a mutable string variable and get its value \"Hello\" ( Set :Name .svar ) ;; set value ( Get :Name .svar ) >= .gotSvar ;; get value and store it .gotSvar ( Log \"gotten value\" ) ;; => gotten value: Hello ;; create an immutable numeric variable and get its value 100 ( Ref :Name .nvar ) ;; set value ( Get :Name .nvar ) >= .gotNvar ;; modify numeric variable .gotNvar ( Log \"gotten value\" ) ;; => gotten value: 100 ;; create a mutable sequence and get it [ 10 20 30 ] ( Set :Name .sequence ) ( Get .sequence ) ( Log ) ;; => [10, 20, 30] ;; create an empty sequence and try reading it with the :Default failsafe [] ( Set :Name .seqEmpty ) ( Get .seqEmpty :Default \"Void\" ) ( Log ) ;; => Void ;; create a table and get one of it's key-values pairs [ \"a\" \"b\" ] ( Set :Name \"table\" :Key \"key1\" ) ( Get .table :Key \"key1\" ) ( Log ) ;; => [a, b] ;; create a table and try to get a non-existent key-value using the :Default parameter [ \"a\" \"b\" ] ( Set :Name \"table\" :Key \"key1\" ) ( Get .table :Key \"key2\" :Default \"Key missing\" ) ( Log ) ;; => \"Key missing\" ;; Using a `Get` alias ;; `??` is `OR` hence alias for `(Get :Default ...)` ;; try getting a non-existent key-value again [ \"a\" \"b\" ] ( Set :Name .tableA :Key \"key1\" ) ( Get .tableA :Key \"key2\" ) ?? \"Key still missing\" ( Log ) ;; => \"Key still missing\" ;; create mutable local/global variables and get their values \"Local\" ( Set .str ) ;; create local variable \"Global\" ( Set .str :Global true ) ;; create same-name global variable ( Get .str ) ( Log ) ;; get local variable => \"Local\" ( Get .str :Global true ) ( Log ) ;; get same-name global variable => \"Global\" [info] [2022-08-15 10:09:11.672] [T-6516] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::53] [shards/General/Get/Get.edn] gotten value: Hello [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::53] [shards/General/Get/Get.edn] gotten value: 100 [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] [10, 20, 30] [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Void [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] [a, b] [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Key missing [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Key still missing [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Local [info] [2022-08-15 10:09:11.673] [T-6516] [logging.cpp::55] [shards/General/Get/Get.edn] Global","title":"Examples"},{"location":"shards/General/Hash/","text":"Hash \u00b6 ( Hash ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Int2)]","title":"Hash"},{"location":"shards/General/Hash/#hash","text":"( Hash )","title":"Hash"},{"location":"shards/General/Hash/#definition","text":"","title":"Definition"},{"location":"shards/General/Hash/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Hash/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/General/Hashed/","text":"Hashed \u00b6 ( Hashed :Shards [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Hashes the output of a shard or of a sequence of shards. Parameters \u00b6 Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to execute in the hashed flow. Input \u00b6 Type Description [(Any)] The value passed to the first shard in the hashed sequence. Output \u00b6 Type Description [(Any)] The hash of the output of the last shard in the hashed sequence. Details \u00b6 (Hashed) takes a single shard or a sequence of shards and hashes the output of the last shard (or the only shard) in this sequence. So this shard can be used to group together certain shards when you want their final output to be hashed. (Hashed) uses (->) to group multiple shards. The input to (Hashed) becomes input to the first shard in the hashed sequence and the output of this shard becomes the input for the next shard in the hashed sequence (following the regular Shards data flow pattern). Note (Hashed) has an alias (|#) which is more convenient to use. |# also removes the need to use (->) as, unlike (Hashed) , it doesn't require the parameter shards to be grouped together. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; Hashed sequence of shards (using keyword `Hashed`) ( int 5 ) ( Log \"input to Hashed shards sequence\" ) ;; => 5 ( Hashed ( -> ( Math.Multiply 2 ) ;; shard1 ( Log \"output from shard1\" ) ;; => 10 ( Math.Multiply 2 ) ;; shard2 ( Log \"output from shard2\" ) ;; => 20 ( Math.Multiply 2 ) ;; shard3 ( Log \"output from shard3\" ) ;; => 40 )) ( Log \"last shard output, hashed\" ) ;; => {Hash: (1005568994776713365, 558560013916990142), Result: 40} [info] [2022-08-15 10:09:11.732] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] input to Hashed shards sequence: 5 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] output from shard1: 10 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] output from shard2: 20 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] output from shard3: 40 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] last shard output, hashed: {Hash: (4701209066045399993, 8148186447390729919), Result: 40} Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ;; Hashed sequence of shards (using alias `|#`) ( int 5 ) ( Log \"input to Hashed shards sequence\" ) ;; => 5 ( |# ( Math.Multiply 2 ) ;; shard1 ( Log \"output from shard1\" ) ;; => 10 ( Math.Multiply 2 ) ;; shard2 ( Log \"output from shard2\" ) ;; => 20 ( Math.Multiply 2 ) ;; shard3 ( Log \"output from shard3\" ) ;; => 40 ) ( Log \"last shard output, hashed\" ) ;; => {Hash: (1005568994776713365, 558560013916990142), Result: 40} [info] [2022-08-15 10:09:11.791] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] input to Hashed shards sequence: 5 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] output from shard1: 10 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] output from shard2: 20 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] output from shard3: 40 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] last shard output, hashed: {Hash: (4701209066045399993, 8148186447390729919), Result: 40}","title":"Hashed"},{"location":"shards/General/Hashed/#hashed","text":"( Hashed :Shards [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Hashed"},{"location":"shards/General/Hashed/#definition","text":"Hashes the output of a shard or of a sequence of shards.","title":"Definition"},{"location":"shards/General/Hashed/#parameters","text":"Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to execute in the hashed flow.","title":"Parameters"},{"location":"shards/General/Hashed/#input","text":"Type Description [(Any)] The value passed to the first shard in the hashed sequence.","title":"Input"},{"location":"shards/General/Hashed/#output","text":"Type Description [(Any)] The hash of the output of the last shard in the hashed sequence.","title":"Output"},{"location":"shards/General/Hashed/#details","text":"(Hashed) takes a single shard or a sequence of shards and hashes the output of the last shard (or the only shard) in this sequence. So this shard can be used to group together certain shards when you want their final output to be hashed. (Hashed) uses (->) to group multiple shards. The input to (Hashed) becomes input to the first shard in the hashed sequence and the output of this shard becomes the input for the next shard in the hashed sequence (following the regular Shards data flow pattern). Note (Hashed) has an alias (|#) which is more convenient to use. |# also removes the need to use (->) as, unlike (Hashed) , it doesn't require the parameter shards to be grouped together.","title":"Details"},{"location":"shards/General/Hashed/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; Hashed sequence of shards (using keyword `Hashed`) ( int 5 ) ( Log \"input to Hashed shards sequence\" ) ;; => 5 ( Hashed ( -> ( Math.Multiply 2 ) ;; shard1 ( Log \"output from shard1\" ) ;; => 10 ( Math.Multiply 2 ) ;; shard2 ( Log \"output from shard2\" ) ;; => 20 ( Math.Multiply 2 ) ;; shard3 ( Log \"output from shard3\" ) ;; => 40 )) ( Log \"last shard output, hashed\" ) ;; => {Hash: (1005568994776713365, 558560013916990142), Result: 40} [info] [2022-08-15 10:09:11.732] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] input to Hashed shards sequence: 5 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] output from shard1: 10 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] output from shard2: 20 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] output from shard3: 40 [info] [2022-08-15 10:09:11.733] [T-6652] [logging.cpp::53] [shards/General/Hashed/1.edn] last shard output, hashed: {Hash: (4701209066045399993, 8148186447390729919), Result: 40} Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ;; Hashed sequence of shards (using alias `|#`) ( int 5 ) ( Log \"input to Hashed shards sequence\" ) ;; => 5 ( |# ( Math.Multiply 2 ) ;; shard1 ( Log \"output from shard1\" ) ;; => 10 ( Math.Multiply 2 ) ;; shard2 ( Log \"output from shard2\" ) ;; => 20 ( Math.Multiply 2 ) ;; shard3 ( Log \"output from shard3\" ) ;; => 40 ) ( Log \"last shard output, hashed\" ) ;; => {Hash: (1005568994776713365, 558560013916990142), Result: 40} [info] [2022-08-15 10:09:11.791] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] input to Hashed shards sequence: 5 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] output from shard1: 10 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] output from shard2: 20 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] output from shard3: 40 [info] [2022-08-15 10:09:11.792] [T-1064] [logging.cpp::53] [shards/General/Hashed/2.edn] last shard output, hashed: {Hash: (4701209066045399993, 8148186447390729919), Result: 40}","title":"Examples"},{"location":"shards/General/HexToBytes/","text":"HexToBytes \u00b6 ( HexToBytes ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bytes)]","title":"HexToBytes"},{"location":"shards/General/HexToBytes/#hextobytes","text":"( HexToBytes )","title":"HexToBytes"},{"location":"shards/General/HexToBytes/#definition","text":"","title":"Definition"},{"location":"shards/General/HexToBytes/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/HexToBytes/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/If/","text":"If \u00b6 ( If :Predicate [( Shard ) ( Seq [( Shard )]) ( None )] :Then [( Shard ) ( Seq [( Shard )]) ( None )] :Else [( Shard ) ( Seq [( Shard )]) ( None )] :Passthrough [( Bool )] ) Definition \u00b6 Evaluates a predicate and executes an action. Parameters \u00b6 Name Type Default Description Predicate [(Shard) (Seq [(Shard)]) (None)] None The predicate to evaluate in order to trigger Then (when true ) or Else (when false ). Then [(Shard) (Seq [(Shard)]) (None)] None The shards to activate when Predicate is true . Else [(Shard) (Seq [(Shard)]) (None)] None The shards to activate when Predicate is false . Passthrough [(Bool)] false The output of this shard will be its input. Input \u00b6 Type Description [(Any)] The value that will be passed to the predicate. Output \u00b6 Type Description [(Any)] The input of the shard if Passthrough is true ; otherwise, the output of the action that was performed (i.e. Then or Else ). Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 5 ( If ;:Predicate ( IsLess 2 ) ;:Then ( Msg \"lesser than 2\" ) ;:Else ( Msg \"equal or greater than 2\" )) [info] [2022-08-15 10:09:11.854] [T-7088] [logging.cpp::98] [shards/General/If/If.edn] equal or greater than 2","title":"If"},{"location":"shards/General/If/#if","text":"( If :Predicate [( Shard ) ( Seq [( Shard )]) ( None )] :Then [( Shard ) ( Seq [( Shard )]) ( None )] :Else [( Shard ) ( Seq [( Shard )]) ( None )] :Passthrough [( Bool )] )","title":"If"},{"location":"shards/General/If/#definition","text":"Evaluates a predicate and executes an action.","title":"Definition"},{"location":"shards/General/If/#parameters","text":"Name Type Default Description Predicate [(Shard) (Seq [(Shard)]) (None)] None The predicate to evaluate in order to trigger Then (when true ) or Else (when false ). Then [(Shard) (Seq [(Shard)]) (None)] None The shards to activate when Predicate is true . Else [(Shard) (Seq [(Shard)]) (None)] None The shards to activate when Predicate is false . Passthrough [(Bool)] false The output of this shard will be its input.","title":"Parameters"},{"location":"shards/General/If/#input","text":"Type Description [(Any)] The value that will be passed to the predicate.","title":"Input"},{"location":"shards/General/If/#output","text":"Type Description [(Any)] The input of the shard if Passthrough is true ; otherwise, the output of the action that was performed (i.e. Then or Else ).","title":"Output"},{"location":"shards/General/If/#examples","text":"Code Output 1 2 3 4 5 6 7 8 5 ( If ;:Predicate ( IsLess 2 ) ;:Then ( Msg \"lesser than 2\" ) ;:Else ( Msg \"equal or greater than 2\" )) [info] [2022-08-15 10:09:11.854] [T-7088] [logging.cpp::98] [shards/General/If/If.edn] equal or greater than 2","title":"Examples"},{"location":"shards/General/ImageToFloats/","text":"ImageToFloats \u00b6 ( ImageToFloats ) Definition \u00b6 Input \u00b6 Type Description [(Image)] Output \u00b6 Type Description [(Seq [(Float)])]","title":"ImageToFloats"},{"location":"shards/General/ImageToFloats/#imagetofloats","text":"( ImageToFloats )","title":"ImageToFloats"},{"location":"shards/General/ImageToFloats/#definition","text":"","title":"Definition"},{"location":"shards/General/ImageToFloats/#input","text":"Type Description [(Image)]","title":"Input"},{"location":"shards/General/ImageToFloats/#output","text":"Type Description [(Seq [(Float)])]","title":"Output"},{"location":"shards/General/IndexOf/","text":"IndexOf \u00b6 ( IndexOf :Item [( Any )] :All [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Item [(Any)] None The item to find the index of from the input, if it's a sequence it will try to match all the items in the sequence, in sequence. All [(Bool)] false If true will return a sequence with all the indices of Item, empty sequence if not found. Input \u00b6 Type Description [(Seq [(Any)])] Output \u00b6 Type Description [(Int)]","title":"IndexOf"},{"location":"shards/General/IndexOf/#indexof","text":"( IndexOf :Item [( Any )] :All [( Bool )] )","title":"IndexOf"},{"location":"shards/General/IndexOf/#definition","text":"","title":"Definition"},{"location":"shards/General/IndexOf/#parameters","text":"Name Type Default Description Item [(Any)] None The item to find the index of from the input, if it's a sequence it will try to match all the items in the sequence, in sequence. All [(Bool)] false If true will return a sequence with all the indices of Item, empty sequence if not found.","title":"Parameters"},{"location":"shards/General/IndexOf/#input","text":"Type Description [(Seq [(Any)])]","title":"Input"},{"location":"shards/General/IndexOf/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/General/Input/","text":"Input \u00b6 ( Input ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Any)]","title":"Input"},{"location":"shards/General/Input/#input","text":"( Input )","title":"Input"},{"location":"shards/General/Input/#definition","text":"","title":"Definition"},{"location":"shards/General/Input/#input_1","text":"Type Description [(None)]","title":"Input"},{"location":"shards/General/Input/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/IntsToBytes/","text":"IntsToBytes \u00b6 ( IntsToBytes ) Definition \u00b6 Input \u00b6 Type Description [(Seq [(Int)])] Output \u00b6 Type Description [(Bytes)]","title":"IntsToBytes"},{"location":"shards/General/IntsToBytes/#intstobytes","text":"( IntsToBytes )","title":"IntsToBytes"},{"location":"shards/General/IntsToBytes/#definition","text":"","title":"Definition"},{"location":"shards/General/IntsToBytes/#input","text":"Type Description [(Seq [(Int)])]","title":"Input"},{"location":"shards/General/IntsToBytes/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/Is/","text":"Is \u00b6 ( Is :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)] Details \u00b6 This shard compares the input to its :Value parameter and outputs true if they are equal or same, else outputs false . If the input and :Value parameter have different data types they will be assessed as inequal by default even if they are numerically equal (for example int 5 is not equal to float 5.0 ). Note that for two sequences to be considered equal or identical they must both contain the same elements and in the same order. For two tables to be considered equal/identical they must both contain the same key/value pairs but the order of these pairs is irrelevant. See also IsNot Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ;; string comparison \"hello\" ( String.ToUpper ) ( Is \"HELLO\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( Math.Add 3 ) ( Is 5 ) ( Assert.Is true :Abort true ) ;; float comparison 4.0 ( Is ( + 1.0 3.0 )) ( Assert.Is true :Abort true ) ;; sequence comparison [ 1 2 3 ] ( Is [ 1 2 3 ]) ( Assert.Is true :Abort true ) ;; table comparison 1 { :key1 [ 10 20 ] :key2 [ 30 ]} ( Is { :key1 [ 10 20 ] :key2 [ 30 ]}) ( Assert.Is true :Abort true ) ;; table comparison 2 { :key2 [ 30 ] :key1 [ 10 20 ]} ( Is { :key1 [ 10 20 ] :key2 [ 30 ]}) ( Assert.Is true :Abort true )","title":"Is"},{"location":"shards/General/Is/#is","text":"( Is :Value [( Any )] )","title":"Is"},{"location":"shards/General/Is/#definition","text":"","title":"Definition"},{"location":"shards/General/Is/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/Is/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Is/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/Is/#details","text":"This shard compares the input to its :Value parameter and outputs true if they are equal or same, else outputs false . If the input and :Value parameter have different data types they will be assessed as inequal by default even if they are numerically equal (for example int 5 is not equal to float 5.0 ). Note that for two sequences to be considered equal or identical they must both contain the same elements and in the same order. For two tables to be considered equal/identical they must both contain the same key/value pairs but the order of these pairs is irrelevant. See also IsNot","title":"Details"},{"location":"shards/General/Is/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ;; string comparison \"hello\" ( String.ToUpper ) ( Is \"HELLO\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( Math.Add 3 ) ( Is 5 ) ( Assert.Is true :Abort true ) ;; float comparison 4.0 ( Is ( + 1.0 3.0 )) ( Assert.Is true :Abort true ) ;; sequence comparison [ 1 2 3 ] ( Is [ 1 2 3 ]) ( Assert.Is true :Abort true ) ;; table comparison 1 { :key1 [ 10 20 ] :key2 [ 30 ]} ( Is { :key1 [ 10 20 ] :key2 [ 30 ]}) ( Assert.Is true :Abort true ) ;; table comparison 2 { :key2 [ 30 ] :key1 [ 10 20 ]} ( Is { :key1 [ 10 20 ] :key2 [ 30 ]}) ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/IsLess/","text":"IsLess \u00b6 ( IsLess :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)] Details \u00b6 This shard compares the input to its :Value parameter and outputs true if the input value is less than the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLessEqual IsMore IsMoreEqual Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"a\" ( IsLess \"z\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( IsLess 5 ) ( Assert.Is true :Abort true ) ;; float comparison 2.0 ( IsLess ( + 1.0 3.0 )) ( Assert.Is true :Abort true )","title":"IsLess"},{"location":"shards/General/IsLess/#isless","text":"( IsLess :Value [( Any )] )","title":"IsLess"},{"location":"shards/General/IsLess/#definition","text":"","title":"Definition"},{"location":"shards/General/IsLess/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/IsLess/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/IsLess/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/IsLess/#details","text":"This shard compares the input to its :Value parameter and outputs true if the input value is less than the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLessEqual IsMore IsMoreEqual","title":"Details"},{"location":"shards/General/IsLess/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"a\" ( IsLess \"z\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( IsLess 5 ) ( Assert.Is true :Abort true ) ;; float comparison 2.0 ( IsLess ( + 1.0 3.0 )) ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/IsLessEqual/","text":"IsLessEqual \u00b6 ( IsLessEqual :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)] Details \u00b6 This shard compares the input to its :Value parameter and outputs true if the input value is less than or equal to the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLess IsMore IsMoreEqual Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"a\" ( IsLessEqual \"z\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( IsLessEqual 5 ) ( Assert.Is true :Abort true ) ;; float comparison 4.0 ( IsLessEqual ( + 1.0 3.0 )) ( Assert.Is true :Abort true )","title":"IsLessEqual"},{"location":"shards/General/IsLessEqual/#islessequal","text":"( IsLessEqual :Value [( Any )] )","title":"IsLessEqual"},{"location":"shards/General/IsLessEqual/#definition","text":"","title":"Definition"},{"location":"shards/General/IsLessEqual/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/IsLessEqual/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/IsLessEqual/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/IsLessEqual/#details","text":"This shard compares the input to its :Value parameter and outputs true if the input value is less than or equal to the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLess IsMore IsMoreEqual","title":"Details"},{"location":"shards/General/IsLessEqual/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"a\" ( IsLessEqual \"z\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( IsLessEqual 5 ) ( Assert.Is true :Abort true ) ;; float comparison 4.0 ( IsLessEqual ( + 1.0 3.0 )) ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/IsMore/","text":"IsMore \u00b6 ( IsMore :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)] Details \u00b6 This shard compares the input to its :Value parameter and outputs true if the input value is more than the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLess IsLessEqual IsMoreEqual Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"z\" ( IsMore \"a\" ) ( Assert.Is true :Abort true ) ;; integer comparison 5 ( IsMore 2 ) ( Assert.Is true :Abort true ) ;; float comparison 5.0 ( IsMore ( + 1.0 3.0 )) ( Assert.Is true :Abort true )","title":"IsMore"},{"location":"shards/General/IsMore/#ismore","text":"( IsMore :Value [( Any )] )","title":"IsMore"},{"location":"shards/General/IsMore/#definition","text":"","title":"Definition"},{"location":"shards/General/IsMore/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/IsMore/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/IsMore/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/IsMore/#details","text":"This shard compares the input to its :Value parameter and outputs true if the input value is more than the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLess IsLessEqual IsMoreEqual","title":"Details"},{"location":"shards/General/IsMore/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"z\" ( IsMore \"a\" ) ( Assert.Is true :Abort true ) ;; integer comparison 5 ( IsMore 2 ) ( Assert.Is true :Abort true ) ;; float comparison 5.0 ( IsMore ( + 1.0 3.0 )) ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/IsMoreEqual/","text":"IsMoreEqual \u00b6 ( IsMoreEqual :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)] Details \u00b6 This shard compares the input to its :Value parameter and outputs true if the input value is more than or equal to the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLess IsLessEqual IsMore Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"z\" ( IsMoreEqual \"a\" ) ( Assert.Is true :Abort true ) ;; integer comparison 5 ( IsMoreEqual 2 ) ( Assert.Is true :Abort true ) ;; float comparison 9.0 ( IsMoreEqual ( + 1.0 1.0 )) ( Assert.Is true :Abort true )","title":"IsMoreEqual"},{"location":"shards/General/IsMoreEqual/#ismoreequal","text":"( IsMoreEqual :Value [( Any )] )","title":"IsMoreEqual"},{"location":"shards/General/IsMoreEqual/#definition","text":"","title":"Definition"},{"location":"shards/General/IsMoreEqual/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/IsMoreEqual/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/IsMoreEqual/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/IsMoreEqual/#details","text":"This shard compares the input to its :Value parameter and outputs true if the input value is more than or equal to the value of its :Value parameter, else it outputs false . For a valid comparison, the input and :Value parameter must have identical data types. A comparison across different data types will throw a validation error. This shard can be used to compare simple data types like stings, integers, floats, etc. However, complex data types like sequences or tables cannot be meaningfully compared for the lesser-than/greater-than attribute. Using this shard on such complex data types will give unexpected and meaningless results. See also IsLess IsLessEqual IsMore","title":"Details"},{"location":"shards/General/IsMoreEqual/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; string comparison \"z\" ( IsMoreEqual \"a\" ) ( Assert.Is true :Abort true ) ;; integer comparison 5 ( IsMoreEqual 2 ) ( Assert.Is true :Abort true ) ;; float comparison 9.0 ( IsMoreEqual ( + 1.0 1.0 )) ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/IsNone/","text":"IsNone \u00b6 ( IsNone ) Definition \u00b6 Gets whether the type of the input is None . Input \u00b6 Type Description [(Any)] The value which type to check against. Output \u00b6 Type Description [(Bool)] true is the type of input is None ; otherwise, false .","title":"IsNone"},{"location":"shards/General/IsNone/#isnone","text":"( IsNone )","title":"IsNone"},{"location":"shards/General/IsNone/#definition","text":"Gets whether the type of the input is None .","title":"Definition"},{"location":"shards/General/IsNone/#input","text":"Type Description [(Any)] The value which type to check against.","title":"Input"},{"location":"shards/General/IsNone/#output","text":"Type Description [(Bool)] true is the type of input is None ; otherwise, false .","title":"Output"},{"location":"shards/General/IsNot/","text":"IsNot \u00b6 ( IsNot :Value [( Any )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Value [(Any)] None The value to test against for equality. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bool)] Details \u00b6 This shard compares the input to its :Value parameter and outputs true if they are different, else outputs false . If the input and :Value parameter have different data types they will be assessed as inequal by default even if they are numerically equal (for example int 5 is not equal to float 5.0 ). See also Is Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; string comparison \"hello\" ( IsNot \"HELLO\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( Math.Add 3 ) ( IsNot 4 ) ( Assert.Is true :Abort true ) ;; integer/float comparison 4 ( IsNot ( + 1.0 3.0 )) ( Assert.Is true :Abort true ) ;; string/integer comparison \"Shards\" ( IsNot 122 ) ( Assert.Is true :Abort true ) ;; sequence comparison [ 1 2 3 ] ( IsNot [ 1 3 ]) ( Assert.Is true :Abort true ) ;; table comparison { :key3 [ 10 20 ] :key2 [ 30 ]} ( IsNot { :key1 [ 10 20 ] :key2 [ 30 ]}) ( Assert.Is true :Abort true ) ;; sequence/table comparison [ 1 2 3 ] ( IsNot { :key1 [ 1 2 ] :key2 [ 3 ]}) ( Assert.Is true :Abort true )","title":"IsNot"},{"location":"shards/General/IsNot/#isnot","text":"( IsNot :Value [( Any )] )","title":"IsNot"},{"location":"shards/General/IsNot/#definition","text":"","title":"Definition"},{"location":"shards/General/IsNot/#parameters","text":"Name Type Default Description Value [(Any)] None The value to test against for equality.","title":"Parameters"},{"location":"shards/General/IsNot/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/IsNot/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/IsNot/#details","text":"This shard compares the input to its :Value parameter and outputs true if they are different, else outputs false . If the input and :Value parameter have different data types they will be assessed as inequal by default even if they are numerically equal (for example int 5 is not equal to float 5.0 ). See also Is","title":"Details"},{"location":"shards/General/IsNot/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ;; string comparison \"hello\" ( IsNot \"HELLO\" ) ( Assert.Is true :Abort true ) ;; integer comparison 2 ( Math.Add 3 ) ( IsNot 4 ) ( Assert.Is true :Abort true ) ;; integer/float comparison 4 ( IsNot ( + 1.0 3.0 )) ( Assert.Is true :Abort true ) ;; string/integer comparison \"Shards\" ( IsNot 122 ) ( Assert.Is true :Abort true ) ;; sequence comparison [ 1 2 3 ] ( IsNot [ 1 3 ]) ( Assert.Is true :Abort true ) ;; table comparison { :key3 [ 10 20 ] :key2 [ 30 ]} ( IsNot { :key1 [ 10 20 ] :key2 [ 30 ]}) ( Assert.Is true :Abort true ) ;; sequence/table comparison [ 1 2 3 ] ( IsNot { :key1 [ 1 2 ] :key2 [ 3 ]}) ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/IsNotNone/","text":"IsNotNone \u00b6 ( IsNotNone ) Definition \u00b6 Gets whether the type of the input is different from None . Input \u00b6 Type Description [(Any)] The value which type to check against. Output \u00b6 Type Description [(Bool)] true is the type of input different from None ; otherwise, false .","title":"IsNotNone"},{"location":"shards/General/IsNotNone/#isnotnone","text":"( IsNotNone )","title":"IsNotNone"},{"location":"shards/General/IsNotNone/#definition","text":"Gets whether the type of the input is different from None .","title":"Definition"},{"location":"shards/General/IsNotNone/#input","text":"Type Description [(Any)] The value which type to check against.","title":"Input"},{"location":"shards/General/IsNotNone/#output","text":"Type Description [(Bool)] true is the type of input different from None ; otherwise, false .","title":"Output"},{"location":"shards/General/IsValidNumber/","text":"IsValidNumber \u00b6 ( IsValidNumber ) Definition \u00b6 Input \u00b6 Type Description [(Float)] Output \u00b6 Type Description [(Bool)]","title":"IsValidNumber"},{"location":"shards/General/IsValidNumber/#isvalidnumber","text":"( IsValidNumber )","title":"IsValidNumber"},{"location":"shards/General/IsValidNumber/#definition","text":"","title":"Definition"},{"location":"shards/General/IsValidNumber/#input","text":"Type Description [(Float)]","title":"Input"},{"location":"shards/General/IsValidNumber/#output","text":"Type Description [(Bool)]","title":"Output"},{"location":"shards/General/Limit/","text":"Limit \u00b6 ( Limit :Max [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Max [(Int)] 0 How many maximum elements to take from the input sequence. Input \u00b6 Type Description [(Seq [(Any)])] Output \u00b6 Type Description [(Any)]","title":"Limit"},{"location":"shards/General/Limit/#limit","text":"( Limit :Max [( Int )] )","title":"Limit"},{"location":"shards/General/Limit/#definition","text":"","title":"Definition"},{"location":"shards/General/Limit/#parameters","text":"Name Type Default Description Max [(Int)] 0 How many maximum elements to take from the input sequence.","title":"Parameters"},{"location":"shards/General/Limit/#input","text":"Type Description [(Seq [(Any)])]","title":"Input"},{"location":"shards/General/Limit/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Listen/","text":"Listen \u00b6 ( Listen :Name [( String )] :Buffer [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the channel. Buffer [(Int)] 1 The amount of values to buffer before outputting them. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Listen"},{"location":"shards/General/Listen/#listen","text":"( Listen :Name [( String )] :Buffer [( Int )] )","title":"Listen"},{"location":"shards/General/Listen/#definition","text":"","title":"Definition"},{"location":"shards/General/Listen/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the channel. Buffer [(Int)] 1 The amount of values to buffer before outputting them.","title":"Parameters"},{"location":"shards/General/Listen/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Listen/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/LoadImage/","text":"LoadImage \u00b6 ( LoadImage :File [( String ) ( ContextVar [( String )]) ( None )] :BPP [( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from. BPP [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x69627070 bits per pixel (HDR images loading and such!) Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Image)]","title":"LoadImage"},{"location":"shards/General/LoadImage/#loadimage","text":"( LoadImage :File [( String ) ( ContextVar [( String )]) ( None )] :BPP [( Enum )] )","title":"LoadImage"},{"location":"shards/General/LoadImage/#definition","text":"","title":"Definition"},{"location":"shards/General/LoadImage/#parameters","text":"Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from. BPP [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x69627070 bits per pixel (HDR images loading and such!)","title":"Parameters"},{"location":"shards/General/LoadImage/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/General/LoadImage/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/General/Log/","text":"Log \u00b6 ( Log :Prefix [( String )] ) Definition \u00b6 Logs the output of a shard or the value of a variable to the console (along with an optional prefix string). Parameters \u00b6 Name Type Default Description Prefix [(String)] \"\" The message to prefix to the logged output. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Details \u00b6 This shard is used for printing information to the console for debugging purposes. It can log the output of a shard or the value of a variable. It can also prefix a message string to the logged output while displaying it in the console. Examples \u00b6 Code Output 1 2 3 4 \"I am a var\" = .var ( * 2 4 ) ( Log ) ;; log previous shard output .var ( Log ) ;; log a variable value ( + 3 9 ) ( Log :Prefix \"String\" ) ;; prefix a string to the logged output [info] [2022-08-15 10:09:12.256] [T-6520] [logging.cpp::55] [shards/General/Log/1.edn] 8 [info] [2022-08-15 10:09:12.256] [T-6520] [logging.cpp::55] [shards/General/Log/1.edn] I am a var [info] [2022-08-15 10:09:12.256] [T-6520] [logging.cpp::53] [shards/General/Log/1.edn] String: 12","title":"Log"},{"location":"shards/General/Log/#log","text":"( Log :Prefix [( String )] )","title":"Log"},{"location":"shards/General/Log/#definition","text":"Logs the output of a shard or the value of a variable to the console (along with an optional prefix string).","title":"Definition"},{"location":"shards/General/Log/#parameters","text":"Name Type Default Description Prefix [(String)] \"\" The message to prefix to the logged output.","title":"Parameters"},{"location":"shards/General/Log/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Log/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Log/#details","text":"This shard is used for printing information to the console for debugging purposes. It can log the output of a shard or the value of a variable. It can also prefix a message string to the logged output while displaying it in the console.","title":"Details"},{"location":"shards/General/Log/#examples","text":"Code Output 1 2 3 4 \"I am a var\" = .var ( * 2 4 ) ( Log ) ;; log previous shard output .var ( Log ) ;; log a variable value ( + 3 9 ) ( Log :Prefix \"String\" ) ;; prefix a string to the logged output [info] [2022-08-15 10:09:12.256] [T-6520] [logging.cpp::55] [shards/General/Log/1.edn] 8 [info] [2022-08-15 10:09:12.256] [T-6520] [logging.cpp::55] [shards/General/Log/1.edn] I am a var [info] [2022-08-15 10:09:12.256] [T-6520] [logging.cpp::53] [shards/General/Log/1.edn] String: 12","title":"Examples"},{"location":"shards/General/Map/","text":"Map \u00b6 ( Map :Apply [( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Apply [(Shard) (Seq [(Shard)])] None The function to apply to each item of the sequence. Input \u00b6 Type Description [(Seq [(Any)])] Output \u00b6 Type Description [(Seq [(Any)])]","title":"Map"},{"location":"shards/General/Map/#map","text":"( Map :Apply [( Shard ) ( Seq [( Shard )])] )","title":"Map"},{"location":"shards/General/Map/#definition","text":"","title":"Definition"},{"location":"shards/General/Map/#parameters","text":"Name Type Default Description Apply [(Shard) (Seq [(Shard)])] None The function to apply to each item of the sequence.","title":"Parameters"},{"location":"shards/General/Map/#input","text":"Type Description [(Seq [(Any)])]","title":"Input"},{"location":"shards/General/Map/#output","text":"Type Description [(Seq [(Any)])]","title":"Output"},{"location":"shards/General/Match/","text":"Match \u00b6 ( Match :Cases [( Seq [( Any )])] :Passthrough [( Bool )] ) Definition \u00b6 Compares the input with the declared cases (in order of the declaration) and activates the shard of the first matched case. Parameters \u00b6 Name Type Default Description Cases [(Seq [(Any)])] [] Values to match against the input. A nil case will match anything. Passthrough [(Bool)] true Parameter to control the shard's output. true allows the Match shard's input itself to appear as its output; false allows the matched shard's output to appear as Match shard's output. Input \u00b6 Type Description [(Any)] The value that's compared with the declared cases. Output \u00b6 Type Description [(Any)] Same value as input if :Passthrough is true else the output of the matched case's shard if :Passthrough is false . Details \u00b6 Match compares its input with every case declared via the :Cases parameter (in the order of their declaration) till a match is found. Once a match is found the shard of that matched case is activated/executed and Match execution stops. All subsequent cases (even matching ones) are ignored. A nil case matches with everything. So it's a good practice to declare a nil case at the end of :Cases to execute some default logic if no valid matches exist for a given input. If you do not have a nil case then a non-matching input to Match will fail the shard. A note on :Passthrough \u00b6 The :Passthrough parameter can control the final output of the shard it applies to. Setting this parameter to true allows the original input of shard to passthrough as its output as well. If this paramter is set to false , passthrough is suppressed and then the output of the shard is the actual computed value coming out from the shard execution. For Match , this parameter when set to true will allow the original input (the one that was used to match against every case in the shard) to appear again its final output (irrespective of the case match results). Setting :Passthrough to false will enable the matched case's shard output to appear as the output of Match . However, for :Passthrough to work correctly, the data types of the shard input and the shard's case outputs must match. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 ;; single match + nil match at end + no passthrough 1 ( Match [ 2 ( -> \"Matched 2\" ) ;; case processed, match not found 1 ( -> \"Matched 1\" ) ;; case processed, match found 3 ( -> \"Matched 3\" ) ;; case ignored nil ( -> \"Matched nil\" )] ;; case ignored :Passthrough false ) ;; no passthrough -- ( Assert.Is \"Matched 1\" true ) ;; -- so matched case's output becomes `Match` shard's output Code Output 1 2 3 4 5 6 7 8 9 ;; multiple matches + nil match at end + no passthrough 1 ( Match [ ( + 0 1 ) ( -> \"Matched 1a\" ) ;; case processed, match found 1 ( -> \"Matched 1\" ) ;; case ignored 2 ( -> \"Matched 2\" ) ;; case ignored nil ( -> \"Matched nil\" )] ;; case ignored :Passthrough false ) ;; no passthrough -- ( Assert.Is \"Matched 1a\" true ) ;; -- so matched case's output becomes `Match` shard's output Code Output 1 2 3 4 5 6 7 8 9 ;; multiple matches + nil match at start + with passthrough 1 ( Match [ nil ( -> ( Msg \"Matched nil\" )) ;; case processed, match found 1 ( -> ( Msg \"Matched 1\" )) ;; case ignored ( + 0 1 ) ( -> ( Msg \"Matched 1a\" )) ;; case ignored 2 ( -> ( Msg \"Matched 2\" ))] ;; case ignored :Passthrough true ) ;; passthrough -- ( Assert.Is 1 true ) ;; -- so input to `Match` is also its output [info] [2022-08-15 10:09:12.427] [T-3524] [logging.cpp::98] [shards/General/Match/3.edn] Matched nil Code Output 1 2 3 4 5 6 7 8 ;; no matches + nil match in the middle + with passthrough 1 ( Match [ 2 ( -> ( Msg \"Matched 2\" )) ;; case processed, match not found nil ( -> ( Msg \"Matched nil\" )) ;; case processed, match found 3 ( -> ( Msg \"Matched 3\" ))] ;; case ignored :Passthrough true ) ;; passthrough -- ( Assert.Is 1 true ) ;; -- so input to `Match` is also its output [info] [2022-08-15 10:09:12.486] [T-7136] [logging.cpp::98] [shards/General/Match/4.edn] Matched nil","title":"Match"},{"location":"shards/General/Match/#match","text":"( Match :Cases [( Seq [( Any )])] :Passthrough [( Bool )] )","title":"Match"},{"location":"shards/General/Match/#definition","text":"Compares the input with the declared cases (in order of the declaration) and activates the shard of the first matched case.","title":"Definition"},{"location":"shards/General/Match/#parameters","text":"Name Type Default Description Cases [(Seq [(Any)])] [] Values to match against the input. A nil case will match anything. Passthrough [(Bool)] true Parameter to control the shard's output. true allows the Match shard's input itself to appear as its output; false allows the matched shard's output to appear as Match shard's output.","title":"Parameters"},{"location":"shards/General/Match/#input","text":"Type Description [(Any)] The value that's compared with the declared cases.","title":"Input"},{"location":"shards/General/Match/#output","text":"Type Description [(Any)] Same value as input if :Passthrough is true else the output of the matched case's shard if :Passthrough is false .","title":"Output"},{"location":"shards/General/Match/#details","text":"Match compares its input with every case declared via the :Cases parameter (in the order of their declaration) till a match is found. Once a match is found the shard of that matched case is activated/executed and Match execution stops. All subsequent cases (even matching ones) are ignored. A nil case matches with everything. So it's a good practice to declare a nil case at the end of :Cases to execute some default logic if no valid matches exist for a given input. If you do not have a nil case then a non-matching input to Match will fail the shard.","title":"Details"},{"location":"shards/General/Match/#a-note-on-passthrough","text":"The :Passthrough parameter can control the final output of the shard it applies to. Setting this parameter to true allows the original input of shard to passthrough as its output as well. If this paramter is set to false , passthrough is suppressed and then the output of the shard is the actual computed value coming out from the shard execution. For Match , this parameter when set to true will allow the original input (the one that was used to match against every case in the shard) to appear again its final output (irrespective of the case match results). Setting :Passthrough to false will enable the matched case's shard output to appear as the output of Match . However, for :Passthrough to work correctly, the data types of the shard input and the shard's case outputs must match.","title":"A note on :Passthrough"},{"location":"shards/General/Match/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 ;; single match + nil match at end + no passthrough 1 ( Match [ 2 ( -> \"Matched 2\" ) ;; case processed, match not found 1 ( -> \"Matched 1\" ) ;; case processed, match found 3 ( -> \"Matched 3\" ) ;; case ignored nil ( -> \"Matched nil\" )] ;; case ignored :Passthrough false ) ;; no passthrough -- ( Assert.Is \"Matched 1\" true ) ;; -- so matched case's output becomes `Match` shard's output Code Output 1 2 3 4 5 6 7 8 9 ;; multiple matches + nil match at end + no passthrough 1 ( Match [ ( + 0 1 ) ( -> \"Matched 1a\" ) ;; case processed, match found 1 ( -> \"Matched 1\" ) ;; case ignored 2 ( -> \"Matched 2\" ) ;; case ignored nil ( -> \"Matched nil\" )] ;; case ignored :Passthrough false ) ;; no passthrough -- ( Assert.Is \"Matched 1a\" true ) ;; -- so matched case's output becomes `Match` shard's output Code Output 1 2 3 4 5 6 7 8 9 ;; multiple matches + nil match at start + with passthrough 1 ( Match [ nil ( -> ( Msg \"Matched nil\" )) ;; case processed, match found 1 ( -> ( Msg \"Matched 1\" )) ;; case ignored ( + 0 1 ) ( -> ( Msg \"Matched 1a\" )) ;; case ignored 2 ( -> ( Msg \"Matched 2\" ))] ;; case ignored :Passthrough true ) ;; passthrough -- ( Assert.Is 1 true ) ;; -- so input to `Match` is also its output [info] [2022-08-15 10:09:12.427] [T-3524] [logging.cpp::98] [shards/General/Match/3.edn] Matched nil Code Output 1 2 3 4 5 6 7 8 ;; no matches + nil match in the middle + with passthrough 1 ( Match [ 2 ( -> ( Msg \"Matched 2\" )) ;; case processed, match not found nil ( -> ( Msg \"Matched nil\" )) ;; case processed, match found 3 ( -> ( Msg \"Matched 3\" ))] ;; case ignored :Passthrough true ) ;; passthrough -- ( Assert.Is 1 true ) ;; -- so input to `Match` is also its output [info] [2022-08-15 10:09:12.486] [T-7136] [logging.cpp::98] [shards/General/Match/4.edn] Matched nil","title":"Examples"},{"location":"shards/General/Max/","text":"Max \u00b6 ( Max :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Details \u00b6 This shard compares the input to its :Operand parameter and outputs the greater of the two values. If the input is a sequence and the :Operand a single number, each input element is compared with the :Operand and the greater value from each comparison is collected and output as a sequence. If the input and :Operand both are sequences, each element of the input sequence is compared with the corresponding-index element in the :Operand sequence and the greater value from each comparison is collected and output as a sequence. If the input sequence is smaller in size than the :Operand sequence the comparison stops with the last element of the input sequence. If the :Operand sequence is smaller the remaining input sequence elements loop over the :Operand sequence till all input sequence elements have been compared. This shard works only on numbers (integers, floats) and on sequences of such numbers. The data types of the input and the :Operand parameters must match. See also Min Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ;; sequence vs number ( Const [ -1 0 1 2 5 ]) ( Max ;:Operand 3 ) ( Assert.Is [ 3 3 3 3 5 ] true ) ;; number vs number ( Const 3 ) ( Max ;:Operand 2 ) ( Assert.Is 3 true ) ;; sequence (equal) vs sequence (equal) ( Const [ -1 0 1 2 5 ]) ( Max ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ 3 0 4 2 5 ] true ) ;; sequence (smaller) vs sequence (bigger) ( Const [ -1 0 5 ]) ( Max ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ 3 0 5 ] true ) ;; sequence (bigger) vs sequence (smaller) ( Const [ -1 0 1 2 5 ]) ( Max ;:Operand [ 3 -2 1 ]) ( Assert.Is [ 3 0 1 3 5 ] true )","title":"Max"},{"location":"shards/General/Max/#max","text":"( Max :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Max"},{"location":"shards/General/Max/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/General/Max/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/General/Max/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/General/Max/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/General/Max/#details","text":"This shard compares the input to its :Operand parameter and outputs the greater of the two values. If the input is a sequence and the :Operand a single number, each input element is compared with the :Operand and the greater value from each comparison is collected and output as a sequence. If the input and :Operand both are sequences, each element of the input sequence is compared with the corresponding-index element in the :Operand sequence and the greater value from each comparison is collected and output as a sequence. If the input sequence is smaller in size than the :Operand sequence the comparison stops with the last element of the input sequence. If the :Operand sequence is smaller the remaining input sequence elements loop over the :Operand sequence till all input sequence elements have been compared. This shard works only on numbers (integers, floats) and on sequences of such numbers. The data types of the input and the :Operand parameters must match. See also Min","title":"Details"},{"location":"shards/General/Max/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ;; sequence vs number ( Const [ -1 0 1 2 5 ]) ( Max ;:Operand 3 ) ( Assert.Is [ 3 3 3 3 5 ] true ) ;; number vs number ( Const 3 ) ( Max ;:Operand 2 ) ( Assert.Is 3 true ) ;; sequence (equal) vs sequence (equal) ( Const [ -1 0 1 2 5 ]) ( Max ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ 3 0 4 2 5 ] true ) ;; sequence (smaller) vs sequence (bigger) ( Const [ -1 0 5 ]) ( Max ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ 3 0 5 ] true ) ;; sequence (bigger) vs sequence (smaller) ( Const [ -1 0 1 2 5 ]) ( Max ;:Operand [ 3 -2 1 ]) ( Assert.Is [ 3 0 1 3 5 ] true )","title":"Examples"},{"location":"shards/General/Maybe/","text":"Maybe \u00b6 ( Maybe :Shards [( Shard ) ( Seq [( Shard )]) ( None )] :Else [( Shard ) ( Seq [( Shard )]) ( None )] :Silent [( Bool )] ) Definition \u00b6 Attempts to activate a shard or a sequence of shards. Upon failure, activate another shard or sequence of shards. Parameters \u00b6 Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to activate. Else [(Shard) (Seq [(Shard)]) (None)] None The shards to activate on failure. Silent [(Bool)] false If logging should be disabled while running the shards (this will also disable (Log) and (Msg) shards) and no warning message should be printed on failure. Input \u00b6 Type Description [(Any)] Must match the input types of the first shard in the sequence. Output \u00b6 Type Description [(Any)] Will match the output types of the first shard of the sequence. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 [ 1 2 ] ( Maybe ;:Shards ( Take 3 ) ;:Else ( Take 0 ) ;:Silent true )","title":"Maybe"},{"location":"shards/General/Maybe/#maybe","text":"( Maybe :Shards [( Shard ) ( Seq [( Shard )]) ( None )] :Else [( Shard ) ( Seq [( Shard )]) ( None )] :Silent [( Bool )] )","title":"Maybe"},{"location":"shards/General/Maybe/#definition","text":"Attempts to activate a shard or a sequence of shards. Upon failure, activate another shard or sequence of shards.","title":"Definition"},{"location":"shards/General/Maybe/#parameters","text":"Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to activate. Else [(Shard) (Seq [(Shard)]) (None)] None The shards to activate on failure. Silent [(Bool)] false If logging should be disabled while running the shards (this will also disable (Log) and (Msg) shards) and no warning message should be printed on failure.","title":"Parameters"},{"location":"shards/General/Maybe/#input","text":"Type Description [(Any)] Must match the input types of the first shard in the sequence.","title":"Input"},{"location":"shards/General/Maybe/#output","text":"Type Description [(Any)] Will match the output types of the first shard of the sequence.","title":"Output"},{"location":"shards/General/Maybe/#examples","text":"Code Output 1 2 3 4 5 6 7 8 [ 1 2 ] ( Maybe ;:Shards ( Take 3 ) ;:Else ( Take 0 ) ;:Silent true )","title":"Examples"},{"location":"shards/General/Min/","text":"Min \u00b6 ( Min :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Details \u00b6 This shard compares the input to its :Operand parameter and outputs the lesser of the two values. If the input is a sequence and the :Operand a single number, each input element is compared with the :Operand and the lesser value from each comparison is collected and output as a sequence. If the input and :Operand both are sequences, each element of the input sequence is compared with the corresponding-index element in the :Operand sequence and the lesser value from each comparison is collected and output as a sequence. If the input sequence is smaller in size than the :Operand sequence the comparison stops with the last element of the input sequence. If the :Operand sequence is smaller the remaining input sequence elements loop over the :Operand sequence till all input sequence elements have been compared. This shard works only on numbers (integers, floats) and on sequences of such numbers. The data types of the input and the :Operand parameters must match. See also Max Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ;; sequence vs number ( Const [ -1 0 1 2 5 ]) ( Min ;:Operand 3 ) ( Assert.Is [ -1 0 1 2 3 ] true ) ;; number vs number ( Const 3 ) ( Min ;:Operand 2 ) ( Assert.Is 2 true ) ;; sequence (equal) vs sequence (equal) ( Const [ -1 0 1 2 5 ]) ( Min ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ -1 -2 1 0 1 ] true ) ;; sequence (smaller) vs sequence (bigger) ( Const [ -1 0 5 ]) ( Min ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ -1 -2 4 ] true ) ;; sequence (bigger) vs sequence (smaller) ( Const [ -1 0 1 2 5 ]) ( Min ;:Operand [ 3 -2 1 ]) ( Assert.Is [ -1 -2 1 2 -2 ] true )","title":"Min"},{"location":"shards/General/Min/#min","text":"( Min :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Min"},{"location":"shards/General/Min/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/General/Min/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/General/Min/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/General/Min/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/General/Min/#details","text":"This shard compares the input to its :Operand parameter and outputs the lesser of the two values. If the input is a sequence and the :Operand a single number, each input element is compared with the :Operand and the lesser value from each comparison is collected and output as a sequence. If the input and :Operand both are sequences, each element of the input sequence is compared with the corresponding-index element in the :Operand sequence and the lesser value from each comparison is collected and output as a sequence. If the input sequence is smaller in size than the :Operand sequence the comparison stops with the last element of the input sequence. If the :Operand sequence is smaller the remaining input sequence elements loop over the :Operand sequence till all input sequence elements have been compared. This shard works only on numbers (integers, floats) and on sequences of such numbers. The data types of the input and the :Operand parameters must match. See also Max","title":"Details"},{"location":"shards/General/Min/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ;; sequence vs number ( Const [ -1 0 1 2 5 ]) ( Min ;:Operand 3 ) ( Assert.Is [ -1 0 1 2 3 ] true ) ;; number vs number ( Const 3 ) ( Min ;:Operand 2 ) ( Assert.Is 2 true ) ;; sequence (equal) vs sequence (equal) ( Const [ -1 0 1 2 5 ]) ( Min ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ -1 -2 1 0 1 ] true ) ;; sequence (smaller) vs sequence (bigger) ( Const [ -1 0 5 ]) ( Min ;:Operand [ 3 -2 4 0 1 ]) ( Assert.Is [ -1 -2 4 ] true ) ;; sequence (bigger) vs sequence (smaller) ( Const [ -1 0 1 2 5 ]) ( Min ;:Operand [ 3 -2 1 ]) ( Assert.Is [ -1 -2 1 2 -2 ] true )","title":"Examples"},{"location":"shards/General/Msg/","text":"Msg \u00b6 ( Msg :Message [( String )] ) Definition \u00b6 Displays the passed message string or the passed variable's value to the user via standard output. Parameters \u00b6 Name Type Default Description Message [(String)] \"\" The message to display on the user's screen or console. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Details \u00b6 This shard is used for displaying messages to the user on the standard output (which is usually the console). The message to display can be passed to this shard either as a string or as a variable holding a value. In case a variable is passed the shard displays the variable's value. Examples \u00b6 Code Output 1 2 3 4 5 6 ( defshards msgshard [ a b ] ( Msg a ) ;; print value of 1st arg passed ( Msg b )) ;; print value of 2nd arg passed ( Msg \"Hello World\" ) ;; prints string ( msgshard \"Bye\" \"Universe\" ) ;; prints args passed [info] [2022-08-15 10:09:12.719] [T-6656] [SHCore.cpp::963] Ignoring value inside a wire definition: #user-function(000001e94d6e2d30) ignore this warning if this was intentional. [info] [2022-08-15 10:09:12.720] [T-6656] [logging.cpp::98] [shards/General/Msg/1.edn] Hello World [info] [2022-08-15 10:09:12.720] [T-6656] [logging.cpp::98] [shards/General/Msg/1.edn] Bye [info] [2022-08-15 10:09:12.720] [T-6656] [logging.cpp::98] [shards/General/Msg/1.edn] Universe","title":"Msg"},{"location":"shards/General/Msg/#msg","text":"( Msg :Message [( String )] )","title":"Msg"},{"location":"shards/General/Msg/#definition","text":"Displays the passed message string or the passed variable's value to the user via standard output.","title":"Definition"},{"location":"shards/General/Msg/#parameters","text":"Name Type Default Description Message [(String)] \"\" The message to display on the user's screen or console.","title":"Parameters"},{"location":"shards/General/Msg/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Msg/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Msg/#details","text":"This shard is used for displaying messages to the user on the standard output (which is usually the console). The message to display can be passed to this shard either as a string or as a variable holding a value. In case a variable is passed the shard displays the variable's value.","title":"Details"},{"location":"shards/General/Msg/#examples","text":"Code Output 1 2 3 4 5 6 ( defshards msgshard [ a b ] ( Msg a ) ;; print value of 1st arg passed ( Msg b )) ;; print value of 2nd arg passed ( Msg \"Hello World\" ) ;; prints string ( msgshard \"Bye\" \"Universe\" ) ;; prints args passed [info] [2022-08-15 10:09:12.719] [T-6656] [SHCore.cpp::963] Ignoring value inside a wire definition: #user-function(000001e94d6e2d30) ignore this warning if this was intentional. [info] [2022-08-15 10:09:12.720] [T-6656] [logging.cpp::98] [shards/General/Msg/1.edn] Hello World [info] [2022-08-15 10:09:12.720] [T-6656] [logging.cpp::98] [shards/General/Msg/1.edn] Bye [info] [2022-08-15 10:09:12.720] [T-6656] [logging.cpp::98] [shards/General/Msg/1.edn] Universe","title":"Examples"},{"location":"shards/General/Mutant/","text":"Mutant \u00b6 ( Mutant :Shard [( Shard )] :Indices [( Seq [( Int )])] :Mutations [( Seq [( Shard ) ( Seq [( Shard )]) ( None )])] :Options [( None ) ( Table [( Any )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Shard [(Shard)] None The shard to mutate. Indices [(Seq [(Int)])] None The parameter indices to mutate of the inner shard. Mutations [(Seq [(Shard) (Seq [(Shard)]) (None)])] None Optional wires of shards (or Nones) to call when mutating one of the parameters, if empty a default operator will be used. Options [(None) (Table [(Any)])] None Mutation options table - a table with mutation options. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Mutant"},{"location":"shards/General/Mutant/#mutant","text":"( Mutant :Shard [( Shard )] :Indices [( Seq [( Int )])] :Mutations [( Seq [( Shard ) ( Seq [( Shard )]) ( None )])] :Options [( None ) ( Table [( Any )])] )","title":"Mutant"},{"location":"shards/General/Mutant/#definition","text":"","title":"Definition"},{"location":"shards/General/Mutant/#parameters","text":"Name Type Default Description Shard [(Shard)] None The shard to mutate. Indices [(Seq [(Int)])] None The parameter indices to mutate of the inner shard. Mutations [(Seq [(Shard) (Seq [(Shard)]) (None)])] None Optional wires of shards (or Nones) to call when mutating one of the parameters, if empty a default operator will be used. Options [(None) (Table [(Any)])] None Mutation options table - a table with mutation options.","title":"Parameters"},{"location":"shards/General/Mutant/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Mutant/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/NaNTo0/","text":"NaNTo0 \u00b6 ( NaNTo0 ) Definition \u00b6 Input \u00b6 Type Description [(Float) (Seq [(Float)])] Output \u00b6 Type Description [(Float) (Seq [(Float)])]","title":"NaNTo0"},{"location":"shards/General/NaNTo0/#nanto0","text":"( NaNTo0 )","title":"NaNTo0"},{"location":"shards/General/NaNTo0/#definition","text":"","title":"Definition"},{"location":"shards/General/NaNTo0/#input","text":"Type Description [(Float) (Seq [(Float)])]","title":"Input"},{"location":"shards/General/NaNTo0/#output","text":"Type Description [(Float) (Seq [(Float)])]","title":"Output"},{"location":"shards/General/Not/","text":"Not \u00b6 ( Not ) Definition \u00b6 Computes the logical negation of the input. Input \u00b6 Type Description [(Bool)] The value to be negated. Output \u00b6 Type Description [(Bool)] The negation of the input. Examples \u00b6 Code Output 1 2 3 4 5 false ( Not ) ( Assert.Is true :Abort true ) true ( Not ) ( Assert.Is false :Abort true )","title":"Not"},{"location":"shards/General/Not/#not","text":"( Not )","title":"Not"},{"location":"shards/General/Not/#definition","text":"Computes the logical negation of the input.","title":"Definition"},{"location":"shards/General/Not/#input","text":"Type Description [(Bool)] The value to be negated.","title":"Input"},{"location":"shards/General/Not/#output","text":"Type Description [(Bool)] The negation of the input.","title":"Output"},{"location":"shards/General/Not/#examples","text":"Code Output 1 2 3 4 5 false ( Not ) ( Assert.Is true :Abort true ) true ( Not ) ( Assert.Is false :Abort true )","title":"Examples"},{"location":"shards/General/OnCleanup/","text":"OnCleanup \u00b6 ( OnCleanup :Shards [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to execute on wire's cleanup. Notice that shards that suspend execution are not allowed. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"OnCleanup"},{"location":"shards/General/OnCleanup/#oncleanup","text":"( OnCleanup :Shards [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"OnCleanup"},{"location":"shards/General/OnCleanup/#definition","text":"","title":"Definition"},{"location":"shards/General/OnCleanup/#parameters","text":"Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shards to execute on wire's cleanup. Notice that shards that suspend execution are not allowed.","title":"Parameters"},{"location":"shards/General/OnCleanup/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/OnCleanup/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Once/","text":"Once \u00b6 ( Once :Action [( Shard ) ( Seq [( Shard )])] :Every [( Float )] ) Definition \u00b6 Executes the shard or sequence of shards with the desired frequency in a wire flow execution. Parameters \u00b6 Name Type Default Description Action [(Shard) (Seq [(Shard)])] None The shard or sequence of shards to execute. Every [(Float)] 0 The number of seconds to wait until repeating the action, if 0 the action will happen only once per wire flow execution. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Details \u00b6 If you run (Once) with :Every set to its default value (i.e., 0), the sequence of shards will be executed only once per wire flow execution. Since this a very common use case (initialize loop counters, etc.) there's an alias for this - (Setup) . Basically, (Setup) is just (Once) with its :Every parameter value permanently set to 0. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; Once ( defmesh Main ) ( defloop test \"Hello World, every 1.5s during a wire flow execution\" = .string1 \"Hello World, once during every wire flow execution\" = .string2 .string1 ( Once :Action ( Log ) :Every 1.5 ;; string logs once every 1.5 secs i.e for a total of 3 times ) .string2 ( Once :Action ( Log ) ;; :Every defaults to 0 so this string logs only once ) ) ;; here one wire flow execution is 5 secs (5 mesh iterations, one per second) ;; so string1 logs for a maximum of 5/(1.5) => ~3 times and string2 logs only once ( schedule Main test ) ( run Main 1 5 ) [info] [2022-08-15 10:09:12.834] [T-4408] [logging.cpp::55] [test] Hello World, every 1.5s during a wire flow execution [info] [2022-08-15 10:09:12.835] [T-4408] [logging.cpp::55] [test] Hello World, once during every wire flow execution [info] [2022-08-15 10:09:14.849] [T-4408] [logging.cpp::55] [test] Hello World, every 1.5s during a wire flow execution [info] [2022-08-15 10:09:15.839] [T-4408] [logging.cpp::55] [test] Hello World, every 1.5s during a wire flow execution [info] [2022-08-15 10:09:16.846] [T-4408] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; Setup ( defmesh Main ) ( defloop test ( Setup 0 >= .counter .counter ( Log \"counter set to 0 only once\" ) ;; => 0 ) ( Math.Inc .counter ) .counter ( Log \"counter incremented every time wire executes\" ) ;; => 1, 2, 3, 4, 5 ) ( schedule Main test ) ( run Main 1 5 ) [info] [2022-08-15 10:09:16.907] [T-5452] [logging.cpp::53] [test] counter set to 0 only once: 0 [info] [2022-08-15 10:09:16.908] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 1 [info] [2022-08-15 10:09:17.911] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 2 [info] [2022-08-15 10:09:18.912] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 3 [info] [2022-08-15 10:09:19.908] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 4 [info] [2022-08-15 10:09:20.921] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 5 [info] [2022-08-15 10:09:20.921] [T-5452] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"Once"},{"location":"shards/General/Once/#once","text":"( Once :Action [( Shard ) ( Seq [( Shard )])] :Every [( Float )] )","title":"Once"},{"location":"shards/General/Once/#definition","text":"Executes the shard or sequence of shards with the desired frequency in a wire flow execution.","title":"Definition"},{"location":"shards/General/Once/#parameters","text":"Name Type Default Description Action [(Shard) (Seq [(Shard)])] None The shard or sequence of shards to execute. Every [(Float)] 0 The number of seconds to wait until repeating the action, if 0 the action will happen only once per wire flow execution.","title":"Parameters"},{"location":"shards/General/Once/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Once/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Once/#details","text":"If you run (Once) with :Every set to its default value (i.e., 0), the sequence of shards will be executed only once per wire flow execution. Since this a very common use case (initialize loop counters, etc.) there's an alias for this - (Setup) . Basically, (Setup) is just (Once) with its :Every parameter value permanently set to 0.","title":"Details"},{"location":"shards/General/Once/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; Once ( defmesh Main ) ( defloop test \"Hello World, every 1.5s during a wire flow execution\" = .string1 \"Hello World, once during every wire flow execution\" = .string2 .string1 ( Once :Action ( Log ) :Every 1.5 ;; string logs once every 1.5 secs i.e for a total of 3 times ) .string2 ( Once :Action ( Log ) ;; :Every defaults to 0 so this string logs only once ) ) ;; here one wire flow execution is 5 secs (5 mesh iterations, one per second) ;; so string1 logs for a maximum of 5/(1.5) => ~3 times and string2 logs only once ( schedule Main test ) ( run Main 1 5 ) [info] [2022-08-15 10:09:12.834] [T-4408] [logging.cpp::55] [test] Hello World, every 1.5s during a wire flow execution [info] [2022-08-15 10:09:12.835] [T-4408] [logging.cpp::55] [test] Hello World, once during every wire flow execution [info] [2022-08-15 10:09:14.849] [T-4408] [logging.cpp::55] [test] Hello World, every 1.5s during a wire flow execution [info] [2022-08-15 10:09:15.839] [T-4408] [logging.cpp::55] [test] Hello World, every 1.5s during a wire flow execution [info] [2022-08-15 10:09:16.846] [T-4408] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional. Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;; Setup ( defmesh Main ) ( defloop test ( Setup 0 >= .counter .counter ( Log \"counter set to 0 only once\" ) ;; => 0 ) ( Math.Inc .counter ) .counter ( Log \"counter incremented every time wire executes\" ) ;; => 1, 2, 3, 4, 5 ) ( schedule Main test ) ( run Main 1 5 ) [info] [2022-08-15 10:09:16.907] [T-5452] [logging.cpp::53] [test] counter set to 0 only once: 0 [info] [2022-08-15 10:09:16.908] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 1 [info] [2022-08-15 10:09:17.911] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 2 [info] [2022-08-15 10:09:18.912] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 3 [info] [2022-08-15 10:09:19.908] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 4 [info] [2022-08-15 10:09:20.921] [T-5452] [logging.cpp::53] [test] counter incremented every time wire executes: 5 [info] [2022-08-15 10:09:20.921] [T-5452] [SHCore.cpp::963] Ignoring value inside a wire definition: Mesh ignore this warning if this was intentional.","title":"Examples"},{"location":"shards/General/Or/","text":"Or \u00b6 ( Or ) Definition \u00b6 Computes the logical OR between the input of this shard and the output of the next shard. Input \u00b6 Type Description [(Bool)] The first operand to be evaluated. Output \u00b6 Type Description [(Bool)] The output of this shard will be its input. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 false ( Or ) false ( Assert.Is false :Abort true ) false ( Or ) true ( Assert.Is true :Abort true ) true ( Or ) false ( Assert.Is true :Abort true ) true ( Or ) true ( Assert.Is true :Abort true )","title":"Or"},{"location":"shards/General/Or/#or","text":"( Or )","title":"Or"},{"location":"shards/General/Or/#definition","text":"Computes the logical OR between the input of this shard and the output of the next shard.","title":"Definition"},{"location":"shards/General/Or/#input","text":"Type Description [(Bool)] The first operand to be evaluated.","title":"Input"},{"location":"shards/General/Or/#output","text":"Type Description [(Bool)] The output of this shard will be its input.","title":"Output"},{"location":"shards/General/Or/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 false ( Or ) false ( Assert.Is false :Abort true ) false ( Or ) true ( Assert.Is true :Abort true ) true ( Or ) false ( Assert.Is true :Abort true ) true ( Or ) true ( Assert.Is true :Abort true )","title":"Examples"},{"location":"shards/General/Pack/","text":"Pack \u00b6 ( Pack :Definition [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Definition [(String)] \"\" A string defining the struct e.g. \"i32 f32 b i8[256]\". Input \u00b6 Type Description [(Seq [(Any)])] Output \u00b6 Type Description [(Bytes)]","title":"Pack"},{"location":"shards/General/Pack/#pack","text":"( Pack :Definition [( String )] )","title":"Pack"},{"location":"shards/General/Pack/#definition","text":"","title":"Definition"},{"location":"shards/General/Pack/#parameters","text":"Name Type Default Description Definition [(String)] \"\" A string defining the struct e.g. \"i32 f32 b i8[256]\".","title":"Parameters"},{"location":"shards/General/Pack/#input","text":"Type Description [(Seq [(Any)])]","title":"Input"},{"location":"shards/General/Pack/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/ParseFloat/","text":"ParseFloat \u00b6 ( ParseFloat ) Definition \u00b6 Converts the string representation of a number to a floating-point number equivalent. Input \u00b6 Type Description [(String)] A string representing a number. Output \u00b6 Type Description [(Float)] A floating-point number equivalent to the number contained in the string input. Examples \u00b6 Code Output 1 2 \"3.14\" ( ParseFloat ) ( Log ) ( Assert.Is 3.14 :Abort true ) [info] [2022-08-15 10:09:21.050] [T-5844] [logging.cpp::55] [shards/General/ParseFloat/1.edn] 3.14","title":"ParseFloat"},{"location":"shards/General/ParseFloat/#parsefloat","text":"( ParseFloat )","title":"ParseFloat"},{"location":"shards/General/ParseFloat/#definition","text":"Converts the string representation of a number to a floating-point number equivalent.","title":"Definition"},{"location":"shards/General/ParseFloat/#input","text":"Type Description [(String)] A string representing a number.","title":"Input"},{"location":"shards/General/ParseFloat/#output","text":"Type Description [(Float)] A floating-point number equivalent to the number contained in the string input.","title":"Output"},{"location":"shards/General/ParseFloat/#examples","text":"Code Output 1 2 \"3.14\" ( ParseFloat ) ( Log ) ( Assert.Is 3.14 :Abort true ) [info] [2022-08-15 10:09:21.050] [T-5844] [logging.cpp::55] [shards/General/ParseFloat/1.edn] 3.14","title":"Examples"},{"location":"shards/General/ParseInt/","text":"ParseInt \u00b6 ( ParseInt :Base [( Int )] ) Definition \u00b6 Converts the string representation of a number to a signed integer equivalent. Parameters \u00b6 Name Type Default Description Base [(Int)] 10 Numerical base (radix) that determines the valid characters and their interpretation. Input \u00b6 Type Description [(String)] A string representing a number. Output \u00b6 Type Description [(Int)] A signed integer equivalent to the number contained in the string input. Examples \u00b6 Code Output 1 2 \"42\" ( ParseInt ) ( Log ) ( Assert.Is 42 :Abort true ) [info] [2022-08-15 10:09:21.107] [T-1364] [logging.cpp::55] [shards/General/ParseInt/1.edn] 42","title":"ParseInt"},{"location":"shards/General/ParseInt/#parseint","text":"( ParseInt :Base [( Int )] )","title":"ParseInt"},{"location":"shards/General/ParseInt/#definition","text":"Converts the string representation of a number to a signed integer equivalent.","title":"Definition"},{"location":"shards/General/ParseInt/#parameters","text":"Name Type Default Description Base [(Int)] 10 Numerical base (radix) that determines the valid characters and their interpretation.","title":"Parameters"},{"location":"shards/General/ParseInt/#input","text":"Type Description [(String)] A string representing a number.","title":"Input"},{"location":"shards/General/ParseInt/#output","text":"Type Description [(Int)] A signed integer equivalent to the number contained in the string input.","title":"Output"},{"location":"shards/General/ParseInt/#examples","text":"Code Output 1 2 \"42\" ( ParseInt ) ( Log ) ( Assert.Is 42 :Abort true ) [info] [2022-08-15 10:09:21.107] [T-1364] [logging.cpp::55] [shards/General/ParseInt/1.edn] 42","title":"Examples"},{"location":"shards/General/Pass/","text":"Pass \u00b6 ( Pass ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Pass"},{"location":"shards/General/Pass/#pass","text":"( Pass )","title":"Pass"},{"location":"shards/General/Pass/#definition","text":"","title":"Definition"},{"location":"shards/General/Pass/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Pass/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Pause/","text":"Pause \u00b6 ( Pause :Time [( None ) ( Float ) ( Int ) ( ContextVar [( Float )]) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Time [(None) (Float) (Int) (ContextVar [(Float)]) (ContextVar [(Int)])] None The amount of time in seconds (can be fractional) to pause this wire. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Pause"},{"location":"shards/General/Pause/#pause","text":"( Pause :Time [( None ) ( Float ) ( Int ) ( ContextVar [( Float )]) ( ContextVar [( Int )])] )","title":"Pause"},{"location":"shards/General/Pause/#definition","text":"","title":"Definition"},{"location":"shards/General/Pause/#parameters","text":"Name Type Default Description Time [(None) (Float) (Int) (ContextVar [(Float)]) (ContextVar [(Int)])] None The amount of time in seconds (can be fractional) to pause this wire.","title":"Parameters"},{"location":"shards/General/Pause/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Pause/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/PauseMs/","text":"PauseMs \u00b6 ( PauseMs :Time [( None ) ( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Time [(None) (Int) (ContextVar [(Int)])] None The amount of time in milliseconds to pause this wire. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"PauseMs"},{"location":"shards/General/PauseMs/#pausems","text":"( PauseMs :Time [( None ) ( Int ) ( ContextVar [( Int )])] )","title":"PauseMs"},{"location":"shards/General/PauseMs/#definition","text":"","title":"Definition"},{"location":"shards/General/PauseMs/#parameters","text":"Name Type Default Description Time [(None) (Int) (ContextVar [(Int)])] None The amount of time in milliseconds to pause this wire.","title":"Parameters"},{"location":"shards/General/PauseMs/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/PauseMs/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Pop/","text":"Pop \u00b6 ( Pop :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Pops (drops as well as passes as output) the last element of the sequence variable passed in the :Name parameter. Works only on sequences. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(None)] Any input is ignored. Output \u00b6 Type Description [(Any)] Element popped from the sequence. Details \u00b6 Pop drops (removes) the last element of the sequence variable that has been passed to in the :Name parameter and makes it available to the next shard as its input. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to pop elements from. Input field is ignored and the output of this shard is the element which was popped from the sequence passed to it via the :Name parameter. See also AppendTo Clear Drop DropFront Erase PopFront Remove Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; pop last element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( Pop :Name .seq ) ( Log ) ;; pops the last element as output => 40 ( Get .seq ) ( Log ) ;; updated sequence => [10, 20, 30] ;; pop last element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( Pop :Name .seq :Global true ) ( Log ) ;; pops the last element as output => 41 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [11, 21, 31] [info] [2022-08-15 10:09:21.163] [T-656] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] 40 [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [10, 20, 30] [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] 41 [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [11, 21, 31]","title":"Pop"},{"location":"shards/General/Pop/#pop","text":"( Pop :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Pop"},{"location":"shards/General/Pop/#definition","text":"Pops (drops as well as passes as output) the last element of the sequence variable passed in the :Name parameter. Works only on sequences.","title":"Definition"},{"location":"shards/General/Pop/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Pop/#input","text":"Type Description [(None)] Any input is ignored.","title":"Input"},{"location":"shards/General/Pop/#output","text":"Type Description [(Any)] Element popped from the sequence.","title":"Output"},{"location":"shards/General/Pop/#details","text":"Pop drops (removes) the last element of the sequence variable that has been passed to in the :Name parameter and makes it available to the next shard as its input. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to pop elements from. Input field is ignored and the output of this shard is the element which was popped from the sequence passed to it via the :Name parameter. See also AppendTo Clear Drop DropFront Erase PopFront Remove","title":"Details"},{"location":"shards/General/Pop/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; pop last element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( Pop :Name .seq ) ( Log ) ;; pops the last element as output => 40 ( Get .seq ) ( Log ) ;; updated sequence => [10, 20, 30] ;; pop last element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( Pop :Name .seq :Global true ) ( Log ) ;; pops the last element as output => 41 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [11, 21, 31] [info] [2022-08-15 10:09:21.163] [T-656] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] 40 [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [10, 20, 30] [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] 41 [info] [2022-08-15 10:09:21.164] [T-656] [logging.cpp::55] [shards/General/Pop/Pop.edn] [11, 21, 31]","title":"Examples"},{"location":"shards/General/PopFront/","text":"PopFront \u00b6 ( PopFront :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Pops (drops as well as passes as output) the first element of the sequence variable passed in the :Name parameter. Works only on sequences. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(None)] Any input is ignored. Output \u00b6 Type Description [(Any)] Element popped from the sequence. Details \u00b6 PopFront drops (removes) the first element of the sequence variable that has been passed to in the :Name parameter and makes it available to the next shard as its input. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to pop elements from. Input field is ignored and the output of this shard is the element which was popped from the sequence passed to it via the :Name parameter. See also Clear Drop DropFront Erase Pop PrependTo Remove Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; pop first element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( PopFront :Name .seq ) ( Log ) ;; pops the first element as output => 10 ( Get .seq ) ( Log ) ;; updated sequence => [20, 30, 40] ;; pop first element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( PopFront :Name .seq :Global true ) ( Log ) ;; pops the first element as output => 11 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [21, 31, 41] [info] [2022-08-15 10:09:21.219] [T-4140] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] 10 [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [20, 30, 40] [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] 11 [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [21, 31, 41]","title":"PopFront"},{"location":"shards/General/PopFront/#popfront","text":"( PopFront :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"PopFront"},{"location":"shards/General/PopFront/#definition","text":"Pops (drops as well as passes as output) the first element of the sequence variable passed in the :Name parameter. Works only on sequences.","title":"Definition"},{"location":"shards/General/PopFront/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/PopFront/#input","text":"Type Description [(None)] Any input is ignored.","title":"Input"},{"location":"shards/General/PopFront/#output","text":"Type Description [(Any)] Element popped from the sequence.","title":"Output"},{"location":"shards/General/PopFront/#details","text":"PopFront drops (removes) the first element of the sequence variable that has been passed to in the :Name parameter and makes it available to the next shard as its input. This shard works on both sequences and tables. Parameter :Key applies only to tables. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to pop elements from. Input field is ignored and the output of this shard is the element which was popped from the sequence passed to it via the :Name parameter. See also Clear Drop DropFront Erase Pop PrependTo Remove","title":"Details"},{"location":"shards/General/PopFront/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ;; pop first element from a local sequence [ 10 20 30 40 ] >= .seq ;; create a local sequence ( Get .seq ) ( Log ) ;; local sequence => [10, 20, 30, 40] ( PopFront :Name .seq ) ( Log ) ;; pops the first element as output => 10 ( Get .seq ) ( Log ) ;; updated sequence => [20, 30, 40] ;; pop first element from a same-name global sequence [ 11 21 31 41 ] >== .seq ;; create a same-name global sequence ( Get .seq :Global true ) ( Log ) ;; local sequence => [11, 21, 31, 41] ( PopFront :Name .seq :Global true ) ( Log ) ;; pops the first element as output => 11 ( Get .seq :Global true ) ( Log ) ;; updated sequence => [21, 31, 41] [info] [2022-08-15 10:09:21.219] [T-4140] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: seq [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [10, 20, 30, 40] [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] 10 [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [20, 30, 40] [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [11, 21, 31, 41] [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] 11 [info] [2022-08-15 10:09:21.220] [T-4140] [logging.cpp::55] [shards/General/PopFront/PopFront.edn] [21, 31, 41]","title":"Examples"},{"location":"shards/General/PrependTo/","text":"PrependTo \u00b6 ( PrependTo :Collection [( ContextVar [( Seq [( Any )])]) ( ContextVar [( String )]) ( ContextVar [( Bytes )])] ) Definition \u00b6 Prepends the input to the context variable passed to :Collection . Parameters \u00b6 Name Type Default Description Collection [(ContextVar [(Seq [(Any)])]) (ContextVar [(String)]) (ContextVar [(Bytes)])] None The collection to add the input to. Input \u00b6 Type Description [(Any)] The value to prepend to the collection. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 PrependTo prepends (i.e., adds to the start) its input to the variable it receives in its :Collection parameter. This shard works on string and sequence variables. The input to this shard is also passed through as its output. See also DropFront PopFront Push Set Update Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 ;; prepend element to sequence [ 1 2 3 ] >= .seq 0 ( PrependTo .seq ) ;; prepends element to sequence .seq ( Log ) ;; updated sequence => [0, 1, 2, 3] ;; prepend character to string \"pen\" >= .str \"O\" ( PrependTo .str ) ;; prepends character to string .str ( Log ) ;; updated string => Open [info] [2022-08-15 10:09:21.279] [T-2728] [logging.cpp::55] [shards/General/PrependTo/PrependTo.edn] [0, 1, 2, 3] [info] [2022-08-15 10:09:21.279] [T-2728] [logging.cpp::55] [shards/General/PrependTo/PrependTo.edn] Open","title":"PrependTo"},{"location":"shards/General/PrependTo/#prependto","text":"( PrependTo :Collection [( ContextVar [( Seq [( Any )])]) ( ContextVar [( String )]) ( ContextVar [( Bytes )])] )","title":"PrependTo"},{"location":"shards/General/PrependTo/#definition","text":"Prepends the input to the context variable passed to :Collection .","title":"Definition"},{"location":"shards/General/PrependTo/#parameters","text":"Name Type Default Description Collection [(ContextVar [(Seq [(Any)])]) (ContextVar [(String)]) (ContextVar [(Bytes)])] None The collection to add the input to.","title":"Parameters"},{"location":"shards/General/PrependTo/#input","text":"Type Description [(Any)] The value to prepend to the collection.","title":"Input"},{"location":"shards/General/PrependTo/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/PrependTo/#details","text":"PrependTo prepends (i.e., adds to the start) its input to the variable it receives in its :Collection parameter. This shard works on string and sequence variables. The input to this shard is also passed through as its output. See also DropFront PopFront Push Set Update","title":"Details"},{"location":"shards/General/PrependTo/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 ;; prepend element to sequence [ 1 2 3 ] >= .seq 0 ( PrependTo .seq ) ;; prepends element to sequence .seq ( Log ) ;; updated sequence => [0, 1, 2, 3] ;; prepend character to string \"pen\" >= .str \"O\" ( PrependTo .str ) ;; prepends character to string .str ( Log ) ;; updated string => Open [info] [2022-08-15 10:09:21.279] [T-2728] [logging.cpp::55] [shards/General/PrependTo/PrependTo.edn] [0, 1, 2, 3] [info] [2022-08-15 10:09:21.279] [T-2728] [logging.cpp::55] [shards/General/PrependTo/PrependTo.edn] Open","title":"Examples"},{"location":"shards/General/Produce/","text":"Produce \u00b6 ( Produce :Name [( String )] :NoCopy!! [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the channel. NoCopy!! [(Bool)] false Unsafe flag that will improve performance by not copying values when sending them thru the channel. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Produce"},{"location":"shards/General/Produce/#produce","text":"( Produce :Name [( String )] :NoCopy!! [( Bool )] )","title":"Produce"},{"location":"shards/General/Produce/#definition","text":"","title":"Definition"},{"location":"shards/General/Produce/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the channel. NoCopy!! [(Bool)] false Unsafe flag that will improve performance by not copying values when sending them thru the channel.","title":"Parameters"},{"location":"shards/General/Produce/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Produce/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Profile/","text":"Profile \u00b6 ( Profile :Action [( Shard ) ( Seq [( Shard )])] :Label [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Action [(Shard) (Seq [(Shard)])] None The action shards to profile. Label [(String)] \"<no label>\" The label to print when outputting time data. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Profile"},{"location":"shards/General/Profile/#profile","text":"( Profile :Action [( Shard ) ( Seq [( Shard )])] :Label [( String )] )","title":"Profile"},{"location":"shards/General/Profile/#definition","text":"","title":"Definition"},{"location":"shards/General/Profile/#parameters","text":"Name Type Default Description Action [(Shard) (Seq [(Shard)])] None The action shards to profile. Label [(String)] \"<no label>\" The label to print when outputting time data.","title":"Parameters"},{"location":"shards/General/Profile/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Profile/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Push/","text":"Push \u00b6 ( Push :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Clear [( Bool )] ) Definition \u00b6 Updates sequences and tables by pushing elements and/or sequences into them. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Clear [(Bool)] true If we should clear this sequence at every wire iteration; works only if this is the first push; default: true. Input \u00b6 Type Description [(Any)] Input is the update value to be pushed into the variables. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Push updates sequences and tables by pushing elements and/or sequences into them. The name of the variable to update should come from the :Name parameter and the new update value(s) should come from the shard's input. For existing sequences Push pushes in the new elements. If a sequence doesn't exist then Push will create it while pushing in the first element. These elements may be string constants, numerics, or even sequences themselves. For tables Push can update only those existing keys whose values are of the type sequence. In such cases Push can push in new elements in those key-value pair sequences. The key to be updated must be passed in via the :Key parameter. Note Do not use Push to update any variables created by Set (or its aliases >= / >>= ). Push is best used to update variables that were themselves created by Push (first push). Though, if really want to do (1.) you can offload the current sequence into another sequence variable, push new values into it, and update the table with this sequence variable (see the last code example). The :Global parameter controls whether the created variables can be referenced across wires ( :Global set to true ) or only within the current wire ( :Global set to false , default behaviour). Variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh). Hence, in update mode (i.e. when you apply Push to an existing variable) the :Global parameter is used in conjunction with the :Name parameter to identify the correct variable to update. The parameter :Clear controls whether we should clear out this sequence after every wire iteration ( Clear set to true , default behaviour) or should the sequence data persist across wire iterations ( Clear set to false ). The input to this shard is the new update value that is to be pushed into the sequence/table being modified. This value is also passed through as this shard's output. Note Push has two aliases: >> which is an alias for (Push ... :Clear true) , and >>! which is an alias for (Push ... :Clear false) . See the code examples at the end to understand how these aliases are used. See also AppendTo PrependTo Sequence Set Table Update Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ;; create and update sequence with `Push`; value available only to current wire 1 ( Push :Name .seq1 ) ;; create a sequence by pushing the first element .seq1 ( Log \".seq1\" ) ;; sequence created => [1] 2 ( Push :Name .seq1 ) ;; push one more element into sequence .seq1 ( Log \".seq1\" ) ;; sequence updated => [1, 2] ;; create and update sequence with `Push`; value available to all wires on mesh [ 10 20 ] ( Push :Name .seq2 :Global true ) ;; create sequence with two elements .seq2 ( Log \".seq2\" ) ;; sequence created => [10, 20] 30 ( Push :Name .seq2 :Global true ) ;; push one more element into sequence .seq2 ( Log \".seq2\" ) ;; sequence updated => [10, 20, 30] ;; create empty sequence with `Sequence`; add elements with `Push` ( Sequence :Name .seq3 ) ;; create empty sequence .seq3 ( Log \".seq3\" ) ;; empty sequence created => [] 1 ( Push :Name .seq3 :Clear false ) ;; push an element into sequence .seq3 ( Log \".seq3\" ) ;; sequence updated => [1] 2 ( Push :Name .seq3 :Clear false ) ;; push another element into sequence .seq3 ( Log \".seq3\" ) ;; sequence updated => [1, 2] ;; create empty table with `Table`; add/update key sequence values with `Push` ;; (Table :Name .table1) ;; created an empty table (one key, no value) ;; .table1 (Log) ;; table with one key (no value) created => {A: []} 1 ( Push .table1 \"A\" ) ;; push new key \"A\" with sequence value \"[1]\" .table1 ( Log ) ;; table key/value updated => {A: [1]} 2 ( Push .table1 \"A\" ) ;; push new element into key \"A\" existing sequence .table1 ( Log ) ;; table key/value updated => {A: [1, 2]} ;; create and update local/global sequence variables \"Local\" ( Push .seq ) ;; create local sequence variable with first push \"Global\" ( Push .seq :Global true ) ;; create same-name global sequence variable with first push ( Get .seq ) ( Log ) ;; get local variable => [Local] ( Get .seq :Global true ) ( Log ) ;; get same-name updated global variable => [Global] \"Local2\" ( Push .seq ) ;; push new value into local sequence variable \"Global2\" ( Push .seq :Global true ) ;; push new value into same-name global sequence variable ( Get .seq ) ( Log ) ;; get updated local sequence variable => [Local, Local2] ( Get .seq :Global true ) ( Log ) ;; get updated global sequence variable => [Global, Global2] ;; Using a `Push` alias: `>>` is alias for `(Push :Clear true)` \"Hello\" >> .seq4 ;; create sequence by pushing the first element .seq4 ( Log \".seq4\" ) ;; sequence created => [Hello] \"World\" >> .seq4 ;; update the sequence by pushing one more element .seq4 ( Log \".seq4\" ) ;; sequence updated with second element => [Hello, World] ;; Using a `Push` alias: `>>!` is alias for `(Push :Clear false)` \"Bye\" >>! .seq5 ;; create sequence by pushing the first element .seq5 ( Log \".seq5\" ) ;; sequence created => [Bye] \"Universe\" >>! .seq5 ;; update the sequence by pushing one more element .seq5 ( Log \".seq5\" ) ;; sequence updated with second element => [Bye, Universe] ;; Technique to update a non-push created Table's sequence values with `Push` { :k1 [ 1 2 3 ]} >= .table2 ;; table is created using `Set` .table2 ( Log ) ;; table with key/value pair created => {:k1 [1 2 3]} ( Get .table2 \"k1\" ) >= .seqvar ;; target value offloaded into a sequence variable 4 ( Push .seqvar ) ;; update sequence variable using `Push` .seqvar ( Log ) ;; sequence variable updated => [1, 2, 3, 4] { :k1 .seqvar } >= .table2 ;; update table key sequence value with modified sequence variable .table2 ( Log ) ;; targeted table key updated with required sequence values => {:k1 [1 2 3 4]} [info] [2022-08-15 10:09:21.338] [T-2740] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: table2 [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq1: [1] [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq1: [1, 2] [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq2: [[10, 20]] [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq2: [[10, 20], 30] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq3: [] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq3: [1] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq3: [1, 2] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {A: [1]} [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {A: [1, 2]} [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Local] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Global] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Local, Local2] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Global, Global2] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq4: [Hello] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq4: [Hello, World] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq5: [Bye] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq5: [Bye, Universe] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {k1: [1, 2, 3]} [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [1, 2, 3, 4] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {k1: [1, 2, 3, 4]}","title":"Push"},{"location":"shards/General/Push/#push","text":"( Push :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Clear [( Bool )] )","title":"Push"},{"location":"shards/General/Push/#definition","text":"Updates sequences and tables by pushing elements and/or sequences into them.","title":"Definition"},{"location":"shards/General/Push/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Clear [(Bool)] true If we should clear this sequence at every wire iteration; works only if this is the first push; default: true.","title":"Parameters"},{"location":"shards/General/Push/#input","text":"Type Description [(Any)] Input is the update value to be pushed into the variables.","title":"Input"},{"location":"shards/General/Push/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Push/#details","text":"Push updates sequences and tables by pushing elements and/or sequences into them. The name of the variable to update should come from the :Name parameter and the new update value(s) should come from the shard's input. For existing sequences Push pushes in the new elements. If a sequence doesn't exist then Push will create it while pushing in the first element. These elements may be string constants, numerics, or even sequences themselves. For tables Push can update only those existing keys whose values are of the type sequence. In such cases Push can push in new elements in those key-value pair sequences. The key to be updated must be passed in via the :Key parameter. Note Do not use Push to update any variables created by Set (or its aliases >= / >>= ). Push is best used to update variables that were themselves created by Push (first push). Though, if really want to do (1.) you can offload the current sequence into another sequence variable, push new values into it, and update the table with this sequence variable (see the last code example). The :Global parameter controls whether the created variables can be referenced across wires ( :Global set to true ) or only within the current wire ( :Global set to false , default behaviour). Variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh). Hence, in update mode (i.e. when you apply Push to an existing variable) the :Global parameter is used in conjunction with the :Name parameter to identify the correct variable to update. The parameter :Clear controls whether we should clear out this sequence after every wire iteration ( Clear set to true , default behaviour) or should the sequence data persist across wire iterations ( Clear set to false ). The input to this shard is the new update value that is to be pushed into the sequence/table being modified. This value is also passed through as this shard's output. Note Push has two aliases: >> which is an alias for (Push ... :Clear true) , and >>! which is an alias for (Push ... :Clear false) . See the code examples at the end to understand how these aliases are used. See also AppendTo PrependTo Sequence Set Table Update","title":"Details"},{"location":"shards/General/Push/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ;; create and update sequence with `Push`; value available only to current wire 1 ( Push :Name .seq1 ) ;; create a sequence by pushing the first element .seq1 ( Log \".seq1\" ) ;; sequence created => [1] 2 ( Push :Name .seq1 ) ;; push one more element into sequence .seq1 ( Log \".seq1\" ) ;; sequence updated => [1, 2] ;; create and update sequence with `Push`; value available to all wires on mesh [ 10 20 ] ( Push :Name .seq2 :Global true ) ;; create sequence with two elements .seq2 ( Log \".seq2\" ) ;; sequence created => [10, 20] 30 ( Push :Name .seq2 :Global true ) ;; push one more element into sequence .seq2 ( Log \".seq2\" ) ;; sequence updated => [10, 20, 30] ;; create empty sequence with `Sequence`; add elements with `Push` ( Sequence :Name .seq3 ) ;; create empty sequence .seq3 ( Log \".seq3\" ) ;; empty sequence created => [] 1 ( Push :Name .seq3 :Clear false ) ;; push an element into sequence .seq3 ( Log \".seq3\" ) ;; sequence updated => [1] 2 ( Push :Name .seq3 :Clear false ) ;; push another element into sequence .seq3 ( Log \".seq3\" ) ;; sequence updated => [1, 2] ;; create empty table with `Table`; add/update key sequence values with `Push` ;; (Table :Name .table1) ;; created an empty table (one key, no value) ;; .table1 (Log) ;; table with one key (no value) created => {A: []} 1 ( Push .table1 \"A\" ) ;; push new key \"A\" with sequence value \"[1]\" .table1 ( Log ) ;; table key/value updated => {A: [1]} 2 ( Push .table1 \"A\" ) ;; push new element into key \"A\" existing sequence .table1 ( Log ) ;; table key/value updated => {A: [1, 2]} ;; create and update local/global sequence variables \"Local\" ( Push .seq ) ;; create local sequence variable with first push \"Global\" ( Push .seq :Global true ) ;; create same-name global sequence variable with first push ( Get .seq ) ( Log ) ;; get local variable => [Local] ( Get .seq :Global true ) ( Log ) ;; get same-name updated global variable => [Global] \"Local2\" ( Push .seq ) ;; push new value into local sequence variable \"Global2\" ( Push .seq :Global true ) ;; push new value into same-name global sequence variable ( Get .seq ) ( Log ) ;; get updated local sequence variable => [Local, Local2] ( Get .seq :Global true ) ( Log ) ;; get updated global sequence variable => [Global, Global2] ;; Using a `Push` alias: `>>` is alias for `(Push :Clear true)` \"Hello\" >> .seq4 ;; create sequence by pushing the first element .seq4 ( Log \".seq4\" ) ;; sequence created => [Hello] \"World\" >> .seq4 ;; update the sequence by pushing one more element .seq4 ( Log \".seq4\" ) ;; sequence updated with second element => [Hello, World] ;; Using a `Push` alias: `>>!` is alias for `(Push :Clear false)` \"Bye\" >>! .seq5 ;; create sequence by pushing the first element .seq5 ( Log \".seq5\" ) ;; sequence created => [Bye] \"Universe\" >>! .seq5 ;; update the sequence by pushing one more element .seq5 ( Log \".seq5\" ) ;; sequence updated with second element => [Bye, Universe] ;; Technique to update a non-push created Table's sequence values with `Push` { :k1 [ 1 2 3 ]} >= .table2 ;; table is created using `Set` .table2 ( Log ) ;; table with key/value pair created => {:k1 [1 2 3]} ( Get .table2 \"k1\" ) >= .seqvar ;; target value offloaded into a sequence variable 4 ( Push .seqvar ) ;; update sequence variable using `Push` .seqvar ( Log ) ;; sequence variable updated => [1, 2, 3, 4] { :k1 .seqvar } >= .table2 ;; update table key sequence value with modified sequence variable .table2 ( Log ) ;; targeted table key updated with required sequence values => {:k1 [1 2 3 4]} [info] [2022-08-15 10:09:21.338] [T-2740] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: table2 [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq1: [1] [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq1: [1, 2] [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq2: [[10, 20]] [info] [2022-08-15 10:09:21.338] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq2: [[10, 20], 30] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq3: [] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq3: [1] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq3: [1, 2] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {A: [1]} [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {A: [1, 2]} [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Local] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Global] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Local, Local2] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [Global, Global2] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq4: [Hello] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq4: [Hello, World] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq5: [Bye] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::53] [shards/General/Push/Push.edn] .seq5: [Bye, Universe] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {k1: [1, 2, 3]} [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] [1, 2, 3, 4] [info] [2022-08-15 10:09:21.339] [T-2740] [logging.cpp::55] [shards/General/Push/Push.edn] {k1: [1, 2, 3, 4]}","title":"Examples"},{"location":"shards/General/RTake/","text":"RTake \u00b6 ( RTake :Indices [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])])] ) Definition \u00b6 Works exactly like Take except that the selection indices are counted backwards from the last element in the target sequence. Also, RTake works only on sequences, not on tables. Parameters \u00b6 Name Type Default Description Indices [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])])] None One or more indices (counted backwards from the last element) to extract from a sequence. Input \u00b6 Type Description [(Bytes) (String) (Seq [(Any)])] The sequence from which elements have to be extracted. Output \u00b6 Type Description [(Any)] The extracted elements. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ;; RTake on sequences [ 10 20 30 40 ] ( RTake 1 ) ( Log ) ( Assert.Is 30 :Abort true ) [ 10 20 30 40 ] ( RTake [ 0 1 ]) ( Log ) ( Assert.Is [ 40 , 30 ] :Abort true ) ;; RTake not valid on tables ;; RTake using a variable as index 1 = .index [ 1 2 3 4 ] ( RTake .index ) ( Log ) ( Assert.Is 3 :Abort true ) [info] [2022-08-15 10:09:21.740] [T-5328] [logging.cpp::55] [shards/General/RTake/1.edn] 30 [info] [2022-08-15 10:09:21.741] [T-5328] [logging.cpp::55] [shards/General/RTake/1.edn] [40, 30] [info] [2022-08-15 10:09:21.741] [T-5328] [logging.cpp::55] [shards/General/RTake/1.edn] 3","title":"RTake"},{"location":"shards/General/RTake/#rtake","text":"( RTake :Indices [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])])] )","title":"RTake"},{"location":"shards/General/RTake/#definition","text":"Works exactly like Take except that the selection indices are counted backwards from the last element in the target sequence. Also, RTake works only on sequences, not on tables.","title":"Definition"},{"location":"shards/General/RTake/#parameters","text":"Name Type Default Description Indices [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])])] None One or more indices (counted backwards from the last element) to extract from a sequence.","title":"Parameters"},{"location":"shards/General/RTake/#input","text":"Type Description [(Bytes) (String) (Seq [(Any)])] The sequence from which elements have to be extracted.","title":"Input"},{"location":"shards/General/RTake/#output","text":"Type Description [(Any)] The extracted elements.","title":"Output"},{"location":"shards/General/RTake/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ;; RTake on sequences [ 10 20 30 40 ] ( RTake 1 ) ( Log ) ( Assert.Is 30 :Abort true ) [ 10 20 30 40 ] ( RTake [ 0 1 ]) ( Log ) ( Assert.Is [ 40 , 30 ] :Abort true ) ;; RTake not valid on tables ;; RTake using a variable as index 1 = .index [ 1 2 3 4 ] ( RTake .index ) ( Log ) ( Assert.Is 3 :Abort true ) [info] [2022-08-15 10:09:21.740] [T-5328] [logging.cpp::55] [shards/General/RTake/1.edn] 30 [info] [2022-08-15 10:09:21.741] [T-5328] [logging.cpp::55] [shards/General/RTake/1.edn] [40, 30] [info] [2022-08-15 10:09:21.741] [T-5328] [logging.cpp::55] [shards/General/RTake/1.edn] 3","title":"Examples"},{"location":"shards/General/RandomBytes/","text":"RandomBytes \u00b6 ( RandomBytes :Size [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Size [(Int)] 32 The amount of bytes to output. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Bytes)]","title":"RandomBytes"},{"location":"shards/General/RandomBytes/#randombytes","text":"( RandomBytes :Size [( Int )] )","title":"RandomBytes"},{"location":"shards/General/RandomBytes/#definition","text":"","title":"Definition"},{"location":"shards/General/RandomBytes/#parameters","text":"Name Type Default Description Size [(Int)] 32 The amount of bytes to output.","title":"Parameters"},{"location":"shards/General/RandomBytes/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/General/RandomBytes/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/RandomFloat/","text":"RandomFloat \u00b6 ( RandomFloat :Max [( None ) ( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Max [(None) (Float) (ContextVar [(Float)])] None The maximum (if integer, not including) value to output. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float)]","title":"RandomFloat"},{"location":"shards/General/RandomFloat/#randomfloat","text":"( RandomFloat :Max [( None ) ( Float ) ( ContextVar [( Float )])] )","title":"RandomFloat"},{"location":"shards/General/RandomFloat/#definition","text":"","title":"Definition"},{"location":"shards/General/RandomFloat/#parameters","text":"Name Type Default Description Max [(None) (Float) (ContextVar [(Float)])] None The maximum (if integer, not including) value to output.","title":"Parameters"},{"location":"shards/General/RandomFloat/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/General/RandomFloat/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/General/RandomInt/","text":"RandomInt \u00b6 ( RandomInt :Max [( None ) ( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Max [(None) (Int) (ContextVar [(Int)])] None The maximum (if integer, not including) value to output. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Int)]","title":"RandomInt"},{"location":"shards/General/RandomInt/#randomint","text":"( RandomInt :Max [( None ) ( Int ) ( ContextVar [( Int )])] )","title":"RandomInt"},{"location":"shards/General/RandomInt/#definition","text":"","title":"Definition"},{"location":"shards/General/RandomInt/#parameters","text":"Name Type Default Description Max [(None) (Int) (ContextVar [(Int)])] None The maximum (if integer, not including) value to output.","title":"Parameters"},{"location":"shards/General/RandomInt/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/General/RandomInt/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/General/ReadFile/","text":"ReadFile \u00b6 ( ReadFile :File [( String ) ( ContextVar [( String )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Any)]","title":"ReadFile"},{"location":"shards/General/ReadFile/#readfile","text":"( ReadFile :File [( String ) ( ContextVar [( String )]) ( None )] )","title":"ReadFile"},{"location":"shards/General/ReadFile/#definition","text":"","title":"Definition"},{"location":"shards/General/ReadFile/#parameters","text":"Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from.","title":"Parameters"},{"location":"shards/General/ReadFile/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/General/ReadFile/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Recur/","text":"Recur \u00b6 ( Recur ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 ( defwire fibo >= .n ( If ( IsLess 2 ) :Then ( -> ( Pass )) :Else ( -> .n ( Math.Subtract 2 ) ( Recur ) >= .a .n ( Math.Subtract 1 ) ( Recur ) >= .b .a ( Math.Add .b )))) 16 ( Do fibo ) ( Log ) ( Assert.Is 987 true ) [info] [2022-08-15 10:09:21.396] [T-4820] [logging.cpp::55] [shards/General/Recur/Recur.edn] 987","title":"Recur"},{"location":"shards/General/Recur/#recur","text":"( Recur )","title":"Recur"},{"location":"shards/General/Recur/#definition","text":"","title":"Definition"},{"location":"shards/General/Recur/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Recur/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Recur/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 ( defwire fibo >= .n ( If ( IsLess 2 ) :Then ( -> ( Pass )) :Else ( -> .n ( Math.Subtract 2 ) ( Recur ) >= .a .n ( Math.Subtract 1 ) ( Recur ) >= .b .a ( Math.Add .b )))) 16 ( Do fibo ) ( Log ) ( Assert.Is 987 true ) [info] [2022-08-15 10:09:21.396] [T-4820] [logging.cpp::55] [shards/General/Recur/Recur.edn] 987","title":"Examples"},{"location":"shards/General/Reduce/","text":"Reduce \u00b6 ( Reduce :Apply [( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Apply [(Shard) (Seq [(Shard)])] None The function to apply to each item of the sequence. Input \u00b6 Type Description [(Seq [(Any)])] Output \u00b6 Type Description [(Any)]","title":"Reduce"},{"location":"shards/General/Reduce/#reduce","text":"( Reduce :Apply [( Shard ) ( Seq [( Shard )])] )","title":"Reduce"},{"location":"shards/General/Reduce/#definition","text":"","title":"Definition"},{"location":"shards/General/Reduce/#parameters","text":"Name Type Default Description Apply [(Shard) (Seq [(Shard)])] None The function to apply to each item of the sequence.","title":"Parameters"},{"location":"shards/General/Reduce/#input","text":"Type Description [(Seq [(Any)])]","title":"Input"},{"location":"shards/General/Reduce/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Ref/","text":"Ref \u00b6 ( Ref :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Creates an immutable variable with a constant value. Once created this variable cannot be changed. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(Any)] Input becomes the value of the variable being created. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Ref creates an immutable variable and assigns a constant value to it. Once created this variable cannot be changed. The name of the variable comes from the :Name parameter and the constant value comes from the input. The type of input controls the kind of variable that will created: numeric input creates numeric variable, string input creates string variable, and sequence input would create a sequence variable. To create a table variable, along with the input, you also have to pass the key in the :Key parameter. In this case the input (whatever it may be - numeric, string, sequence) becomes the value of the key that was passed in parameter :Key . The :Global parameter controls whether the created variables can be referenced across wires ( :Global set to true ) or only within the current wire ( :Global set to false , default behaviour). The input to this shard is used as the value for the new variable and is also passed through as this shard's output. Note Ref has two aliases: = and &> . Both are aliases for (Ref ... :Global false) . See the code examples at the end to understand how these aliases are used. See also Const Get Set Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;; create an immutable string variable (by default available only to current wire) \"Hello\" ( Ref :Name .svar ) .svar ( Log \".svar\" ) ;; => .svar: Hello ;; uncomment next line to see the immutable-variable-update error ;; 20 (Update .svar) ;; => Error composing shard: Set/Ref/Update, attempted to write an immutable variable. ;; create an immutable numeric variable (available to all wires because `:Global true`) 100 ( Ref :Name .nvar :Global true ) .nvar ( Log \".nvar\" ) ;; => .nvar: 100 ;; create an immutable sequence [ 10 20 ] ( Ref :Name .seq ) .seq ( Log \".seq\" ) ;; => .seq: [10, 20] ;; create an immutable table ( Const [ \"a\" \"b\" ]) ( Ref :Name \"table\" :Key \"key1\" ) .table ( Log \".table\" ) ;; => .table: {key1: [a, b]} ;; Using `Ref` aliases ;; `=` is alias for `(Ref :Global false)`: create an immutable string variable: \"World\" = .svarA .svarA ( Log \".svarA\" ) ;; => .svarA: World ;; `&>` is another alias for `(Ref :Global false)`: create an immubtable numeric variable 100 & > .nvarA .nvarA ( Log \".nvarA\" ) ;; => .nvarA: 100 [info] [2022-08-15 10:09:21.453] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .svar: Hello [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .nvar: 100 [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .seq: [10, 20] [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .table: {key1: [a, b]} [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .svarA: World [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .nvarA: 100","title":"Ref"},{"location":"shards/General/Ref/#ref","text":"( Ref :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Ref"},{"location":"shards/General/Ref/#definition","text":"Creates an immutable variable with a constant value. Once created this variable cannot be changed.","title":"Definition"},{"location":"shards/General/Ref/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Ref/#input","text":"Type Description [(Any)] Input becomes the value of the variable being created.","title":"Input"},{"location":"shards/General/Ref/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Ref/#details","text":"Ref creates an immutable variable and assigns a constant value to it. Once created this variable cannot be changed. The name of the variable comes from the :Name parameter and the constant value comes from the input. The type of input controls the kind of variable that will created: numeric input creates numeric variable, string input creates string variable, and sequence input would create a sequence variable. To create a table variable, along with the input, you also have to pass the key in the :Key parameter. In this case the input (whatever it may be - numeric, string, sequence) becomes the value of the key that was passed in parameter :Key . The :Global parameter controls whether the created variables can be referenced across wires ( :Global set to true ) or only within the current wire ( :Global set to false , default behaviour). The input to this shard is used as the value for the new variable and is also passed through as this shard's output. Note Ref has two aliases: = and &> . Both are aliases for (Ref ... :Global false) . See the code examples at the end to understand how these aliases are used. See also Const Get Set","title":"Details"},{"location":"shards/General/Ref/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;; create an immutable string variable (by default available only to current wire) \"Hello\" ( Ref :Name .svar ) .svar ( Log \".svar\" ) ;; => .svar: Hello ;; uncomment next line to see the immutable-variable-update error ;; 20 (Update .svar) ;; => Error composing shard: Set/Ref/Update, attempted to write an immutable variable. ;; create an immutable numeric variable (available to all wires because `:Global true`) 100 ( Ref :Name .nvar :Global true ) .nvar ( Log \".nvar\" ) ;; => .nvar: 100 ;; create an immutable sequence [ 10 20 ] ( Ref :Name .seq ) .seq ( Log \".seq\" ) ;; => .seq: [10, 20] ;; create an immutable table ( Const [ \"a\" \"b\" ]) ( Ref :Name \"table\" :Key \"key1\" ) .table ( Log \".table\" ) ;; => .table: {key1: [a, b]} ;; Using `Ref` aliases ;; `=` is alias for `(Ref :Global false)`: create an immutable string variable: \"World\" = .svarA .svarA ( Log \".svarA\" ) ;; => .svarA: World ;; `&>` is another alias for `(Ref :Global false)`: create an immubtable numeric variable 100 & > .nvarA .nvarA ( Log \".nvarA\" ) ;; => .nvarA: 100 [info] [2022-08-15 10:09:21.453] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .svar: Hello [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .nvar: 100 [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .seq: [10, 20] [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .table: {key1: [a, b]} [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .svarA: World [info] [2022-08-15 10:09:21.454] [T-6376] [logging.cpp::53] [shards/General/Ref/Ref.edn] .nvarA: 100","title":"Examples"},{"location":"shards/General/Remove/","text":"Remove \u00b6 ( Remove :From [( ContextVar [( Seq [( Any )])])] :Join [( ContextVar [( Seq [( Any )])]) ( Seq [( ContextVar [( Seq [( Any )])])])] :Predicate [( Shard ) ( Seq [( Shard )])] :Unordered [( Bool )] ) Definition \u00b6 Removes all elements from a sequence that match the given condition. Can also take these matched indices and remove corresponding elements from a joined sequence. Parameters \u00b6 Name Type Default Description From [(ContextVar [(Seq [(Any)])])] None The name of the sequence variable to edit in place. Join [(ContextVar [(Seq [(Any)])]) (Seq [(ContextVar [(Seq [(Any)])])])] None Other columns to join sort/filter using the input (they must be of the same length). Predicate [(Shard) (Seq [(Shard)])] None The shards to use as predicate, if true the item will be popped from the sequence. Unordered [(Bool)] false Turn on to remove items very quickly but will not preserve the sequence items order. Input \u00b6 Type Description [(None)] Any input is ignored. Output \u00b6 Type Description [(Seq [(Any)])] Output is the filtered sequence. Details \u00b6 Remove removes all the elements of the :Name parameter sequence that match the condition laid out in the the :Predicate parameter. It can also take these condition-matched indices (from the :From sequence) and remove the corresponding elements from a joined sequence (passed via the :Join parameter). Remember, Remove doesn't apply the :Predicate conditions to the joined sequence, but removes corresponding elements from it based on :Predicate matched indices of the main sequence. For this to work both the sequences must have the same length. Note Think of this as the Shards equivalent of a relational database inner join. The main sequence and the joined sequence can be thought of as columns from two different tables inner joined over indices equality. So that the changes in elements of one sequence (rows in the first table) can be propogated to the corresponding elements of the joined sequence (corresponding rows in the joined table). In this case the operation is deletion of selected elements (selected rows) from one sequence (table) leading to deletion of corresponding elements (connected rows) of the joined sequence (joined table). The :Predicate parameter can take any conditional/logical expression or combination of shards that will result in assertion that can be tested on the sequence elements. The :Unordered parameter can be set to true if you need to make the removal process faster, but then the order of the remaining elements in the resulting sequence elements may not be preserved. By default, this order is preseved. Remove works only on sequences. Any input to this shard is ignored and its output is the main filtered sequence. See also Clear Drop DropFront Erase Pop PopFront Sort Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;; remove predicate-satisfying elements from :From sequence [ 10 20 30 ] >= .seq1 ( Remove :From .seq1 :Predicate ( IsMore 20 ) :Unordered false ) ( Log \"output\" ) ;; => output: [10, 20] .seq1 ( Log \".seq1\" ) ;; index-2 element matched, removed => .seq1: [10, 20] ;; remove corresponding index elements from :Join sequence [ 10 20 30 ] >= .seq2 [ 100 200 300 ] >= .seqJ ( Remove .seq2 :Predicate ( Is 20 ) :Join .seqJ ) .seq2 ( Log \".seq2\" ) ;; index-1 element matched, removed from seq2 => .seq2: [10, 30] .seqJ ( Log \".seqJ\" ) ;; matched index-1 element removed from seqJ => .seqJ: [100, 300] ;; remove with :Unordered true (faster but sequence items order may not be preserved) [[ 20 30 ] [ 30 40 ] [ 40 50 ]] >= .seq3 ( Remove .seq3 :Predicate ( -> ( Take 0 ) ( IsLess 30 )) :Unordered true ) .seq3 ( Log \".seq3\" ) ;; index-0 element matched, removed => .seq3: [[40, 50], [30, 40]] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] output: [10, 20] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seq1: [10, 20] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seq2: [10, 30] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seqJ: [100, 300] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seq3: [[40, 50], [30, 40]]","title":"Remove"},{"location":"shards/General/Remove/#remove","text":"( Remove :From [( ContextVar [( Seq [( Any )])])] :Join [( ContextVar [( Seq [( Any )])]) ( Seq [( ContextVar [( Seq [( Any )])])])] :Predicate [( Shard ) ( Seq [( Shard )])] :Unordered [( Bool )] )","title":"Remove"},{"location":"shards/General/Remove/#definition","text":"Removes all elements from a sequence that match the given condition. Can also take these matched indices and remove corresponding elements from a joined sequence.","title":"Definition"},{"location":"shards/General/Remove/#parameters","text":"Name Type Default Description From [(ContextVar [(Seq [(Any)])])] None The name of the sequence variable to edit in place. Join [(ContextVar [(Seq [(Any)])]) (Seq [(ContextVar [(Seq [(Any)])])])] None Other columns to join sort/filter using the input (they must be of the same length). Predicate [(Shard) (Seq [(Shard)])] None The shards to use as predicate, if true the item will be popped from the sequence. Unordered [(Bool)] false Turn on to remove items very quickly but will not preserve the sequence items order.","title":"Parameters"},{"location":"shards/General/Remove/#input","text":"Type Description [(None)] Any input is ignored.","title":"Input"},{"location":"shards/General/Remove/#output","text":"Type Description [(Seq [(Any)])] Output is the filtered sequence.","title":"Output"},{"location":"shards/General/Remove/#details","text":"Remove removes all the elements of the :Name parameter sequence that match the condition laid out in the the :Predicate parameter. It can also take these condition-matched indices (from the :From sequence) and remove the corresponding elements from a joined sequence (passed via the :Join parameter). Remember, Remove doesn't apply the :Predicate conditions to the joined sequence, but removes corresponding elements from it based on :Predicate matched indices of the main sequence. For this to work both the sequences must have the same length. Note Think of this as the Shards equivalent of a relational database inner join. The main sequence and the joined sequence can be thought of as columns from two different tables inner joined over indices equality. So that the changes in elements of one sequence (rows in the first table) can be propogated to the corresponding elements of the joined sequence (corresponding rows in the joined table). In this case the operation is deletion of selected elements (selected rows) from one sequence (table) leading to deletion of corresponding elements (connected rows) of the joined sequence (joined table). The :Predicate parameter can take any conditional/logical expression or combination of shards that will result in assertion that can be tested on the sequence elements. The :Unordered parameter can be set to true if you need to make the removal process faster, but then the order of the remaining elements in the resulting sequence elements may not be preserved. By default, this order is preseved. Remove works only on sequences. Any input to this shard is ignored and its output is the main filtered sequence. See also Clear Drop DropFront Erase Pop PopFront Sort","title":"Details"},{"location":"shards/General/Remove/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;; remove predicate-satisfying elements from :From sequence [ 10 20 30 ] >= .seq1 ( Remove :From .seq1 :Predicate ( IsMore 20 ) :Unordered false ) ( Log \"output\" ) ;; => output: [10, 20] .seq1 ( Log \".seq1\" ) ;; index-2 element matched, removed => .seq1: [10, 20] ;; remove corresponding index elements from :Join sequence [ 10 20 30 ] >= .seq2 [ 100 200 300 ] >= .seqJ ( Remove .seq2 :Predicate ( Is 20 ) :Join .seqJ ) .seq2 ( Log \".seq2\" ) ;; index-1 element matched, removed from seq2 => .seq2: [10, 30] .seqJ ( Log \".seqJ\" ) ;; matched index-1 element removed from seqJ => .seqJ: [100, 300] ;; remove with :Unordered true (faster but sequence items order may not be preserved) [[ 20 30 ] [ 30 40 ] [ 40 50 ]] >= .seq3 ( Remove .seq3 :Predicate ( -> ( Take 0 ) ( IsLess 30 )) :Unordered true ) .seq3 ( Log \".seq3\" ) ;; index-0 element matched, removed => .seq3: [[40, 50], [30, 40]] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] output: [10, 20] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seq1: [10, 20] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seq2: [10, 30] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seqJ: [100, 300] [info] [2022-08-15 10:09:21.511] [T-1204] [logging.cpp::53] [shards/General/Remove/Remove.edn] .seq3: [[40, 50], [30, 40]]","title":"Examples"},{"location":"shards/General/Repeat/","text":"Repeat \u00b6 ( Repeat :Action [( Shard ) ( Seq [( Shard )])] :Times [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])])] :Forever [( Bool )] :Until [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Repeat an action a given number of times or until a condition is no longer true . Parameters \u00b6 Name Type Default Description Action [(Shard) (Seq [(Shard)])] None The shards to repeat. Times [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])])] 0 How many times we should repeat the action. Forever [(Bool)] false If we should repeat the action forever. Until [(Shard) (Seq [(Shard)]) (None)] None Optional shards to use as predicate to continue repeating until it's true Input \u00b6 Type Description [(Any)] The input will be passed to both the action and the :Until condition if used. Output \u00b6 Type Description [(Any)] The output of this shard will be its input. Examples \u00b6 Code Output 1 2 3 ( Repeat ( -> ( Msg \"Hello\" )) :Times 5 ) [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello Code Output 1 2 3 4 5 6 7 0 >= .n ( Repeat ( -> .n ( Log \"Counting\" ) ( Math.Inc .n )) :Forever true :Until ( -> .n ( IsMore 9 ))) [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 0 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 1 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 2 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 3 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 4 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 5 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 6 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 7 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 8 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 9","title":"Repeat"},{"location":"shards/General/Repeat/#repeat","text":"( Repeat :Action [( Shard ) ( Seq [( Shard )])] :Times [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])])] :Forever [( Bool )] :Until [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Repeat"},{"location":"shards/General/Repeat/#definition","text":"Repeat an action a given number of times or until a condition is no longer true .","title":"Definition"},{"location":"shards/General/Repeat/#parameters","text":"Name Type Default Description Action [(Shard) (Seq [(Shard)])] None The shards to repeat. Times [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])])] 0 How many times we should repeat the action. Forever [(Bool)] false If we should repeat the action forever. Until [(Shard) (Seq [(Shard)]) (None)] None Optional shards to use as predicate to continue repeating until it's true","title":"Parameters"},{"location":"shards/General/Repeat/#input","text":"Type Description [(Any)] The input will be passed to both the action and the :Until condition if used.","title":"Input"},{"location":"shards/General/Repeat/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/General/Repeat/#examples","text":"Code Output 1 2 3 ( Repeat ( -> ( Msg \"Hello\" )) :Times 5 ) [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello [info] [2022-08-15 10:09:21.568] [T-1800] [logging.cpp::98] [shards/General/Repeat/1.edn] Hello Code Output 1 2 3 4 5 6 7 0 >= .n ( Repeat ( -> .n ( Log \"Counting\" ) ( Math.Inc .n )) :Forever true :Until ( -> .n ( IsMore 9 ))) [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 0 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 1 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 2 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 3 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 4 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 5 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 6 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 7 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 8 [info] [2022-08-15 10:09:21.625] [T-5556] [logging.cpp::53] [shards/General/Repeat/2.edn] Counting: 9","title":"Examples"},{"location":"shards/General/Replace/","text":"Replace \u00b6 ( Replace :Patterns [( None ) ( Seq [( String )]) ( ContextVar [( Seq [( String )])]) ( ContextVar [( Seq [( Any )])]) ( Seq [( Any )])] :Replacements [( None ) ( Any ) ( ContextVar [( Any )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Patterns [(None) (Seq [(String)]) (ContextVar [(Seq [(String)])]) (ContextVar [(Seq [(Any)])]) (Seq [(Any)])] None The patterns to find. Replacements [(None) (Any) (ContextVar [(Any)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] None The replacements to apply to the input, if a single value is provided every match will be replaced with that single value. Input \u00b6 Type Description [(Seq [(Any)]) (String)] Output \u00b6 Type Description [(Seq [(Any)]) (String)]","title":"Replace"},{"location":"shards/General/Replace/#replace","text":"( Replace :Patterns [( None ) ( Seq [( String )]) ( ContextVar [( Seq [( String )])]) ( ContextVar [( Seq [( Any )])]) ( Seq [( Any )])] :Replacements [( None ) ( Any ) ( ContextVar [( Any )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Replace"},{"location":"shards/General/Replace/#definition","text":"","title":"Definition"},{"location":"shards/General/Replace/#parameters","text":"Name Type Default Description Patterns [(None) (Seq [(String)]) (ContextVar [(Seq [(String)])]) (ContextVar [(Seq [(Any)])]) (Seq [(Any)])] None The patterns to find. Replacements [(None) (Any) (ContextVar [(Any)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] None The replacements to apply to the input, if a single value is provided every match will be replaced with that single value.","title":"Parameters"},{"location":"shards/General/Replace/#input","text":"Type Description [(Seq [(Any)]) (String)]","title":"Input"},{"location":"shards/General/Replace/#output","text":"Type Description [(Seq [(Any)]) (String)]","title":"Output"},{"location":"shards/General/ResizeImage/","text":"ResizeImage \u00b6 ( ResizeImage :Width [( Int )] :Height [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Width [(Int)] 32 The target width. Height [(Int)] 32 How target height. Input \u00b6 Type Description [(Image)] Output \u00b6 Type Description [(Image)]","title":"ResizeImage"},{"location":"shards/General/ResizeImage/#resizeimage","text":"( ResizeImage :Width [( Int )] :Height [( Int )] )","title":"ResizeImage"},{"location":"shards/General/ResizeImage/#definition","text":"","title":"Definition"},{"location":"shards/General/ResizeImage/#parameters","text":"Name Type Default Description Width [(Int)] 32 The target width. Height [(Int)] 32 How target height.","title":"Parameters"},{"location":"shards/General/ResizeImage/#input","text":"Type Description [(Image)]","title":"Input"},{"location":"shards/General/ResizeImage/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/General/Restart/","text":"Restart \u00b6 ( Restart ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(None)]","title":"Restart"},{"location":"shards/General/Restart/#restart","text":"( Restart )","title":"Restart"},{"location":"shards/General/Restart/#definition","text":"","title":"Definition"},{"location":"shards/General/Restart/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Restart/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/General/Resume/","text":"Resume \u00b6 ( Resume :Wire [( Wire ) ( String ) ( None )] ) Definition \u00b6 Resumes a given wire and suspends the current one. In other words, switches flow execution to another wire. Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None)] None The name of the wire to switch to. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 ( defwire hello ( Msg \"Hello\" ) ( Resume )) ( Start hello ) ( Msg \"World\" ) [info] [2022-08-15 10:09:21.682] [T-3440] [logging.cpp::98] [hello] Hello [info] [2022-08-15 10:09:21.683] [T-3440] [logging.cpp::98] [shards/General/Resume/Resume.edn] World","title":"Resume"},{"location":"shards/General/Resume/#resume","text":"( Resume :Wire [( Wire ) ( String ) ( None )] )","title":"Resume"},{"location":"shards/General/Resume/#definition","text":"Resumes a given wire and suspends the current one. In other words, switches flow execution to another wire.","title":"Definition"},{"location":"shards/General/Resume/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None)] None The name of the wire to switch to.","title":"Parameters"},{"location":"shards/General/Resume/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Resume/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Resume/#examples","text":"Code Output 1 2 3 4 5 6 ( defwire hello ( Msg \"Hello\" ) ( Resume )) ( Start hello ) ( Msg \"World\" ) [info] [2022-08-15 10:09:21.682] [T-3440] [logging.cpp::98] [hello] Hello [info] [2022-08-15 10:09:21.683] [T-3440] [logging.cpp::98] [shards/General/Resume/Resume.edn] World","title":"Examples"},{"location":"shards/General/Return/","text":"Return \u00b6 ( Return ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(None)]","title":"Return"},{"location":"shards/General/Return/#return","text":"( Return )","title":"Return"},{"location":"shards/General/Return/#definition","text":"","title":"Definition"},{"location":"shards/General/Return/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Return/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/General/Reverse/","text":"Reverse \u00b6 ( Reverse ) Definition \u00b6 Input \u00b6 Type Description [(Seq [(Any)]) (String) (Bytes)] Output \u00b6 Type Description [(Seq [(Any)]) (String) (Bytes)]","title":"Reverse"},{"location":"shards/General/Reverse/#reverse","text":"( Reverse )","title":"Reverse"},{"location":"shards/General/Reverse/#definition","text":"","title":"Definition"},{"location":"shards/General/Reverse/#input","text":"Type Description [(Seq [(Any)]) (String) (Bytes)]","title":"Input"},{"location":"shards/General/Reverse/#output","text":"Type Description [(Seq [(Any)]) (String) (Bytes)]","title":"Output"},{"location":"shards/General/Sequence/","text":"Sequence \u00b6 ( Sequence :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Clear [( Bool )] :Types [( Enum ) ( Seq [( Enum )]) ( Seq [( Enum ) ( Seq [( Enum )]) ( Self )])] ) Definition \u00b6 Creates an empty sequence (or table if a key is passed). Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Clear [(Bool)] true If we should clear this sequence at every wire iteration; works only if this is the first push; default: true. Types [(Enum) (Seq [(Enum)]) (Seq [(Enum) (Seq [(Enum)]) (Self)])] Enum: 1 vendor: 0x66726167 type: 0x74797065 The sequence inner types to forward declare. Input \u00b6 Type Description [(Any)] Any input is ignored. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Sequence creates an empty sequence when the :Key parameter is not set. If a key is passed via this parameter Sequence creates an empty table instead (behaving like the Table shard). The created sequence name is defined in the :Name parameter. This shard can control the scope of the created sequence variable. A true value for the :Global parameter makes the scope of the sequence global (available to all wires on the mesh), and a false value makes the scope local (available only to the wire its defined in). By default a sequence created with this shard would be cleared (emptied) every time the wire is executed (since :Clear is true by default). To retain the sequence values across wire iterations set the :Clear parameter to false . This shard can also define the sequence's inner data types via the :Types parameter. More than one data type may be set. Any input to this shard is ignored and instead passed through as its output. See also Get Push Set Table Update Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; without key, without types, local scope, :Clear true, using `Push` ( Sequence :Name .seqA ) .seqA ( Log ) ;; created an empty sequence => [] 1 ( Push .seqA ) .seqA ( Log ) ;; updated sequence => [1] 2 ( Push .seqA ) .seqA ( Log ) ;; updated sequence => [1, 2] ;; with key (becomes table), single type, global scope, :Clear true, using `Set` ( Sequence .seqB :Key \"A\" :Global true :Types Type.Float ) .seqB ( Log ) ;; created an empty table => {A: []} 10.2 ( Set .seqB \"A\" ) .seqB ( Log ) ;; updated table => {A: 10.2} 20.1 ( Set .seqB \"A\" ) .seqB ( Log ) ;; updated table => {A: 20.1} ;; without key, multiple types, local scope, :Clear false, using `Push` ( Sequence .seqC :Types [ Type.Float Type.Int ] :Clear false ) .seqC ( Log ) ;; created an empty sequence => [] 10.3 ( Push .seqC ) .seqC ( Log ) ;; updated sequence => [10.3] 20 ( Push .seqC ) .seqC ( Log ) ;; updated sequence => [10.3, 20] ;; with key (becomes table), single type, local scope, :Clear true, using `Push` ;; (Sequence .seqD :Key \"A\" :Types Type.Int) ;; .seqD (Log) ;; created an empty table => {A: []} 10 ( Push .seqD \"A\" ) .seqD ( Log ) ;; updated table => {A: [10]} 20 ( Push .seqD \"A\" ) .seqD ( Log ) ;; updated table => {A: [10, 20]} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [1] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [1, 2] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: []} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: 10.2} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: 20.1} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [10.3] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [10.3, 20] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: [10]} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: [10, 20]}","title":"Sequence"},{"location":"shards/General/Sequence/#sequence","text":"( Sequence :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Clear [( Bool )] :Types [( Enum ) ( Seq [( Enum )]) ( Seq [( Enum ) ( Seq [( Enum )]) ( Self )])] )","title":"Sequence"},{"location":"shards/General/Sequence/#definition","text":"Creates an empty sequence (or table if a key is passed).","title":"Definition"},{"location":"shards/General/Sequence/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Clear [(Bool)] true If we should clear this sequence at every wire iteration; works only if this is the first push; default: true. Types [(Enum) (Seq [(Enum)]) (Seq [(Enum) (Seq [(Enum)]) (Self)])] Enum: 1 vendor: 0x66726167 type: 0x74797065 The sequence inner types to forward declare.","title":"Parameters"},{"location":"shards/General/Sequence/#input","text":"Type Description [(Any)] Any input is ignored.","title":"Input"},{"location":"shards/General/Sequence/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Sequence/#details","text":"Sequence creates an empty sequence when the :Key parameter is not set. If a key is passed via this parameter Sequence creates an empty table instead (behaving like the Table shard). The created sequence name is defined in the :Name parameter. This shard can control the scope of the created sequence variable. A true value for the :Global parameter makes the scope of the sequence global (available to all wires on the mesh), and a false value makes the scope local (available only to the wire its defined in). By default a sequence created with this shard would be cleared (emptied) every time the wire is executed (since :Clear is true by default). To retain the sequence values across wire iterations set the :Clear parameter to false . This shard can also define the sequence's inner data types via the :Types parameter. More than one data type may be set. Any input to this shard is ignored and instead passed through as its output. See also Get Push Set Table Update","title":"Details"},{"location":"shards/General/Sequence/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; without key, without types, local scope, :Clear true, using `Push` ( Sequence :Name .seqA ) .seqA ( Log ) ;; created an empty sequence => [] 1 ( Push .seqA ) .seqA ( Log ) ;; updated sequence => [1] 2 ( Push .seqA ) .seqA ( Log ) ;; updated sequence => [1, 2] ;; with key (becomes table), single type, global scope, :Clear true, using `Set` ( Sequence .seqB :Key \"A\" :Global true :Types Type.Float ) .seqB ( Log ) ;; created an empty table => {A: []} 10.2 ( Set .seqB \"A\" ) .seqB ( Log ) ;; updated table => {A: 10.2} 20.1 ( Set .seqB \"A\" ) .seqB ( Log ) ;; updated table => {A: 20.1} ;; without key, multiple types, local scope, :Clear false, using `Push` ( Sequence .seqC :Types [ Type.Float Type.Int ] :Clear false ) .seqC ( Log ) ;; created an empty sequence => [] 10.3 ( Push .seqC ) .seqC ( Log ) ;; updated sequence => [10.3] 20 ( Push .seqC ) .seqC ( Log ) ;; updated sequence => [10.3, 20] ;; with key (becomes table), single type, local scope, :Clear true, using `Push` ;; (Sequence .seqD :Key \"A\" :Types Type.Int) ;; .seqD (Log) ;; created an empty table => {A: []} 10 ( Push .seqD \"A\" ) .seqD ( Log ) ;; updated table => {A: [10]} 20 ( Push .seqD \"A\" ) .seqD ( Log ) ;; updated table => {A: [10, 20]} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [1] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [1, 2] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: []} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: 10.2} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: 20.1} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [10.3] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] [10.3, 20] [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: [10]} [info] [2022-08-15 10:09:21.799] [T-3492] [logging.cpp::55] [shards/General/Sequence/Sequence.edn] {A: [10, 20]}","title":"Examples"},{"location":"shards/General/Set/","text":"Set \u00b6 ( Set :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Creates a mutable variable and assigns a value to it. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(Any)] Input becomes the value of the variable being created. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Set creates a mutable variable and assigns a value to it. Once created this variable can be modified. The name of the variable comes from the :Name parameter and the variable value comes from the input. The type of input controls the kind of variable that will created: numeric input creates numeric variable, string input creates string variable, and sequence input would create a sequence variable. To create a table variable, along with the input, you also have to pass the key in the :Key parameter. In this case the input (whatever it may be - numeric, string, sequence) becomes the value of the key that was passed in parameter :Key . The :Global parameter controls whether the created variables can be referenced across wires ( :Global set to true ) or only within the current wire ( :Global set to false , default behaviour). Though it will generate a warning Set can also be used to update existing variables (like adding a new key-value pair to an existing table). Note Do not use Push to update any variables created by Set (or its aliases >= / >>= ). Such variables are best best updated by Set itself (all types of variables) or AppendTo (only sequences and string variables). Variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh). Hence, in update mode (i.e. when you apply Set to an existing variable) the :Global parameter is used in conjunction with the :Name parameter to identify the correct variable to update. The input to this shard is used as the value for the variable being created and is also passed through as this shard's output. Note Set has two aliases: >= is an alias for (Set ... :Global false) while >== is an alias for (Set ... :Global true) . See the code examples at the end to understand how these aliases are used. See also AppendTo Const Get PrependTo Ref Sequence Table Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ;; create a mutable string variable, modify it (by default available only to current wire) \"Hello\" ( Set :Name .svar ) .svar ( Log \".svar\" ) ;; => .svar: Hello \"World\" ( Update .svar ) ;; modify string variable .svar ( Log \"modified .svar\" ) ;; => .svar: World ;; create a mutable numeric variable, modify it (available to all wires because `:Global true`) 100 ( Set :Name .nvar :Global true ) .nvar ( Log \".nvar\" ) ;; => .nvar: 100 200 ( Update .nvar ) ;; modify numeric variable .nvar ( Log \"modified .nvar\" ) ;; => modified .nvar: 200 ;; create a mutable sequence [ 10 20 30 ] ( Set :Name .sequence ) .sequence ( Log \".sequence\" ) ;; => .sequence: [10, 20, 30] ;; create a mutable table ( Const [ \"a\" \"b\" ]) ( Set :Name \"table\" :Key \"key1\" ) .table ( Log \".table\" ) ;; => .table: {key1: [a, b]} ;; add a key-value pair to existing mutable table (will generate warnings) \"def\" ( Set \"table\" :Key \"key2\" ) ;; add new key .table ( Log \"modified .table\" ) ;; => modified .table: {key2: def, key1: [a, b]} ;; Using `Set` aliases ;; `>=` is alias for `(Set :Global false)`: create a mutable string variable \"World\" >= .svarA .svarA ( Log \".svarA\" ) ;; => .svarA: World ;; `>==` is alias for `(Set :Global true)`: create a mutable numeric variable 100 >== .nvarA .nvarA ( Log \".nvarA\" ) ;; => .nvarA: 100 ;; create and update local/global variables \"Local\" ( Set .str ) ;; create local variable \"Global\" ( Set .str :Global true ) ;; create same-name global variable ( Get .str ) ( Log ) ;; get updated local variable => \"Local\" ( Get .str :Global true ) ( Log ) ;; get same-name updated global variable => \"Global\" \"LocalNew\" ( Set .str ) ;; create local variable \"GlobalNew\" ( Set .str :Global true ) ;; create same-name global variable ( Get .str ) ( Log ) ;; get updated local variable => \"LocalNew\" ( Get .str :Global true ) ( Log ) ;; get same-name updated global variable => \"GlobalNew\" [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .svar: Hello [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] modified .svar: World [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .nvar: 100 [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] modified .nvar: 200 [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .sequence: [10, 20, 30] [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .table: {key1: [a, b]} [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] modified .table: {key2: def, key1: [a, b]} [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .svarA: World [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .nvarA: 100 [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] Local [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] Global [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] LocalNew [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] GlobalNew","title":"Set"},{"location":"shards/General/Set/#set","text":"( Set :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Set"},{"location":"shards/General/Set/#definition","text":"Creates a mutable variable and assigns a value to it.","title":"Definition"},{"location":"shards/General/Set/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Set/#input","text":"Type Description [(Any)] Input becomes the value of the variable being created.","title":"Input"},{"location":"shards/General/Set/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Set/#details","text":"Set creates a mutable variable and assigns a value to it. Once created this variable can be modified. The name of the variable comes from the :Name parameter and the variable value comes from the input. The type of input controls the kind of variable that will created: numeric input creates numeric variable, string input creates string variable, and sequence input would create a sequence variable. To create a table variable, along with the input, you also have to pass the key in the :Key parameter. In this case the input (whatever it may be - numeric, string, sequence) becomes the value of the key that was passed in parameter :Key . The :Global parameter controls whether the created variables can be referenced across wires ( :Global set to true ) or only within the current wire ( :Global set to false , default behaviour). Though it will generate a warning Set can also be used to update existing variables (like adding a new key-value pair to an existing table). Note Do not use Push to update any variables created by Set (or its aliases >= / >>= ). Such variables are best best updated by Set itself (all types of variables) or AppendTo (only sequences and string variables). Variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh). Hence, in update mode (i.e. when you apply Set to an existing variable) the :Global parameter is used in conjunction with the :Name parameter to identify the correct variable to update. The input to this shard is used as the value for the variable being created and is also passed through as this shard's output. Note Set has two aliases: >= is an alias for (Set ... :Global false) while >== is an alias for (Set ... :Global true) . See the code examples at the end to understand how these aliases are used. See also AppendTo Const Get PrependTo Ref Sequence Table","title":"Details"},{"location":"shards/General/Set/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ;; create a mutable string variable, modify it (by default available only to current wire) \"Hello\" ( Set :Name .svar ) .svar ( Log \".svar\" ) ;; => .svar: Hello \"World\" ( Update .svar ) ;; modify string variable .svar ( Log \"modified .svar\" ) ;; => .svar: World ;; create a mutable numeric variable, modify it (available to all wires because `:Global true`) 100 ( Set :Name .nvar :Global true ) .nvar ( Log \".nvar\" ) ;; => .nvar: 100 200 ( Update .nvar ) ;; modify numeric variable .nvar ( Log \"modified .nvar\" ) ;; => modified .nvar: 200 ;; create a mutable sequence [ 10 20 30 ] ( Set :Name .sequence ) .sequence ( Log \".sequence\" ) ;; => .sequence: [10, 20, 30] ;; create a mutable table ( Const [ \"a\" \"b\" ]) ( Set :Name \"table\" :Key \"key1\" ) .table ( Log \".table\" ) ;; => .table: {key1: [a, b]} ;; add a key-value pair to existing mutable table (will generate warnings) \"def\" ( Set \"table\" :Key \"key2\" ) ;; add new key .table ( Log \"modified .table\" ) ;; => modified .table: {key2: def, key1: [a, b]} ;; Using `Set` aliases ;; `>=` is alias for `(Set :Global false)`: create a mutable string variable \"World\" >= .svarA .svarA ( Log \".svarA\" ) ;; => .svarA: World ;; `>==` is alias for `(Set :Global true)`: create a mutable numeric variable 100 >== .nvarA .nvarA ( Log \".nvarA\" ) ;; => .nvarA: 100 ;; create and update local/global variables \"Local\" ( Set .str ) ;; create local variable \"Global\" ( Set .str :Global true ) ;; create same-name global variable ( Get .str ) ( Log ) ;; get updated local variable => \"Local\" ( Get .str :Global true ) ( Log ) ;; get same-name updated global variable => \"Global\" \"LocalNew\" ( Set .str ) ;; create local variable \"GlobalNew\" ( Set .str :Global true ) ;; create same-name global variable ( Get .str ) ( Log ) ;; get updated local variable => \"LocalNew\" ( Get .str :Global true ) ( Log ) ;; get same-name updated global variable => \"GlobalNew\" [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.858] [T-1368] [core.hpp::683] Set - Warning: setting an already exposed variable, use Update to avoid this warning, variable: str [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .svar: Hello [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] modified .svar: World [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .nvar: 100 [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] modified .nvar: 200 [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .sequence: [10, 20, 30] [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .table: {key1: [a, b]} [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] modified .table: {key2: def, key1: [a, b]} [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .svarA: World [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::53] [shards/General/Set/Set.edn] .nvarA: 100 [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] Local [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] Global [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] LocalNew [info] [2022-08-15 10:09:21.859] [T-1368] [logging.cpp::55] [shards/General/Set/Set.edn] GlobalNew","title":"Examples"},{"location":"shards/General/SleepBlocking%21/","text":"SleepBlocking! \u00b6 ( SleepBlocking! ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"SleepBlocking!"},{"location":"shards/General/SleepBlocking%21/#sleepblocking","text":"( SleepBlocking! )","title":"SleepBlocking!"},{"location":"shards/General/SleepBlocking%21/#definition","text":"","title":"Definition"},{"location":"shards/General/SleepBlocking%21/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/SleepBlocking%21/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Slice/","text":"Slice \u00b6 ( Slice :From [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])])] :To [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])]) ( None )] :Step [( Int )] ) Definition \u00b6 Extracts characters from a string or elements from a sequence based on the start and end positions/indices and an increment parameter. Operation is non-destructive; the target string/sequence is not modified. Parameters \u00b6 Name Type Default Description From [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])])] 0 The position/index of the first character or element that is to be extracted (including). Negative position/indices simply loop over the target string/sequence counting backwards. To [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])]) (None)] None The position/index of the last character or element that is to be extracted (excluding). Negative position/indices simply loop over the target string/sequence counting backwards. Step [(Int)] 1 The increment between each position/index. Chooses every nth sample to extract, where n is the increment. Value has to be greater than zero. Input \u00b6 Type Description [(Seq [(Any)]) (Bytes) (String)] The string or sequence from which characters/elements have to be extracted. Output \u00b6 Type Description [(Any)] The extracted characters/elements. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; Slice on strings \"Hello World\" ( Slice :From 1 :To 3 :Step 1 ) ( Log ) ;; => \"el\" \"Hello World\" ( Slice 0 11 2 ) ( Log ) ;; => \"HloWrd\" ;; Slice on sequences [ 10 20 30 40 50 60 70 80 90 ] ( Slice 1 3 1 ) ( Log ) ;; => [20, 30] [ 10 20 30 40 50 60 70 80 90 ] ( Slice 0 7 3 ) ( Log ) ;; => [10, 40, 70] [ 10 20 30 40 50 60 70 80 90 ] ( Slice -9 -2 3 ) ( Log ) ;; => [10, 40, 70] : index -9 is same as 0, index -2 is same as 7 [info] [2022-08-15 10:09:21.918] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] el [info] [2022-08-15 10:09:21.918] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] HloWrd [info] [2022-08-15 10:09:21.919] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] [20, 30] [info] [2022-08-15 10:09:21.919] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] [10, 40, 70] [info] [2022-08-15 10:09:21.919] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] [10, 40, 70]","title":"Slice"},{"location":"shards/General/Slice/#slice","text":"( Slice :From [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])])] :To [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])]) ( None )] :Step [( Int )] )","title":"Slice"},{"location":"shards/General/Slice/#definition","text":"Extracts characters from a string or elements from a sequence based on the start and end positions/indices and an increment parameter. Operation is non-destructive; the target string/sequence is not modified.","title":"Definition"},{"location":"shards/General/Slice/#parameters","text":"Name Type Default Description From [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])])] 0 The position/index of the first character or element that is to be extracted (including). Negative position/indices simply loop over the target string/sequence counting backwards. To [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])]) (None)] None The position/index of the last character or element that is to be extracted (excluding). Negative position/indices simply loop over the target string/sequence counting backwards. Step [(Int)] 1 The increment between each position/index. Chooses every nth sample to extract, where n is the increment. Value has to be greater than zero.","title":"Parameters"},{"location":"shards/General/Slice/#input","text":"Type Description [(Seq [(Any)]) (Bytes) (String)] The string or sequence from which characters/elements have to be extracted.","title":"Input"},{"location":"shards/General/Slice/#output","text":"Type Description [(Any)] The extracted characters/elements.","title":"Output"},{"location":"shards/General/Slice/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 ;; Slice on strings \"Hello World\" ( Slice :From 1 :To 3 :Step 1 ) ( Log ) ;; => \"el\" \"Hello World\" ( Slice 0 11 2 ) ( Log ) ;; => \"HloWrd\" ;; Slice on sequences [ 10 20 30 40 50 60 70 80 90 ] ( Slice 1 3 1 ) ( Log ) ;; => [20, 30] [ 10 20 30 40 50 60 70 80 90 ] ( Slice 0 7 3 ) ( Log ) ;; => [10, 40, 70] [ 10 20 30 40 50 60 70 80 90 ] ( Slice -9 -2 3 ) ( Log ) ;; => [10, 40, 70] : index -9 is same as 0, index -2 is same as 7 [info] [2022-08-15 10:09:21.918] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] el [info] [2022-08-15 10:09:21.918] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] HloWrd [info] [2022-08-15 10:09:21.919] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] [20, 30] [info] [2022-08-15 10:09:21.919] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] [10, 40, 70] [info] [2022-08-15 10:09:21.919] [T-5336] [logging.cpp::55] [shards/General/Slice/1.edn] [10, 40, 70]","title":"Examples"},{"location":"shards/General/Sort/","text":"Sort \u00b6 ( Sort :From [( ContextVar [( Seq [( Any )])])] :Join [( ContextVar [( Seq [( Any )])]) ( Seq [( ContextVar [( Seq [( Any )])])])] :Desc [( Bool )] :Key [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Sorts the elements of a sequence. Can also move around the elements of a joined sequence in alignment with the sorted sequence. Parameters \u00b6 Name Type Default Description From [(ContextVar [(Seq [(Any)])])] None The name of the sequence variable to edit in place. Join [(ContextVar [(Seq [(Any)])]) (Seq [(ContextVar [(Seq [(Any)])])])] None Other columns to join sort/filter using the input (they must be of the same length). Desc [(Bool)] false If sorting should be in descending order, defaults ascending. Key [(Shard) (Seq [(Shard)]) (None)] None The shards to use to transform the collection's items before they are compared. Can be None. Input \u00b6 Type Description [(None)] Any input is ignored. Output \u00b6 Type Description [(Seq [(Any)])] Output is the sorted sequence. Details \u00b6 Sort sorts all the elements of the sequence that has been passed to it in the :Name parameter based on the value of the :Desc parameter. If :Desc is set to true the sequence is sorted in descending order, else it's sorted in the ascending order (which is the default behaviour). This shard can also take final element order of the sorted sequence and apply that to a joined sequence (passed via the :Join parameter). For example, if the element at index-7 moved to index-3 in the main sequence due to sorting then in the joined sequence too the element at index-7 would move to index-3. The movement of all elements in the main sequence (post-sort) would be mirrored in the joined sequence. For this to work both the sequences must have the same length. Note Think of this as the Shards equivalent of a relational database inner join. The main sequence and the joined sequence can be thought of as columns from two different tables inner joined over indices equality. So that the changes in elements of one sequence (rows in the first table) can be propogated to the corresponding elements of the joined sequence (corresponding rows in the joined table). In this case the operation is changing of indices (position) of selected elements (selected rows) in one sequence (table) leading to an equivalent change of indices (position) of corresponding elements (connected rows) of the joined sequence (joined table). The :Key parameter can take a shard or group of shards to transform the sequence elements before they're compared for sorting. This transformation doesn't actually change the value of the elements in the final sorted sequence (it's used only for sort comparisons). Sort works only on sequences. Any input to this shard is ignored and its output is the main sorted sequence. See also Remove Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; sort ascending (since default :Desc is false) [ 9 5 1 3 8 ] >= .seq1 ( Sort :From .seq1 ) .seq1 ( Log \"seq1\" ) ;; sorted ascending => seq1: [1, 3, 5, 8, 9] ; sorting descending (:Desc set to true) [ 9 5 1 3 8 ] >= .seq2 ( Sort .seq2 :Desc true ) .seq2 ( Log \"seq2\" ) ;; sorted ascending => seq2: [9, 8, 5, 3, 1] ;; sort ascending using a :Key [ 9 5 1 3 8 ] >= .seq3 ( Sort .seq3 :Key ( Math.Multiply -1 )) .seq3 ( Log \"seq3\" ) ;; :Key transform makes it look like descending sort => seq3: [9, 8, 5, 3, 1] ;; sort ascending with a joined sequence [ 9 5 1 3 8 ] >= .seq4 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] >= .seqJ ( Sort .seq4 :Join .seqJ ) .seq4 ( Log \"seq4\" ) ;; main sequence sorted in ascending order => seq4: [1, 3, 5, 8, 9] .seqJ ( Log \"seqJ\" ) ;; sorted order applied to joined sequence => seqJ: [c, d, b, e, a] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq1: [1, 3, 5, 8, 9] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq2: [9, 8, 5, 3, 1] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq3: [9, 8, 5, 3, 1] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq4: [1, 3, 5, 8, 9] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seqJ: [c, d, b, e, a]","title":"Sort"},{"location":"shards/General/Sort/#sort","text":"( Sort :From [( ContextVar [( Seq [( Any )])])] :Join [( ContextVar [( Seq [( Any )])]) ( Seq [( ContextVar [( Seq [( Any )])])])] :Desc [( Bool )] :Key [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Sort"},{"location":"shards/General/Sort/#definition","text":"Sorts the elements of a sequence. Can also move around the elements of a joined sequence in alignment with the sorted sequence.","title":"Definition"},{"location":"shards/General/Sort/#parameters","text":"Name Type Default Description From [(ContextVar [(Seq [(Any)])])] None The name of the sequence variable to edit in place. Join [(ContextVar [(Seq [(Any)])]) (Seq [(ContextVar [(Seq [(Any)])])])] None Other columns to join sort/filter using the input (they must be of the same length). Desc [(Bool)] false If sorting should be in descending order, defaults ascending. Key [(Shard) (Seq [(Shard)]) (None)] None The shards to use to transform the collection's items before they are compared. Can be None.","title":"Parameters"},{"location":"shards/General/Sort/#input","text":"Type Description [(None)] Any input is ignored.","title":"Input"},{"location":"shards/General/Sort/#output","text":"Type Description [(Seq [(Any)])] Output is the sorted sequence.","title":"Output"},{"location":"shards/General/Sort/#details","text":"Sort sorts all the elements of the sequence that has been passed to it in the :Name parameter based on the value of the :Desc parameter. If :Desc is set to true the sequence is sorted in descending order, else it's sorted in the ascending order (which is the default behaviour). This shard can also take final element order of the sorted sequence and apply that to a joined sequence (passed via the :Join parameter). For example, if the element at index-7 moved to index-3 in the main sequence due to sorting then in the joined sequence too the element at index-7 would move to index-3. The movement of all elements in the main sequence (post-sort) would be mirrored in the joined sequence. For this to work both the sequences must have the same length. Note Think of this as the Shards equivalent of a relational database inner join. The main sequence and the joined sequence can be thought of as columns from two different tables inner joined over indices equality. So that the changes in elements of one sequence (rows in the first table) can be propogated to the corresponding elements of the joined sequence (corresponding rows in the joined table). In this case the operation is changing of indices (position) of selected elements (selected rows) in one sequence (table) leading to an equivalent change of indices (position) of corresponding elements (connected rows) of the joined sequence (joined table). The :Key parameter can take a shard or group of shards to transform the sequence elements before they're compared for sorting. This transformation doesn't actually change the value of the elements in the final sorted sequence (it's used only for sort comparisons). Sort works only on sequences. Any input to this shard is ignored and its output is the main sorted sequence. See also Remove","title":"Details"},{"location":"shards/General/Sort/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; sort ascending (since default :Desc is false) [ 9 5 1 3 8 ] >= .seq1 ( Sort :From .seq1 ) .seq1 ( Log \"seq1\" ) ;; sorted ascending => seq1: [1, 3, 5, 8, 9] ; sorting descending (:Desc set to true) [ 9 5 1 3 8 ] >= .seq2 ( Sort .seq2 :Desc true ) .seq2 ( Log \"seq2\" ) ;; sorted ascending => seq2: [9, 8, 5, 3, 1] ;; sort ascending using a :Key [ 9 5 1 3 8 ] >= .seq3 ( Sort .seq3 :Key ( Math.Multiply -1 )) .seq3 ( Log \"seq3\" ) ;; :Key transform makes it look like descending sort => seq3: [9, 8, 5, 3, 1] ;; sort ascending with a joined sequence [ 9 5 1 3 8 ] >= .seq4 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] >= .seqJ ( Sort .seq4 :Join .seqJ ) .seq4 ( Log \"seq4\" ) ;; main sequence sorted in ascending order => seq4: [1, 3, 5, 8, 9] .seqJ ( Log \"seqJ\" ) ;; sorted order applied to joined sequence => seqJ: [c, d, b, e, a] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq1: [1, 3, 5, 8, 9] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq2: [9, 8, 5, 3, 1] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq3: [9, 8, 5, 3, 1] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seq4: [1, 3, 5, 8, 9] [info] [2022-08-15 10:09:21.977] [T-5880] [logging.cpp::53] [shards/General/Sort/Sort.edn] seqJ: [c, d, b, e, a]","title":"Examples"},{"location":"shards/General/Spawn/","text":"Spawn \u00b6 ( Spawn :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to spawn and try to run many times concurrently. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Wire)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 ( defwire logic ( IsMore 10 ) ( Or ) ( IsLess 0 )) 11 ( -> ( Spawn logic ) >= .ccc ( Wait .ccc )) ( Assert.Is true true )","title":"Spawn"},{"location":"shards/General/Spawn/#spawn","text":"( Spawn :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] )","title":"Spawn"},{"location":"shards/General/Spawn/#definition","text":"","title":"Definition"},{"location":"shards/General/Spawn/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to spawn and try to run many times concurrently.","title":"Parameters"},{"location":"shards/General/Spawn/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Spawn/#output","text":"Type Description [(Wire)]","title":"Output"},{"location":"shards/General/Spawn/#examples","text":"Code Output 1 2 3 4 5 6 7 ( defwire logic ( IsMore 10 ) ( Or ) ( IsLess 0 )) 11 ( -> ( Spawn logic ) >= .ccc ( Wait .ccc )) ( Assert.Is true true )","title":"Examples"},{"location":"shards/General/Start/","text":"Start \u00b6 ( Start :Wire [( Wire ) ( String ) ( None )] ) Definition \u00b6 Starts a given wire and suspends the current one. In other words, switches flow execution to another wire. Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None)] None The name of the wire to switch to. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 ( defwire hello ( Msg \"Hello\" )) ( Start hello ) [info] [2022-08-15 10:09:22.090] [T-6964] [logging.cpp::98] [hello] Hello","title":"Start"},{"location":"shards/General/Start/#start","text":"( Start :Wire [( Wire ) ( String ) ( None )] )","title":"Start"},{"location":"shards/General/Start/#definition","text":"Starts a given wire and suspends the current one. In other words, switches flow execution to another wire.","title":"Definition"},{"location":"shards/General/Start/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None)] None The name of the wire to switch to.","title":"Parameters"},{"location":"shards/General/Start/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Start/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Start/#examples","text":"Code Output 1 2 3 4 ( defwire hello ( Msg \"Hello\" )) ( Start hello ) [info] [2022-08-15 10:09:22.090] [T-6964] [logging.cpp::98] [hello] Hello","title":"Examples"},{"location":"shards/General/Step/","text":"Step \u00b6 ( Step :Wire [( Wire ) ( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 ( defwire hello ( Msg \"Hello\" )) ( Detach hello ) ( Step ;:Wire hello ) [info] [2022-08-15 10:09:22.148] [T-4008] [logging.cpp::98] [hello] Hello","title":"Step"},{"location":"shards/General/Step/#step","text":"( Step :Wire [( Wire ) ( String ) ( None )] )","title":"Step"},{"location":"shards/General/Step/#definition","text":"","title":"Definition"},{"location":"shards/General/Step/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None)] None The wire to run.","title":"Parameters"},{"location":"shards/General/Step/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Step/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Step/#examples","text":"Code Output 1 2 3 4 5 6 7 8 ( defwire hello ( Msg \"Hello\" )) ( Detach hello ) ( Step ;:Wire hello ) [info] [2022-08-15 10:09:22.148] [T-4008] [logging.cpp::98] [hello] Hello","title":"Examples"},{"location":"shards/General/Stop/","text":"Stop \u00b6 ( Stop :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Passthrough [( Bool )] ) Definition \u00b6 Stops another wire. If no wire is given, stops the current wire. Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to stop. Passthrough [(Bool)] false The output of this shard will be its input. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 ( defloop Loop ( Math.Add 1 ) ( Log ) ( Cond [( -> ( Is 5 )) ( Stop )]) ( Restart )) 0 ( Do Loop ) [info] [2022-08-15 10:09:22.204] [T-1760] [logging.cpp::55] [Loop] 1 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 2 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 3 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 4 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 5","title":"Stop"},{"location":"shards/General/Stop/#stop","text":"( Stop :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Passthrough [( Bool )] )","title":"Stop"},{"location":"shards/General/Stop/#definition","text":"Stops another wire. If no wire is given, stops the current wire.","title":"Definition"},{"location":"shards/General/Stop/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to stop. Passthrough [(Bool)] false The output of this shard will be its input.","title":"Parameters"},{"location":"shards/General/Stop/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Stop/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Stop/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 ( defloop Loop ( Math.Add 1 ) ( Log ) ( Cond [( -> ( Is 5 )) ( Stop )]) ( Restart )) 0 ( Do Loop ) [info] [2022-08-15 10:09:22.204] [T-1760] [logging.cpp::55] [Loop] 1 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 2 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 3 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 4 [info] [2022-08-15 10:09:22.205] [T-1760] [logging.cpp::55] [Loop] 5","title":"Examples"},{"location":"shards/General/StringToBytes/","text":"StringToBytes \u00b6 ( StringToBytes ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bytes)]","title":"StringToBytes"},{"location":"shards/General/StringToBytes/#stringtobytes","text":"( StringToBytes )","title":"StringToBytes"},{"location":"shards/General/StringToBytes/#definition","text":"","title":"Definition"},{"location":"shards/General/StringToBytes/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/StringToBytes/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/StripAlpha/","text":"StripAlpha \u00b6 ( StripAlpha ) Definition \u00b6 Input \u00b6 Type Description [(Image)] Output \u00b6 Type Description [(Image)]","title":"StripAlpha"},{"location":"shards/General/StripAlpha/#stripalpha","text":"( StripAlpha )","title":"StripAlpha"},{"location":"shards/General/StripAlpha/#definition","text":"","title":"Definition"},{"location":"shards/General/StripAlpha/#input","text":"Type Description [(Image)]","title":"Input"},{"location":"shards/General/StripAlpha/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/General/Sub/","text":"Sub \u00b6 ( Sub :Shards [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Activates a shard or a sequence of shards independently, without consuming the input. I.e. the input of the Sub flow will also be its output regardless of the shards activated in this Sub flow. Parameters \u00b6 Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shard or sequence of shards to execute in the Sub flow. Input \u00b6 Type Description [(Any)] The input value passed to this Sub flow (and hence to the shard or sequence of shards in this Sub flow). Output \u00b6 Type Description [(Any)] The output of this Sub flow (which is the same as its input). Details \u00b6 In Shards a shard receives an input, processes it, and produces an output. Usually this output is different from the input that the shard processed. However, in some cases, we want a shard (or a sequence of shards) to return the same value as its output that it received as an input. For example, when we want a shard to process the same input that its previous shard (or sequence of shards) processed, irrespective of the output created by the previous shard(s). There is a pass-through parameter available for some shards (like Match ) that can allows these shards to pass-through their own input as their output. For other shards, we can use the Sub shard (also called the Sub flow) to acheive the same effect by wrapping the target shard(s) within the Sub . When a Sub shard recieves an input, it passes that to the first shard contained within it. This shard processes the input and creates its own ouput that is then passed to the next shard in the sequence inside the Sub flow. This continues till the last shard in the flow is reached. The output of this last shard is not used by the Sub flow. Instead the Sub flow outputs the same value that it had received as input. While Sub may seem to not use any of its internal shards' inputs or outputs, every variable assigned inside the Sub will be available outside as well since the Sub will always be executed. Hence, the inputs and outputs of the shards within the Sub flow can be made available outside the Sub by saving them into Sub variables. As a result, this method gives a psuedo pass-through capabilty to any shard (if you wrap just that one shard with a Sub shard) or to any sequence of shards (if you wrap a whole sequence of shards within a Sub shard). By nesting Sub shards you can simulate even more flexible and powerful shard execution paths. Note Sub has an alias | which is more convenient to use. | also removes the need to use -> as, unlike Sub , it doesn't require the parameter shards to be grouped together. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ;; Sub container shard + nesting ( int 5 ) ( Log \"input to Sub1\" ) ;; => 5 ( Sub ;; Sub1: a set of shard sequences ;:Shards ( -> ( Math.Multiply 2 ) ( Assert.Is 10 true ) ( Log \"Sub1 inner shard o/p | 5 * 2\" ) ;; => 10 )) ( Log \"Sub1 output => input to Sub2\" ) ;; => 5 ( Sub ;; Sub2: another set of shard sequences ;:Shards ( -> ( Math.Multiply 3 ) ( Assert.Is 15 true ) ( Log \"Sub2 inner shard o/p | 5 * 3\" ) ;; => 15 ( Log \"input to nested-Sub\" ) ;; => 15 ( Sub ;; nesting of Sub shards ;:Shards ( -> ( Math.Multiply 2 ) ( Assert.Is 30 true ) ( Log \"nested-Sub inner shard o/p | (5 * 3) * 2\" ) ;; => 30 )) ( Log \"output from nested Sub\" ) ;; => 15 )) ( Log \"Sub2 output => output\" ) ;; => 5 [info] [2022-08-15 10:09:22.261] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] input to Sub1: 5 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub1 inner shard o/p | 5 * 2: 10 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub1 output => input to Sub2: 5 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub2 inner shard o/p | 5 * 3: 15 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] input to nested-Sub: 15 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] nested-Sub inner shard o/p | (5 * 3) * 2: 30 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] output from nested Sub: 15 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub2 output => output: 5 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; Using `Sub`, with `->` ( int 5 ) ;; input to `Sub` shards ( Sub ( -> ( Math.Multiply 2 ) ( Log ))) ;; 5 * 2 => 10 ( Sub ( -> ( Math.Multiply 3 ) ( Log ) ;; 5 * 3 => 15 ( Sub ( -> ( Math.Multiply 2 ) ( Log ))))) ;; 15 * 2 => 30 ( Log \"output of the last `Sub` shard\" ) ;; input is output => 5 ;; Using `|`, no need for `->` ( int 100 ) ;; input to `|` shards ( | ( Math.Multiply 2 ) ( Log )) ;; 100 * 2 => 200 ( | ( Math.Multiply 3 ) ( Log ) ;; 100 * 3 => 300 ( | ( Math.Multiply 2 ) ( Log ))) ;; 300 * 2 => 600 ( Log \"output of the last `|` shard\" ) ;; input is output => 100 [info] [2022-08-15 10:09:22.319] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 10 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 15 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 30 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::53] [shards/General/Sub/2.edn] output of the last `Sub` shard: 5 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 200 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 300 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 600 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::53] [shards/General/Sub/2.edn] output of the last `|` shard: 100","title":"Sub"},{"location":"shards/General/Sub/#sub","text":"( Sub :Shards [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Sub"},{"location":"shards/General/Sub/#definition","text":"Activates a shard or a sequence of shards independently, without consuming the input. I.e. the input of the Sub flow will also be its output regardless of the shards activated in this Sub flow.","title":"Definition"},{"location":"shards/General/Sub/#parameters","text":"Name Type Default Description Shards [(Shard) (Seq [(Shard)]) (None)] None The shard or sequence of shards to execute in the Sub flow.","title":"Parameters"},{"location":"shards/General/Sub/#input","text":"Type Description [(Any)] The input value passed to this Sub flow (and hence to the shard or sequence of shards in this Sub flow).","title":"Input"},{"location":"shards/General/Sub/#output","text":"Type Description [(Any)] The output of this Sub flow (which is the same as its input).","title":"Output"},{"location":"shards/General/Sub/#details","text":"In Shards a shard receives an input, processes it, and produces an output. Usually this output is different from the input that the shard processed. However, in some cases, we want a shard (or a sequence of shards) to return the same value as its output that it received as an input. For example, when we want a shard to process the same input that its previous shard (or sequence of shards) processed, irrespective of the output created by the previous shard(s). There is a pass-through parameter available for some shards (like Match ) that can allows these shards to pass-through their own input as their output. For other shards, we can use the Sub shard (also called the Sub flow) to acheive the same effect by wrapping the target shard(s) within the Sub . When a Sub shard recieves an input, it passes that to the first shard contained within it. This shard processes the input and creates its own ouput that is then passed to the next shard in the sequence inside the Sub flow. This continues till the last shard in the flow is reached. The output of this last shard is not used by the Sub flow. Instead the Sub flow outputs the same value that it had received as input. While Sub may seem to not use any of its internal shards' inputs or outputs, every variable assigned inside the Sub will be available outside as well since the Sub will always be executed. Hence, the inputs and outputs of the shards within the Sub flow can be made available outside the Sub by saving them into Sub variables. As a result, this method gives a psuedo pass-through capabilty to any shard (if you wrap just that one shard with a Sub shard) or to any sequence of shards (if you wrap a whole sequence of shards within a Sub shard). By nesting Sub shards you can simulate even more flexible and powerful shard execution paths. Note Sub has an alias | which is more convenient to use. | also removes the need to use -> as, unlike Sub , it doesn't require the parameter shards to be grouped together.","title":"Details"},{"location":"shards/General/Sub/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ;; Sub container shard + nesting ( int 5 ) ( Log \"input to Sub1\" ) ;; => 5 ( Sub ;; Sub1: a set of shard sequences ;:Shards ( -> ( Math.Multiply 2 ) ( Assert.Is 10 true ) ( Log \"Sub1 inner shard o/p | 5 * 2\" ) ;; => 10 )) ( Log \"Sub1 output => input to Sub2\" ) ;; => 5 ( Sub ;; Sub2: another set of shard sequences ;:Shards ( -> ( Math.Multiply 3 ) ( Assert.Is 15 true ) ( Log \"Sub2 inner shard o/p | 5 * 3\" ) ;; => 15 ( Log \"input to nested-Sub\" ) ;; => 15 ( Sub ;; nesting of Sub shards ;:Shards ( -> ( Math.Multiply 2 ) ( Assert.Is 30 true ) ( Log \"nested-Sub inner shard o/p | (5 * 3) * 2\" ) ;; => 30 )) ( Log \"output from nested Sub\" ) ;; => 15 )) ( Log \"Sub2 output => output\" ) ;; => 5 [info] [2022-08-15 10:09:22.261] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] input to Sub1: 5 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub1 inner shard o/p | 5 * 2: 10 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub1 output => input to Sub2: 5 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub2 inner shard o/p | 5 * 3: 15 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] input to nested-Sub: 15 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] nested-Sub inner shard o/p | (5 * 3) * 2: 30 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] output from nested Sub: 15 [info] [2022-08-15 10:09:22.262] [T-1172] [logging.cpp::53] [shards/General/Sub/1.edn] Sub2 output => output: 5 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; Using `Sub`, with `->` ( int 5 ) ;; input to `Sub` shards ( Sub ( -> ( Math.Multiply 2 ) ( Log ))) ;; 5 * 2 => 10 ( Sub ( -> ( Math.Multiply 3 ) ( Log ) ;; 5 * 3 => 15 ( Sub ( -> ( Math.Multiply 2 ) ( Log ))))) ;; 15 * 2 => 30 ( Log \"output of the last `Sub` shard\" ) ;; input is output => 5 ;; Using `|`, no need for `->` ( int 100 ) ;; input to `|` shards ( | ( Math.Multiply 2 ) ( Log )) ;; 100 * 2 => 200 ( | ( Math.Multiply 3 ) ( Log ) ;; 100 * 3 => 300 ( | ( Math.Multiply 2 ) ( Log ))) ;; 300 * 2 => 600 ( Log \"output of the last `|` shard\" ) ;; input is output => 100 [info] [2022-08-15 10:09:22.319] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 10 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 15 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 30 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::53] [shards/General/Sub/2.edn] output of the last `Sub` shard: 5 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 200 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 300 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::55] [shards/General/Sub/2.edn] 600 [info] [2022-08-15 10:09:22.320] [T-676] [logging.cpp::53] [shards/General/Sub/2.edn] output of the last `|` shard: 100","title":"Examples"},{"location":"shards/General/Swap/","text":"Swap \u00b6 ( Swap :NameA [( String ) ( ContextVar [( Any )])] :NameB [( String ) ( ContextVar [( Any )])] ) Definition \u00b6 Swaps the values of the two variables passed to it via :NameA and :NameB parameters. Parameters \u00b6 Name Type Default Description NameA [(String) (ContextVar [(Any)])] \"\" The name of first variable. NameB [(String) (ContextVar [(Any)])] \"\" The name of second variable. Input \u00b6 Type Description [(Any)] Any input is ignored. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Swap swaps the values of the two variables passed to it, one via the :NameA parameter, the other via the :NameB parameter. This shard works on all kinds of variables and across types. So you can not only swap between two integers, two strings, two sequences, two tables etc., but also between a string and a number, a table and a sequence and so on. Any input to this shard is ignored and instead passed through as its output. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"Shards\" >= .string 123 >= .number1 456 >= .number2 789 >= .number3 [ 10 20 ] >= .sequence { \"k1\" 1 \"k2\" 2 } >= .table ( Swap :NameA .number1 :NameB .number2 ) ;; swap two numbers .number1 ( Log \"number1\" ) ;; swapped => number1: 456 .number2 ( Log \"number2\" ) ;; swapped => number2: 123 ( Swap .string .table ) ;; swap a string and a table .string ( Log \"string\" ) ;; swapped => string: {\"k1\" 1 \"k2\" 2} .table ( Log \"table\" ) ;; swapped => table: \"Shards\" ( Swap .number3 .sequence ) ;; swap a number and a sequence .number3 ( Log \"number3\" ) ;; swapped => number3:[10 20] .sequence ( Log \"sequence\" ) ;; swapped => sequence: 789 [info] [2022-08-15 10:09:22.376] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] number1: 456 [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] number2: 123 [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] string: {k2: 2, k1: 1} [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] table: Shards [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] number3: [10, 20] [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] sequence: 789","title":"Swap"},{"location":"shards/General/Swap/#swap","text":"( Swap :NameA [( String ) ( ContextVar [( Any )])] :NameB [( String ) ( ContextVar [( Any )])] )","title":"Swap"},{"location":"shards/General/Swap/#definition","text":"Swaps the values of the two variables passed to it via :NameA and :NameB parameters.","title":"Definition"},{"location":"shards/General/Swap/#parameters","text":"Name Type Default Description NameA [(String) (ContextVar [(Any)])] \"\" The name of first variable. NameB [(String) (ContextVar [(Any)])] \"\" The name of second variable.","title":"Parameters"},{"location":"shards/General/Swap/#input","text":"Type Description [(Any)] Any input is ignored.","title":"Input"},{"location":"shards/General/Swap/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Swap/#details","text":"Swap swaps the values of the two variables passed to it, one via the :NameA parameter, the other via the :NameB parameter. This shard works on all kinds of variables and across types. So you can not only swap between two integers, two strings, two sequences, two tables etc., but also between a string and a number, a table and a sequence and so on. Any input to this shard is ignored and instead passed through as its output.","title":"Details"},{"location":"shards/General/Swap/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"Shards\" >= .string 123 >= .number1 456 >= .number2 789 >= .number3 [ 10 20 ] >= .sequence { \"k1\" 1 \"k2\" 2 } >= .table ( Swap :NameA .number1 :NameB .number2 ) ;; swap two numbers .number1 ( Log \"number1\" ) ;; swapped => number1: 456 .number2 ( Log \"number2\" ) ;; swapped => number2: 123 ( Swap .string .table ) ;; swap a string and a table .string ( Log \"string\" ) ;; swapped => string: {\"k1\" 1 \"k2\" 2} .table ( Log \"table\" ) ;; swapped => table: \"Shards\" ( Swap .number3 .sequence ) ;; swap a number and a sequence .number3 ( Log \"number3\" ) ;; swapped => number3:[10 20] .sequence ( Log \"sequence\" ) ;; swapped => sequence: 789 [info] [2022-08-15 10:09:22.376] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] number1: 456 [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] number2: 123 [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] string: {k2: 2, k1: 1} [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] table: Shards [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] number3: [10, 20] [info] [2022-08-15 10:09:22.377] [T-4596] [logging.cpp::53] [shards/General/Swap/Swap.edn] sequence: 789","title":"Examples"},{"location":"shards/General/Table/","text":"Table \u00b6 ( Table :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Types [( Enum ) ( Seq [( Enum )]) ( Seq [( Enum ) ( Seq [( Enum )]) ( Self )])] ) Definition \u00b6 Creates an empty table. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Types [(Enum) (Seq [(Enum)]) (Seq [(Enum) (Seq [(Enum)]) (Self)])] Enum: 1 vendor: 0x66726167 type: 0x74797065 The table inner types to forward declare. Input \u00b6 Type Description [(Any)] Any input is ignored. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Table creates an empty table with or without a specified key (via the :Key parameter). The created table name is defined in the :Name parameter. Whether the created table variable has a global scope (available to all wires on the mesh) or a local scope (available only to the wire its defined in) can be controlled via the :Global parameter ( true for global scope, false for local scope; default is false ). In addition to the key and the scope, this shard can also define the table's inner data types via the :Types parameter. More than one data type may be set. Any input to this shard is ignored and instead passed through as its output. See also Get Push Sequence Set Update Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; without key, without types, local scope, using `Push` (puts sequence values) ;; (Table :Name .tableA) ;; .tableA (Log) ;; created a table => {A: []} 1 ( Push .tableA \"A\" ) .tableA ( Log ) ;; updated table => {A: [1]} 2 ( Push .tableA \"A\" ) .tableA ( Log ) ;; updated table => {A: [1, 2]} ;; with key, single type, global scope, using `Set` ( Table .tableB :Key \"A\" :Global true :Types Type.Float ) .tableB ( Log ) ;; created a table => {A: {}} 10.2 ( Set .tableB \"A\" ) .tableB ( Log ) ;; updated table => {A: 10.2} 20.1 ( Set .tableB \"A\" ) .tableB ( Log ) ;; updated table => {A: 20.1} ;; with key, multiple types, local scope, using `Set` ( Table .tableC :Key \"A\" :Types [ Type.Float Type.Int ]) .tableC ( Log ) ;; created a table => {A: {}} 10.3 ( Set .tableC \"A\" ) .tableC ( Log ) ;; updated table => {A: 10.3} 20 ( Set .tableC \"B\" ) .tableC ( Log ) ;; updated table => {B: 20, A: 10.3} ;; with key, single type, local scope, using `Push` (puts sequence values) ;; (Table .tableD :Key \"A\" :Types Type.Int) ;; .tableD (Log) ;; created a table => {A: []} 10 ( Push .tableD \"A\" ) .tableD ( Log ) ;; updated table => {A: [10]} 20 ( Push .tableD \"A\" ) .tableD ( Log ) ;; updated table => {A: [10, 20]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [1]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [1, 2]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: {}} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: 10.2} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: 20.1} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: {}} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: 10.3} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {B: 20, A: 10.3} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [10]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [10, 20]}","title":"Table"},{"location":"shards/General/Table/#table","text":"( Table :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] :Types [( Enum ) ( Seq [( Enum )]) ( Seq [( Enum ) ( Seq [( Enum )]) ( Self )])] )","title":"Table"},{"location":"shards/General/Table/#definition","text":"Creates an empty table.","title":"Definition"},{"location":"shards/General/Table/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Types [(Enum) (Seq [(Enum)]) (Seq [(Enum) (Seq [(Enum)]) (Self)])] Enum: 1 vendor: 0x66726167 type: 0x74797065 The table inner types to forward declare.","title":"Parameters"},{"location":"shards/General/Table/#input","text":"Type Description [(Any)] Any input is ignored.","title":"Input"},{"location":"shards/General/Table/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Table/#details","text":"Table creates an empty table with or without a specified key (via the :Key parameter). The created table name is defined in the :Name parameter. Whether the created table variable has a global scope (available to all wires on the mesh) or a local scope (available only to the wire its defined in) can be controlled via the :Global parameter ( true for global scope, false for local scope; default is false ). In addition to the key and the scope, this shard can also define the table's inner data types via the :Types parameter. More than one data type may be set. Any input to this shard is ignored and instead passed through as its output. See also Get Push Sequence Set Update","title":"Details"},{"location":"shards/General/Table/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; without key, without types, local scope, using `Push` (puts sequence values) ;; (Table :Name .tableA) ;; .tableA (Log) ;; created a table => {A: []} 1 ( Push .tableA \"A\" ) .tableA ( Log ) ;; updated table => {A: [1]} 2 ( Push .tableA \"A\" ) .tableA ( Log ) ;; updated table => {A: [1, 2]} ;; with key, single type, global scope, using `Set` ( Table .tableB :Key \"A\" :Global true :Types Type.Float ) .tableB ( Log ) ;; created a table => {A: {}} 10.2 ( Set .tableB \"A\" ) .tableB ( Log ) ;; updated table => {A: 10.2} 20.1 ( Set .tableB \"A\" ) .tableB ( Log ) ;; updated table => {A: 20.1} ;; with key, multiple types, local scope, using `Set` ( Table .tableC :Key \"A\" :Types [ Type.Float Type.Int ]) .tableC ( Log ) ;; created a table => {A: {}} 10.3 ( Set .tableC \"A\" ) .tableC ( Log ) ;; updated table => {A: 10.3} 20 ( Set .tableC \"B\" ) .tableC ( Log ) ;; updated table => {B: 20, A: 10.3} ;; with key, single type, local scope, using `Push` (puts sequence values) ;; (Table .tableD :Key \"A\" :Types Type.Int) ;; .tableD (Log) ;; created a table => {A: []} 10 ( Push .tableD \"A\" ) .tableD ( Log ) ;; updated table => {A: [10]} 20 ( Push .tableD \"A\" ) .tableD ( Log ) ;; updated table => {A: [10, 20]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [1]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [1, 2]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: {}} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: 10.2} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: 20.1} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: {}} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: 10.3} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {B: 20, A: 10.3} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [10]} [info] [2022-08-15 10:09:22.435] [T-6600] [logging.cpp::55] [shards/General/Table/Table.edn] {A: [10, 20]}","title":"Examples"},{"location":"shards/General/Take/","text":"Take \u00b6 ( Take :Indices/Keys [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])]) ( String ) ( Seq [( String )]) ( ContextVar [( String )]) ( ContextVar [( Seq [( String )])])] ) Definition \u00b6 Extracts one or more elements/key-values from a sequence or a table by using the provided sequence index/indices or table key(s). Operation is non-destructive; doesn't modify target sequence/table. Parameters \u00b6 Name Type Default Description Indices/Keys [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])]) (String) (Seq [(String)]) (ContextVar [(String)]) (ContextVar [(Seq [(String)])])] None One or more indices/keys to extract from a sequence/table. Input \u00b6 Type Description [(Int2) (Int3) (Int4) (Int8) (Int16) (Float2) (Float3) (Float4) (Bytes) (Color) (String) (Seq [(Any)]) (Table [(Any)])] The sequence or table from which elements/key-values have to be extracted. Output \u00b6 Type Description [(Any)] The extracted elements/key-values. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ;; Take on sequences [ 10 20 30 40 ] ( Take 1 ) ( Log ) ( Assert.Is 20 :Abort true ) [ 10 20 30 40 ] ( Take [ 1 2 ]) ( Log ) ( Assert.Is [ 20 , 30 ] :Abort true ) ;; Take on tables { \"Hello\" 10 \"World\" 20 } ( Take \"Hello\" ) ( Log ) ( Assert.Is 10 :Abort true ) { \"Hello\" 10 \"World\" 20 } ( Take [ \"World\" \"Hello\" ]) ( Log ) ( Assert.Is [ 20 , 10 ] :Abort true ) { \"Hello\" 10 \"World\" 20 } ( Take \"Universe\" ) ( Log ) ( Assert.Is nil :Abort true ) { :abc 10 :def 20 } ( Take \"def\" ) ( Log ) ( Assert.Is 20 :Abort true ) ;; Take using a variable as index 1 = .index [ 1 2 3 4 ] ( Take .index ) ( Log ) ( Assert.Is 2 :Abort true ) \"Hello\" = .key { \"Hello\" 10 \"World\" 20 } ( Take .key ) ( Log ) ( Assert.Is 10 :Abort true ) [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 20 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] [20, 30] [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 10 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] [20, 10] [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] None [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 20 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 2 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 10","title":"Take"},{"location":"shards/General/Take/#take","text":"( Take :Indices/Keys [( Int ) ( Seq [( Int )]) ( ContextVar [( Int )]) ( ContextVar [( Seq [( Int )])]) ( String ) ( Seq [( String )]) ( ContextVar [( String )]) ( ContextVar [( Seq [( String )])])] )","title":"Take"},{"location":"shards/General/Take/#definition","text":"Extracts one or more elements/key-values from a sequence or a table by using the provided sequence index/indices or table key(s). Operation is non-destructive; doesn't modify target sequence/table.","title":"Definition"},{"location":"shards/General/Take/#parameters","text":"Name Type Default Description Indices/Keys [(Int) (Seq [(Int)]) (ContextVar [(Int)]) (ContextVar [(Seq [(Int)])]) (String) (Seq [(String)]) (ContextVar [(String)]) (ContextVar [(Seq [(String)])])] None One or more indices/keys to extract from a sequence/table.","title":"Parameters"},{"location":"shards/General/Take/#input","text":"Type Description [(Int2) (Int3) (Int4) (Int8) (Int16) (Float2) (Float3) (Float4) (Bytes) (Color) (String) (Seq [(Any)]) (Table [(Any)])] The sequence or table from which elements/key-values have to be extracted.","title":"Input"},{"location":"shards/General/Take/#output","text":"Type Description [(Any)] The extracted elements/key-values.","title":"Output"},{"location":"shards/General/Take/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ;; Take on sequences [ 10 20 30 40 ] ( Take 1 ) ( Log ) ( Assert.Is 20 :Abort true ) [ 10 20 30 40 ] ( Take [ 1 2 ]) ( Log ) ( Assert.Is [ 20 , 30 ] :Abort true ) ;; Take on tables { \"Hello\" 10 \"World\" 20 } ( Take \"Hello\" ) ( Log ) ( Assert.Is 10 :Abort true ) { \"Hello\" 10 \"World\" 20 } ( Take [ \"World\" \"Hello\" ]) ( Log ) ( Assert.Is [ 20 , 10 ] :Abort true ) { \"Hello\" 10 \"World\" 20 } ( Take \"Universe\" ) ( Log ) ( Assert.Is nil :Abort true ) { :abc 10 :def 20 } ( Take \"def\" ) ( Log ) ( Assert.Is 20 :Abort true ) ;; Take using a variable as index 1 = .index [ 1 2 3 4 ] ( Take .index ) ( Log ) ( Assert.Is 2 :Abort true ) \"Hello\" = .key { \"Hello\" 10 \"World\" 20 } ( Take .key ) ( Log ) ( Assert.Is 10 :Abort true ) [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 20 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] [20, 30] [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 10 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] [20, 10] [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] None [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 20 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 2 [info] [2022-08-15 10:09:22.493] [T-6608] [logging.cpp::55] [shards/General/Take/1.edn] 10","title":"Examples"},{"location":"shards/General/ToBase58/","text":"ToBase58 \u00b6 ( ToBase58 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (String)] Output \u00b6 Type Description [(String)]","title":"ToBase58"},{"location":"shards/General/ToBase58/#tobase58","text":"( ToBase58 )","title":"ToBase58"},{"location":"shards/General/ToBase58/#definition","text":"","title":"Definition"},{"location":"shards/General/ToBase58/#input","text":"Type Description [(Bytes) (String)]","title":"Input"},{"location":"shards/General/ToBase58/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/ToBase64/","text":"ToBase64 \u00b6 ( ToBase64 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (String)] Output \u00b6 Type Description [(String)]","title":"ToBase64"},{"location":"shards/General/ToBase64/#tobase64","text":"( ToBase64 )","title":"ToBase64"},{"location":"shards/General/ToBase64/#definition","text":"","title":"Definition"},{"location":"shards/General/ToBase64/#input","text":"Type Description [(Bytes) (String)]","title":"Input"},{"location":"shards/General/ToBase64/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/ToBytes/","text":"ToBytes \u00b6 ( ToBytes ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Bytes)]","title":"ToBytes"},{"location":"shards/General/ToBytes/#tobytes","text":"( ToBytes )","title":"ToBytes"},{"location":"shards/General/ToBytes/#definition","text":"","title":"Definition"},{"location":"shards/General/ToBytes/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToBytes/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/ToColor/","text":"ToColor \u00b6 ( ToColor ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToColor"},{"location":"shards/General/ToColor/#tocolor","text":"( ToColor )","title":"ToColor"},{"location":"shards/General/ToColor/#definition","text":"","title":"Definition"},{"location":"shards/General/ToColor/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToColor/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToFloat/","text":"ToFloat \u00b6 ( ToFloat ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Details \u00b6 This shard typecasts integer and string numeric values into the single float data type ( float ). Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 1 ( ToFloat ) ( Log ) ( Assert.Is 1.0 :Abort true ) 2.2 ( ToFloat ) ( Log ) ( Assert.Is 2.2 :Abort true ) \"3\" ( ToFloat ) ( Log ) ( Assert.Is 3.0 :Abort true ) [info] [2022-08-15 10:09:22.557] [T-3652] [logging.cpp::55] [shards/General/ToFloat/1.edn] 1 [info] [2022-08-15 10:09:22.557] [T-3652] [logging.cpp::55] [shards/General/ToFloat/1.edn] 2.2 [info] [2022-08-15 10:09:22.557] [T-3652] [logging.cpp::55] [shards/General/ToFloat/1.edn] 3","title":"ToFloat"},{"location":"shards/General/ToFloat/#tofloat","text":"( ToFloat )","title":"ToFloat"},{"location":"shards/General/ToFloat/#definition","text":"","title":"Definition"},{"location":"shards/General/ToFloat/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToFloat/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToFloat/#details","text":"This shard typecasts integer and string numeric values into the single float data type ( float ).","title":"Details"},{"location":"shards/General/ToFloat/#examples","text":"Code Output 1 2 3 4 5 6 7 8 1 ( ToFloat ) ( Log ) ( Assert.Is 1.0 :Abort true ) 2.2 ( ToFloat ) ( Log ) ( Assert.Is 2.2 :Abort true ) \"3\" ( ToFloat ) ( Log ) ( Assert.Is 3.0 :Abort true ) [info] [2022-08-15 10:09:22.557] [T-3652] [logging.cpp::55] [shards/General/ToFloat/1.edn] 1 [info] [2022-08-15 10:09:22.557] [T-3652] [logging.cpp::55] [shards/General/ToFloat/1.edn] 2.2 [info] [2022-08-15 10:09:22.557] [T-3652] [logging.cpp::55] [shards/General/ToFloat/1.edn] 3","title":"Examples"},{"location":"shards/General/ToFloat2/","text":"ToFloat2 \u00b6 ( ToFloat2 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToFloat2"},{"location":"shards/General/ToFloat2/#tofloat2","text":"( ToFloat2 )","title":"ToFloat2"},{"location":"shards/General/ToFloat2/#definition","text":"","title":"Definition"},{"location":"shards/General/ToFloat2/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToFloat2/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToFloat3/","text":"ToFloat3 \u00b6 ( ToFloat3 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToFloat3"},{"location":"shards/General/ToFloat3/#tofloat3","text":"( ToFloat3 )","title":"ToFloat3"},{"location":"shards/General/ToFloat3/#definition","text":"","title":"Definition"},{"location":"shards/General/ToFloat3/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToFloat3/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToFloat4/","text":"ToFloat4 \u00b6 ( ToFloat4 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToFloat4"},{"location":"shards/General/ToFloat4/#tofloat4","text":"( ToFloat4 )","title":"ToFloat4"},{"location":"shards/General/ToFloat4/#definition","text":"","title":"Definition"},{"location":"shards/General/ToFloat4/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToFloat4/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToHex/","text":"ToHex \u00b6 ( ToHex ) Definition \u00b6 Input \u00b6 Type Description [(Int) (Bytes) (String)] Output \u00b6 Type Description [(String)]","title":"ToHex"},{"location":"shards/General/ToHex/#tohex","text":"( ToHex )","title":"ToHex"},{"location":"shards/General/ToHex/#definition","text":"","title":"Definition"},{"location":"shards/General/ToHex/#input","text":"Type Description [(Int) (Bytes) (String)]","title":"Input"},{"location":"shards/General/ToHex/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/ToInt/","text":"ToInt \u00b6 ( ToInt ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Details \u00b6 This shard typecasts float and string numeric values into the single integer data type ( int ). Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 1 ( ToInt ) ( Log ) ( Assert.Is 1 :Abort true ) 2.2 ( ToInt ) ( Log ) ( Assert.Is 2 :Abort true ) \"3\" ( ToInt ) ( Log ) ( Assert.Is 3 :Abort true ) [info] [2022-08-15 10:09:22.619] [T-3664] [logging.cpp::55] [shards/General/ToInt/1.edn] 1 [info] [2022-08-15 10:09:22.619] [T-3664] [logging.cpp::55] [shards/General/ToInt/1.edn] 2 [info] [2022-08-15 10:09:22.619] [T-3664] [logging.cpp::55] [shards/General/ToInt/1.edn] 3","title":"ToInt"},{"location":"shards/General/ToInt/#toint","text":"( ToInt )","title":"ToInt"},{"location":"shards/General/ToInt/#definition","text":"","title":"Definition"},{"location":"shards/General/ToInt/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToInt/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToInt/#details","text":"This shard typecasts float and string numeric values into the single integer data type ( int ).","title":"Details"},{"location":"shards/General/ToInt/#examples","text":"Code Output 1 2 3 4 5 6 7 8 1 ( ToInt ) ( Log ) ( Assert.Is 1 :Abort true ) 2.2 ( ToInt ) ( Log ) ( Assert.Is 2 :Abort true ) \"3\" ( ToInt ) ( Log ) ( Assert.Is 3 :Abort true ) [info] [2022-08-15 10:09:22.619] [T-3664] [logging.cpp::55] [shards/General/ToInt/1.edn] 1 [info] [2022-08-15 10:09:22.619] [T-3664] [logging.cpp::55] [shards/General/ToInt/1.edn] 2 [info] [2022-08-15 10:09:22.619] [T-3664] [logging.cpp::55] [shards/General/ToInt/1.edn] 3","title":"Examples"},{"location":"shards/General/ToInt16/","text":"ToInt16 \u00b6 ( ToInt16 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToInt16"},{"location":"shards/General/ToInt16/#toint16","text":"( ToInt16 )","title":"ToInt16"},{"location":"shards/General/ToInt16/#definition","text":"","title":"Definition"},{"location":"shards/General/ToInt16/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToInt16/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToInt2/","text":"ToInt2 \u00b6 ( ToInt2 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToInt2"},{"location":"shards/General/ToInt2/#toint2","text":"( ToInt2 )","title":"ToInt2"},{"location":"shards/General/ToInt2/#definition","text":"","title":"Definition"},{"location":"shards/General/ToInt2/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToInt2/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToInt3/","text":"ToInt3 \u00b6 ( ToInt3 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToInt3"},{"location":"shards/General/ToInt3/#toint3","text":"( ToInt3 )","title":"ToInt3"},{"location":"shards/General/ToInt3/#definition","text":"","title":"Definition"},{"location":"shards/General/ToInt3/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToInt3/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToInt4/","text":"ToInt4 \u00b6 ( ToInt4 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToInt4"},{"location":"shards/General/ToInt4/#toint4","text":"( ToInt4 )","title":"ToInt4"},{"location":"shards/General/ToInt4/#definition","text":"","title":"Definition"},{"location":"shards/General/ToInt4/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToInt4/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToInt8/","text":"ToInt8 \u00b6 ( ToInt8 ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"ToInt8"},{"location":"shards/General/ToInt8/#toint8","text":"( ToInt8 )","title":"ToInt8"},{"location":"shards/General/ToInt8/#definition","text":"","title":"Definition"},{"location":"shards/General/ToInt8/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToInt8/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/ToJson/","text":"ToJson \u00b6 ( ToJson :Pure [( Bool )] :Indent [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Pure [(Bool)] true If the input string is generic pure json rather then shards flavored json. Indent [(Int)] 0 How many spaces to use as json prettify indent. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(String)]","title":"ToJson"},{"location":"shards/General/ToJson/#tojson","text":"( ToJson :Pure [( Bool )] :Indent [( Int )] )","title":"ToJson"},{"location":"shards/General/ToJson/#definition","text":"","title":"Definition"},{"location":"shards/General/ToJson/#parameters","text":"Name Type Default Description Pure [(Bool)] true If the input string is generic pure json rather then shards flavored json. Indent [(Int)] 0 How many spaces to use as json prettify indent.","title":"Parameters"},{"location":"shards/General/ToJson/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToJson/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/ToLEB128/","text":"ToLEB128 \u00b6 ( ToLEB128 :Signed [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Signed [(Bool)] false If the integer to encode/decode is signed and can be negative. Input \u00b6 Type Description [(Int)] Output \u00b6 Type Description [(Bytes)]","title":"ToLEB128"},{"location":"shards/General/ToLEB128/#toleb128","text":"( ToLEB128 :Signed [( Bool )] )","title":"ToLEB128"},{"location":"shards/General/ToLEB128/#definition","text":"","title":"Definition"},{"location":"shards/General/ToLEB128/#parameters","text":"Name Type Default Description Signed [(Bool)] false If the integer to encode/decode is signed and can be negative.","title":"Parameters"},{"location":"shards/General/ToLEB128/#input","text":"Type Description [(Int)]","title":"Input"},{"location":"shards/General/ToLEB128/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/General/ToString/","text":"ToString \u00b6 ( ToString ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(String)]","title":"ToString"},{"location":"shards/General/ToString/#tostring","text":"( ToString )","title":"ToString"},{"location":"shards/General/ToString/#definition","text":"","title":"Definition"},{"location":"shards/General/ToString/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/ToString/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/General/TryMany/","text":"TryMany \u00b6 ( TryMany :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Policy [( Enum )] :Threads [( Int )] :Coroutines [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to spawn and try to run many times concurrently. Policy [(Enum)] Enum: 1 vendor: 0x66726167 type: 0x7472794d The execution policy in terms of wires success. Threads [(Int)] 1 The number of cpu threads to use. Coroutines [(Int)] 1 The number of coroutines to run on each thread. Input \u00b6 Type Description [(Seq [(Any)])] Output \u00b6 Type Description [(Seq [(Any)])] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( Const [ \"A\" \"B\" \"C\" ]) ( TryMany ;:Wire ( Wire \"print\" ( Log ) \"Ok\" ) ;:Policy WaitUntil.AllSuccess ;:Threads 12 ;:Coroutine 1 ) ( Assert.Is [ \"Ok\" \"Ok\" \"Ok\" ] true ) [info] [2022-08-15 10:09:22.679] [T-2120] [logging.cpp::55] [print-2] B [info] [2022-08-15 10:09:22.679] [T-2120] [logging.cpp::55] [print-3] C [info] [2022-08-15 10:09:22.679] [T-2012] [logging.cpp::55] [print-1] A","title":"TryMany"},{"location":"shards/General/TryMany/#trymany","text":"( TryMany :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Policy [( Enum )] :Threads [( Int )] :Coroutines [( Int )] )","title":"TryMany"},{"location":"shards/General/TryMany/#definition","text":"","title":"Definition"},{"location":"shards/General/TryMany/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to spawn and try to run many times concurrently. Policy [(Enum)] Enum: 1 vendor: 0x66726167 type: 0x7472794d The execution policy in terms of wires success. Threads [(Int)] 1 The number of cpu threads to use. Coroutines [(Int)] 1 The number of coroutines to run on each thread.","title":"Parameters"},{"location":"shards/General/TryMany/#input","text":"Type Description [(Seq [(Any)])]","title":"Input"},{"location":"shards/General/TryMany/#output","text":"Type Description [(Seq [(Any)])]","title":"Output"},{"location":"shards/General/TryMany/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( Const [ \"A\" \"B\" \"C\" ]) ( TryMany ;:Wire ( Wire \"print\" ( Log ) \"Ok\" ) ;:Policy WaitUntil.AllSuccess ;:Threads 12 ;:Coroutine 1 ) ( Assert.Is [ \"Ok\" \"Ok\" \"Ok\" ] true ) [info] [2022-08-15 10:09:22.679] [T-2120] [logging.cpp::55] [print-2] B [info] [2022-08-15 10:09:22.679] [T-2120] [logging.cpp::55] [print-3] C [info] [2022-08-15 10:09:22.679] [T-2012] [logging.cpp::55] [print-1] A","title":"Examples"},{"location":"shards/General/Unpack/","text":"Unpack \u00b6 ( Unpack :Definition [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Definition [(String)] \"\" A string defining the struct e.g. \"i32 f32 b i8[256]\". Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Seq [(Any)])]","title":"Unpack"},{"location":"shards/General/Unpack/#unpack","text":"( Unpack :Definition [( String )] )","title":"Unpack"},{"location":"shards/General/Unpack/#definition","text":"","title":"Definition"},{"location":"shards/General/Unpack/#parameters","text":"Name Type Default Description Definition [(String)] \"\" A string defining the struct e.g. \"i32 f32 b i8[256]\".","title":"Parameters"},{"location":"shards/General/Unpack/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/General/Unpack/#output","text":"Type Description [(Seq [(Any)])]","title":"Output"},{"location":"shards/General/UnsafeActivate%21/","text":"UnsafeActivate! \u00b6 ( UnsafeActivate! :Pointer [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Pointer [(Int)] 0 The function address, must be of type SHVar f(Context , SHVar ). Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"UnsafeActivate!"},{"location":"shards/General/UnsafeActivate%21/#unsafeactivate","text":"( UnsafeActivate! :Pointer [( Int )] )","title":"UnsafeActivate!"},{"location":"shards/General/UnsafeActivate%21/#definition","text":"","title":"Definition"},{"location":"shards/General/UnsafeActivate%21/#parameters","text":"Name Type Default Description Pointer [(Int)] 0 The function address, must be of type SHVar f(Context , SHVar ).","title":"Parameters"},{"location":"shards/General/UnsafeActivate%21/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/UnsafeActivate%21/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Update/","text":"Update \u00b6 ( Update :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] ) Definition \u00b6 Modifies the value of an existing mutable variable. Parameters \u00b6 Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh. Input \u00b6 Type Description [(Any)] Input is the new value of the variable being updated. Output \u00b6 Type Description [(Any)] The input to this shard is passed through as its output. Details \u00b6 Update modifies the value of an existing mutable variable. The name of the variable comes from the :Name parameter and the update value comes from the input. Update overwrites string, numeric, and sequence variables with the new value (coming from input). However, for sequences, it cannot update a sequence at the level of elements (i.e., add elements, remove elements, change element order, etc.), so it overwrites the whole sequence with whatever you've passed in the input field. Also, for an existing table, Update can only change the existing keys' values. It cannot add new key-value pairs to the table (do that with Set ). To update existing key-values in a table you need to pass the key in the :Key parameter. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to update. The input to this shard is the update value to be applied to the mutable variables and is also passed through as this shard's output. Note Update has an alias > . Its an alias for Update with the defaults: (Update ...) . See the code examples at the end to understand how this alias is used. See also AppendTo PrependTo Push Sequence Set Table Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ;; update a mutable string variable (by default available only to current wire) \"Hello\" ( Set :Name .svar ) .svar ( Log \".svar\" ) ;; => .svar: Hello \"World\" ( Update .svar ) ;; modify string variable .svar ( Log \"modified .svar\" ) ;; => .svar: World ;; update a mutable numeric variable (available to all wires because `:Global true`) 100 ( Set :Name .nvar :Global true ) .nvar ( Log \".nvar\" ) ;; => .nvar: 100 200 ( Update :Name .nvar :Global true ) ;; modify numeric variable .nvar ( Log \"modified .nvar\" ) ;; => modified .nvar: 200 ;; update a mutable sequence (will overwrite it completely) [ 10 20 30 ] ( Set :Name .sequence ) [ 100 ] ( Update :Name .sequence ) .sequence ( Log \".sequence\" ) ;; => .sequence: [100] ;; update a mutable table: update existing key-value pair [ \"a\" \"b\" ] ( Set :Name \"table1\" :Key \"key1\" ) .table1 ( Log \".table1\" ) ;; => .table1: {key1: [a, b]} [ \"def\" ] ( Update .table1 :Key \"key1\" ) .table1 ( Log \".table1\" ) ;; => .table1: {key1: [def]} ;; Using an `Update` alias ;; `>` is alias for `(Update ...)`: update an existing string variable \"Hello\" ( Set :Name .svarA ) .svarA ( Log \".svarA\" ) ;; => .svar: Hello \"World\" > .svarA ;; modify string variable .svarA ( Log \"modified .svar\" ) ;; => .svar: World ;; create and update local/global table variables [ \"a\" \"b\" ] ( Set :Name \"table\" :Key \"key1\" ) ;; create local table [ \"c\" \"d\" ] ( Set :Name \"table\" :Key \"key1\" :Global true ) ;; create same-name global table ( Get .table ) ( Log ) ;; local table => {key1: [a, b]} ( Get .table :Global true ) ( Log ) ;; same-name global table => {key1: [c, d]} [ \"X\" ] ( Update .table :Key \"key1\" ) ;; update local table [ \"Y\" ] ( Update .table :Key \"key1\" :Global true ) ;; update same-name global table ( Get .table ) ( Log ) ;; updated local table => {key1: [X]} ( Get .table :Global true ) ( Log ) ;; updated same-name global table => {key1: [Y]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .svar: Hello [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] modified .svar: World [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .nvar: 100 [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] modified .nvar: 200 [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .sequence: [100] [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .table1: {key1: [a, b]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .table1: {key1: [def]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .svarA: Hello [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] modified .svar: World [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [a, b]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [c, d]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [X]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [Y]}","title":"Update"},{"location":"shards/General/Update/#update","text":"( Update :Name [( String ) ( ContextVar [( Any )])] :Key [( String ) ( ContextVar [( String )]) ( None )] :Global [( Bool )] )","title":"Update"},{"location":"shards/General/Update/#definition","text":"Modifies the value of an existing mutable variable.","title":"Definition"},{"location":"shards/General/Update/#parameters","text":"Name Type Default Description Name [(String) (ContextVar [(Any)])] \"\" The name of the variable. Key [(String) (ContextVar [(String)]) (None)] None The key of the value to read/write from/in the table (parameter applicable only if the target variable is or will become a table). Global [(Bool)] false If the variable is or should be available to all of the wires in the same mesh.","title":"Parameters"},{"location":"shards/General/Update/#input","text":"Type Description [(Any)] Input is the new value of the variable being updated.","title":"Input"},{"location":"shards/General/Update/#output","text":"Type Description [(Any)] The input to this shard is passed through as its output.","title":"Output"},{"location":"shards/General/Update/#details","text":"Update modifies the value of an existing mutable variable. The name of the variable comes from the :Name parameter and the update value comes from the input. Update overwrites string, numeric, and sequence variables with the new value (coming from input). However, for sequences, it cannot update a sequence at the level of elements (i.e., add elements, remove elements, change element order, etc.), so it overwrites the whole sequence with whatever you've passed in the input field. Also, for an existing table, Update can only change the existing keys' values. It cannot add new key-value pairs to the table (do that with Set ). To update existing key-values in a table you need to pass the key in the :Key parameter. Since variables may be locally scoped (created with (:Global false) ; exists only for current wire) or globally scoped (created with (:Global true) ; exists for all wires of that mesh), both parameters :Global and :Name are used in combination to identify the correct variable to update. The input to this shard is the update value to be applied to the mutable variables and is also passed through as this shard's output. Note Update has an alias > . Its an alias for Update with the defaults: (Update ...) . See the code examples at the end to understand how this alias is used. See also AppendTo PrependTo Push Sequence Set Table","title":"Details"},{"location":"shards/General/Update/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ;; update a mutable string variable (by default available only to current wire) \"Hello\" ( Set :Name .svar ) .svar ( Log \".svar\" ) ;; => .svar: Hello \"World\" ( Update .svar ) ;; modify string variable .svar ( Log \"modified .svar\" ) ;; => .svar: World ;; update a mutable numeric variable (available to all wires because `:Global true`) 100 ( Set :Name .nvar :Global true ) .nvar ( Log \".nvar\" ) ;; => .nvar: 100 200 ( Update :Name .nvar :Global true ) ;; modify numeric variable .nvar ( Log \"modified .nvar\" ) ;; => modified .nvar: 200 ;; update a mutable sequence (will overwrite it completely) [ 10 20 30 ] ( Set :Name .sequence ) [ 100 ] ( Update :Name .sequence ) .sequence ( Log \".sequence\" ) ;; => .sequence: [100] ;; update a mutable table: update existing key-value pair [ \"a\" \"b\" ] ( Set :Name \"table1\" :Key \"key1\" ) .table1 ( Log \".table1\" ) ;; => .table1: {key1: [a, b]} [ \"def\" ] ( Update .table1 :Key \"key1\" ) .table1 ( Log \".table1\" ) ;; => .table1: {key1: [def]} ;; Using an `Update` alias ;; `>` is alias for `(Update ...)`: update an existing string variable \"Hello\" ( Set :Name .svarA ) .svarA ( Log \".svarA\" ) ;; => .svar: Hello \"World\" > .svarA ;; modify string variable .svarA ( Log \"modified .svar\" ) ;; => .svar: World ;; create and update local/global table variables [ \"a\" \"b\" ] ( Set :Name \"table\" :Key \"key1\" ) ;; create local table [ \"c\" \"d\" ] ( Set :Name \"table\" :Key \"key1\" :Global true ) ;; create same-name global table ( Get .table ) ( Log ) ;; local table => {key1: [a, b]} ( Get .table :Global true ) ( Log ) ;; same-name global table => {key1: [c, d]} [ \"X\" ] ( Update .table :Key \"key1\" ) ;; update local table [ \"Y\" ] ( Update .table :Key \"key1\" :Global true ) ;; update same-name global table ( Get .table ) ( Log ) ;; updated local table => {key1: [X]} ( Get .table :Global true ) ( Log ) ;; updated same-name global table => {key1: [Y]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .svar: Hello [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] modified .svar: World [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .nvar: 100 [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] modified .nvar: 200 [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .sequence: [100] [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .table1: {key1: [a, b]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .table1: {key1: [def]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] .svarA: Hello [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::53] [shards/General/Update/Update.edn] modified .svar: World [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [a, b]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [c, d]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [X]} [info] [2022-08-15 10:09:22.738] [T-4412] [logging.cpp::55] [shards/General/Update/Update.edn] {key1: [Y]}","title":"Examples"},{"location":"shards/General/VarAddr/","text":"VarAddr \u00b6 ( VarAddr ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Int)]","title":"VarAddr"},{"location":"shards/General/VarAddr/#varaddr","text":"( VarAddr )","title":"VarAddr"},{"location":"shards/General/VarAddr/#definition","text":"","title":"Definition"},{"location":"shards/General/VarAddr/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/General/VarAddr/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/General/Wait/","text":"Wait \u00b6 ( Wait :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Passthrough [( Bool )] ) Definition \u00b6 Waits for another wire to complete before resuming execution of the current wire. Parameters \u00b6 Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to wait. Passthrough [(Bool)] false The output of this shard will be its input. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)] Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ( defwire myWire ( If ( IsLess 0 ) ( -> \"Negative\" ) ( -> \"Positive\" ))) 5 ( Detach myWire ) ( Wait ;:Wire \"myWire\" ;:Passthrough false ) ( Assert.Is \"Positive\" true )","title":"Wait"},{"location":"shards/General/Wait/#wait","text":"( Wait :Wire [( Wire ) ( String ) ( None ) ( ContextVar [( Wire )])] :Passthrough [( Bool )] )","title":"Wait"},{"location":"shards/General/Wait/#definition","text":"Waits for another wire to complete before resuming execution of the current wire.","title":"Definition"},{"location":"shards/General/Wait/#parameters","text":"Name Type Default Description Wire [(Wire) (String) (None) (ContextVar [(Wire)])] None The wire to wait. Passthrough [(Bool)] false The output of this shard will be its input.","title":"Parameters"},{"location":"shards/General/Wait/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/Wait/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/Wait/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 10 11 12 ( defwire myWire ( If ( IsLess 0 ) ( -> \"Negative\" ) ( -> \"Positive\" ))) 5 ( Detach myWire ) ( Wait ;:Wire \"myWire\" ;:Passthrough false ) ( Assert.Is \"Positive\" true )","title":"Examples"},{"location":"shards/General/When/","text":"When \u00b6 ( When :Predicate [( Shard ) ( Seq [( Shard )]) ( None )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Passthrough [( Bool )] ) Definition \u00b6 Conditonal shard that only executes the action if the predicate is true. Parameters \u00b6 Name Type Default Description Predicate [(Shard) (Seq [(Shard)]) (None)] None The predicate to evaluate in order to trigger Action. Action [(Shard) (Seq [(Shard)]) (None)] None The shards to activate on when Predicate is true for When and false for WhenNot. Passthrough [(Bool)] true The output of this shard will be its input. Input \u00b6 Type Description [(Any)] The value that will be passed to the predicate. Output \u00b6 Type Description [(Any)] The input of the shard if Passthrough is true , or the Predicate is false ; otherwise, the output of the Action . Examples \u00b6 Code Output 1 2 3 4 5 6 64 ( When ;:Predicate ( IsMore 50 ) ;:Action ( Msg \"More than 50\" )) [info] [2022-08-15 10:09:22.852] [T-5400] [logging.cpp::98] [shards/General/When/When.edn] More than 50","title":"When"},{"location":"shards/General/When/#when","text":"( When :Predicate [( Shard ) ( Seq [( Shard )]) ( None )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Passthrough [( Bool )] )","title":"When"},{"location":"shards/General/When/#definition","text":"Conditonal shard that only executes the action if the predicate is true.","title":"Definition"},{"location":"shards/General/When/#parameters","text":"Name Type Default Description Predicate [(Shard) (Seq [(Shard)]) (None)] None The predicate to evaluate in order to trigger Action. Action [(Shard) (Seq [(Shard)]) (None)] None The shards to activate on when Predicate is true for When and false for WhenNot. Passthrough [(Bool)] true The output of this shard will be its input.","title":"Parameters"},{"location":"shards/General/When/#input","text":"Type Description [(Any)] The value that will be passed to the predicate.","title":"Input"},{"location":"shards/General/When/#output","text":"Type Description [(Any)] The input of the shard if Passthrough is true , or the Predicate is false ; otherwise, the output of the Action .","title":"Output"},{"location":"shards/General/When/#examples","text":"Code Output 1 2 3 4 5 6 64 ( When ;:Predicate ( IsMore 50 ) ;:Action ( Msg \"More than 50\" )) [info] [2022-08-15 10:09:22.852] [T-5400] [logging.cpp::98] [shards/General/When/When.edn] More than 50","title":"Examples"},{"location":"shards/General/WhenNot/","text":"WhenNot \u00b6 ( WhenNot :Predicate [( Shard ) ( Seq [( Shard )]) ( None )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Passthrough [( Bool )] ) Definition \u00b6 Conditonal shard that only executes the action if the predicate is false. Parameters \u00b6 Name Type Default Description Predicate [(Shard) (Seq [(Shard)]) (None)] None The predicate to evaluate in order to trigger Action. Action [(Shard) (Seq [(Shard)]) (None)] None The shards to activate on when Predicate is true for When and false for WhenNot. Passthrough [(Bool)] true The output of this shard will be its input. Input \u00b6 Type Description [(Any)] The value that will be passed to the predicate. Output \u00b6 Type Description [(Any)] The input of the shard if Passthrough is true , or the Predicate is true ; otherwise, the output of the Action . Examples \u00b6 Code Output 1 2 3 4 5 6 42 ( WhenNot ;:Predicate ( IsMore 50 ) ;:Action ( Msg \"Less than 50\" )) [info] [2022-08-15 10:09:22.910] [T-5664] [logging.cpp::98] [shards/General/WhenNot/WhenNot.edn] Less than 50","title":"WhenNot"},{"location":"shards/General/WhenNot/#whennot","text":"( WhenNot :Predicate [( Shard ) ( Seq [( Shard )]) ( None )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Passthrough [( Bool )] )","title":"WhenNot"},{"location":"shards/General/WhenNot/#definition","text":"Conditonal shard that only executes the action if the predicate is false.","title":"Definition"},{"location":"shards/General/WhenNot/#parameters","text":"Name Type Default Description Predicate [(Shard) (Seq [(Shard)]) (None)] None The predicate to evaluate in order to trigger Action. Action [(Shard) (Seq [(Shard)]) (None)] None The shards to activate on when Predicate is true for When and false for WhenNot. Passthrough [(Bool)] true The output of this shard will be its input.","title":"Parameters"},{"location":"shards/General/WhenNot/#input","text":"Type Description [(Any)] The value that will be passed to the predicate.","title":"Input"},{"location":"shards/General/WhenNot/#output","text":"Type Description [(Any)] The input of the shard if Passthrough is true , or the Predicate is true ; otherwise, the output of the Action .","title":"Output"},{"location":"shards/General/WhenNot/#examples","text":"Code Output 1 2 3 4 5 6 42 ( WhenNot ;:Predicate ( IsMore 50 ) ;:Action ( Msg \"Less than 50\" )) [info] [2022-08-15 10:09:22.910] [T-5664] [logging.cpp::98] [shards/General/WhenNot/WhenNot.edn] Less than 50","title":"Examples"},{"location":"shards/General/WireLoader/","text":"WireLoader \u00b6 ( WireLoader :Provider [( Object ) ( None )] :Mode [( Enum )] :OnReload [( Shard ) ( Seq [( Shard )]) ( None )] :OnError [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Provider [(Object) (None)] None The shards wire provider. Mode [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x72756e43 The way to run the wire. Inline: will run the sub wire inline within the root wire, a pause in the child wire will pause the root too; Detached: will run the wire separately in the same mesh, a pause in this wire will not pause the root; Stepped: the wire will run as a child, the root will tick the wire every activation of this shard and so a child pause won't pause the root. OnReload [(Shard) (Seq [(Shard)]) (None)] None Shards to execute when the wire is reloaded, the input of this flow will be the reloaded wire. OnError [(Shard) (Seq [(Shard)]) (None)] None Shards to execute when a wire reload failed, the input of this flow will be the error message. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"WireLoader"},{"location":"shards/General/WireLoader/#wireloader","text":"( WireLoader :Provider [( Object ) ( None )] :Mode [( Enum )] :OnReload [( Shard ) ( Seq [( Shard )]) ( None )] :OnError [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"WireLoader"},{"location":"shards/General/WireLoader/#definition","text":"","title":"Definition"},{"location":"shards/General/WireLoader/#parameters","text":"Name Type Default Description Provider [(Object) (None)] None The shards wire provider. Mode [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x72756e43 The way to run the wire. Inline: will run the sub wire inline within the root wire, a pause in the child wire will pause the root too; Detached: will run the wire separately in the same mesh, a pause in this wire will not pause the root; Stepped: the wire will run as a child, the root will tick the wire every activation of this shard and so a child pause won't pause the root. OnReload [(Shard) (Seq [(Shard)]) (None)] None Shards to execute when the wire is reloaded, the input of this flow will be the reloaded wire. OnError [(Shard) (Seq [(Shard)]) (None)] None Shards to execute when a wire reload failed, the input of this flow will be the error message.","title":"Parameters"},{"location":"shards/General/WireLoader/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/WireLoader/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/WireRunner/","text":"WireRunner \u00b6 ( WireRunner :Wire [( ContextVar [( Wire )])] :Mode [( Enum )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Wire [(ContextVar [(Wire)])] None The wire variable to compose and run. Mode [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x72756e43 The way to run the wire. Inline: will run the sub wire inline within the root wire, a pause in the child wire will pause the root too; Detached: will run the wire separately in the same mesh, a pause in this wire will not pause the root; Stepped: the wire will run as a child, the root will tick the wire every activation of this shard and so a child pause won't pause the root. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"WireRunner"},{"location":"shards/General/WireRunner/#wirerunner","text":"( WireRunner :Wire [( ContextVar [( Wire )])] :Mode [( Enum )] )","title":"WireRunner"},{"location":"shards/General/WireRunner/#definition","text":"","title":"Definition"},{"location":"shards/General/WireRunner/#parameters","text":"Name Type Default Description Wire [(ContextVar [(Wire)])] None The wire variable to compose and run. Mode [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x72756e43 The way to run the wire. Inline: will run the sub wire inline within the root wire, a pause in the child wire will pause the root too; Detached: will run the wire separately in the same mesh, a pause in this wire will not pause the root; Stepped: the wire will run as a child, the root will tick the wire every activation of this shard and so a child pause won't pause the root.","title":"Parameters"},{"location":"shards/General/WireRunner/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/WireRunner/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/WriteFile/","text":"WriteFile \u00b6 ( WriteFile :File [( String ) ( ContextVar [( String )]) ( None )] :Append [( Bool )] :Flush [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from. Append [(Bool)] false If we should append to the file if existed already or truncate. (default: false). Flush [(Bool)] false If the file should be flushed to disk after every write. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"WriteFile"},{"location":"shards/General/WriteFile/#writefile","text":"( WriteFile :File [( String ) ( ContextVar [( String )]) ( None )] :Append [( Bool )] :Flush [( Bool )] )","title":"WriteFile"},{"location":"shards/General/WriteFile/#definition","text":"","title":"Definition"},{"location":"shards/General/WriteFile/#parameters","text":"Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from. Append [(Bool)] false If we should append to the file if existed already or truncate. (default: false). Flush [(Bool)] false If the file should be flushed to disk after every write.","title":"Parameters"},{"location":"shards/General/WriteFile/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/General/WriteFile/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/General/WritePNG/","text":"WritePNG \u00b6 ( WritePNG :File [( String ) ( ContextVar [( String )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from. Input \u00b6 Type Description [(Image)] Output \u00b6 Type Description [(Image)]","title":"WritePNG"},{"location":"shards/General/WritePNG/#writepng","text":"( WritePNG :File [( String ) ( ContextVar [( String )]) ( None )] )","title":"WritePNG"},{"location":"shards/General/WritePNG/#definition","text":"","title":"Definition"},{"location":"shards/General/WritePNG/#parameters","text":"Name Type Default Description File [(String) (ContextVar [(String)]) (None)] None The file to read/write from.","title":"Parameters"},{"location":"shards/General/WritePNG/#input","text":"Type Description [(Image)]","title":"Input"},{"location":"shards/General/WritePNG/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/Hash/Blake2-128/","text":"Hash.Blake2-128 \u00b6 ( Hash.Blake2-128 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Blake2-128"},{"location":"shards/Hash/Blake2-128/#hashblake2-128","text":"( Hash.Blake2-128 )","title":"Hash.Blake2-128"},{"location":"shards/Hash/Blake2-128/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Blake2-128/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Blake2-128/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/Blake2-256/","text":"Hash.Blake2-256 \u00b6 ( Hash.Blake2-256 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Blake2-256"},{"location":"shards/Hash/Blake2-256/#hashblake2-256","text":"( Hash.Blake2-256 )","title":"Hash.Blake2-256"},{"location":"shards/Hash/Blake2-256/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Blake2-256/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Blake2-256/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/Keccak-256/","text":"Hash.Keccak-256 \u00b6 ( Hash.Keccak-256 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Keccak-256"},{"location":"shards/Hash/Keccak-256/#hashkeccak-256","text":"( Hash.Keccak-256 )","title":"Hash.Keccak-256"},{"location":"shards/Hash/Keccak-256/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Keccak-256/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Keccak-256/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/Keccak-512/","text":"Hash.Keccak-512 \u00b6 ( Hash.Keccak-512 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Keccak-512"},{"location":"shards/Hash/Keccak-512/#hashkeccak-512","text":"( Hash.Keccak-512 )","title":"Hash.Keccak-512"},{"location":"shards/Hash/Keccak-512/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Keccak-512/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Keccak-512/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/Sha2-256/","text":"Hash.Sha2-256 \u00b6 ( Hash.Sha2-256 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Sha2-256"},{"location":"shards/Hash/Sha2-256/#hashsha2-256","text":"( Hash.Sha2-256 )","title":"Hash.Sha2-256"},{"location":"shards/Hash/Sha2-256/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Sha2-256/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Sha2-256/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/Sha2-512/","text":"Hash.Sha2-512 \u00b6 ( Hash.Sha2-512 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Sha2-512"},{"location":"shards/Hash/Sha2-512/#hashsha2-512","text":"( Hash.Sha2-512 )","title":"Hash.Sha2-512"},{"location":"shards/Hash/Sha2-512/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Sha2-512/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Sha2-512/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/Sha3-256/","text":"Hash.Sha3-256 \u00b6 ( Hash.Sha3-256 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Sha3-256"},{"location":"shards/Hash/Sha3-256/#hashsha3-256","text":"( Hash.Sha3-256 )","title":"Hash.Sha3-256"},{"location":"shards/Hash/Sha3-256/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Sha3-256/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Sha3-256/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/Sha3-512/","text":"Hash.Sha3-512 \u00b6 ( Hash.Sha3-512 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.Sha3-512"},{"location":"shards/Hash/Sha3-512/#hashsha3-512","text":"( Hash.Sha3-512 )","title":"Hash.Sha3-512"},{"location":"shards/Hash/Sha3-512/#definition","text":"","title":"Definition"},{"location":"shards/Hash/Sha3-512/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/Sha3-512/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/XXH-128/","text":"Hash.XXH-128 \u00b6 ( Hash.XXH-128 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.XXH-128"},{"location":"shards/Hash/XXH-128/#hashxxh-128","text":"( Hash.XXH-128 )","title":"Hash.XXH-128"},{"location":"shards/Hash/XXH-128/#definition","text":"","title":"Definition"},{"location":"shards/Hash/XXH-128/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/XXH-128/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Hash/XXH-64/","text":"Hash.XXH-64 \u00b6 ( Hash.XXH-64 ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])] Output \u00b6 Type Description [(Bytes)]","title":"Hash.XXH-64"},{"location":"shards/Hash/XXH-64/#hashxxh-64","text":"( Hash.XXH-64 )","title":"Hash.XXH-64"},{"location":"shards/Hash/XXH-64/#definition","text":"","title":"Definition"},{"location":"shards/Hash/XXH-64/#input","text":"Type Description [(Bytes) (Seq [(Bytes)]) (String) (Seq [(String)])]","title":"Input"},{"location":"shards/Hash/XXH-64/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Http/Delete/","text":"Http.Delete \u00b6 ( Http.Delete :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status. Input \u00b6 Type Description [(None) (Table [(String)]) (Bytes) (String)] Output \u00b6 Type Description [(String)]","title":"Http.Delete"},{"location":"shards/Http/Delete/#httpdelete","text":"( Http.Delete :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] )","title":"Http.Delete"},{"location":"shards/Http/Delete/#definition","text":"","title":"Definition"},{"location":"shards/Http/Delete/#parameters","text":"Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status.","title":"Parameters"},{"location":"shards/Http/Delete/#input","text":"Type Description [(None) (Table [(String)]) (Bytes) (String)]","title":"Input"},{"location":"shards/Http/Delete/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/Get/","text":"Http.Get \u00b6 ( Http.Get :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status. Input \u00b6 Type Description [(None) (Table [(String)])] Output \u00b6 Type Description [(String)]","title":"Http.Get"},{"location":"shards/Http/Get/#httpget","text":"( Http.Get :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] )","title":"Http.Get"},{"location":"shards/Http/Get/#definition","text":"","title":"Definition"},{"location":"shards/Http/Get/#parameters","text":"Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status.","title":"Parameters"},{"location":"shards/Http/Get/#input","text":"Type Description [(None) (Table [(String)])]","title":"Input"},{"location":"shards/Http/Get/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/Head/","text":"Http.Head \u00b6 ( Http.Head :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status. Input \u00b6 Type Description [(None) (Table [(String)])] Output \u00b6 Type Description [(String)]","title":"Http.Head"},{"location":"shards/Http/Head/#httphead","text":"( Http.Head :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] )","title":"Http.Head"},{"location":"shards/Http/Head/#definition","text":"","title":"Definition"},{"location":"shards/Http/Head/#parameters","text":"Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status.","title":"Parameters"},{"location":"shards/Http/Head/#input","text":"Type Description [(None) (Table [(String)])]","title":"Input"},{"location":"shards/Http/Head/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/Patch/","text":"Http.Patch \u00b6 ( Http.Patch :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status. Input \u00b6 Type Description [(None) (Table [(String)]) (Bytes) (String)] Output \u00b6 Type Description [(String)]","title":"Http.Patch"},{"location":"shards/Http/Patch/#httppatch","text":"( Http.Patch :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] )","title":"Http.Patch"},{"location":"shards/Http/Patch/#definition","text":"","title":"Definition"},{"location":"shards/Http/Patch/#parameters","text":"Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status.","title":"Parameters"},{"location":"shards/Http/Patch/#input","text":"Type Description [(None) (Table [(String)]) (Bytes) (String)]","title":"Input"},{"location":"shards/Http/Patch/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/Post/","text":"Http.Post \u00b6 ( Http.Post :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status. Input \u00b6 Type Description [(None) (Table [(String)]) (Bytes) (String)] Output \u00b6 Type Description [(String)]","title":"Http.Post"},{"location":"shards/Http/Post/#httppost","text":"( Http.Post :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] )","title":"Http.Post"},{"location":"shards/Http/Post/#definition","text":"","title":"Definition"},{"location":"shards/Http/Post/#parameters","text":"Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status.","title":"Parameters"},{"location":"shards/Http/Post/#input","text":"Type Description [(None) (Table [(String)]) (Bytes) (String)]","title":"Input"},{"location":"shards/Http/Post/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/Put/","text":"Http.Put \u00b6 ( Http.Put :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status. Input \u00b6 Type Description [(None) (Table [(String)]) (Bytes) (String)] Output \u00b6 Type Description [(String)]","title":"Http.Put"},{"location":"shards/Http/Put/#httpput","text":"( Http.Put :URL [( String ) ( ContextVar [( String )])] :Headers [( None ) ( Table [( String )]) ( ContextVar [( Table [( String )])])] :Timeout [( Int )] :Bytes [( Bool )] :FullResponse [( Bool )] )","title":"Http.Put"},{"location":"shards/Http/Put/#definition","text":"","title":"Definition"},{"location":"shards/Http/Put/#parameters","text":"Name Type Default Description URL [(String) (ContextVar [(String)])] \"\" The url to request to. Headers [(None) (Table [(String)]) (ContextVar [(Table [(String)])])] None The headers to use for the request. Timeout [(Int)] 10 How many seconds to wait for the request to complete. Bytes [(Bool)] false If instead of a string the shard should output bytes. FullResponse [(Bool)] false If the output should be a table with the full response, including headers and status.","title":"Parameters"},{"location":"shards/Http/Put/#input","text":"Type Description [(None) (Table [(String)]) (Bytes) (String)]","title":"Input"},{"location":"shards/Http/Put/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/Read/","text":"Http.Read \u00b6 ( Http.Read ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Table [(String)])]","title":"Http.Read"},{"location":"shards/Http/Read/#httpread","text":"( Http.Read )","title":"Http.Read"},{"location":"shards/Http/Read/#definition","text":"","title":"Definition"},{"location":"shards/Http/Read/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Http/Read/#output","text":"Type Description [(Table [(String)])]","title":"Output"},{"location":"shards/Http/Response/","text":"Http.Response \u00b6 ( Http.Response :Status [( Int )] :Headers [( Table [( String )]) ( ContextVar [( Table [( String )])]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Status [(Int)] 200 The HTTP status code to return. Headers [(Table [(String)]) (ContextVar [(Table [(String)])]) (None)] None The headers to attach to this response. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"Http.Response"},{"location":"shards/Http/Response/#httpresponse","text":"( Http.Response :Status [( Int )] :Headers [( Table [( String )]) ( ContextVar [( Table [( String )])]) ( None )] )","title":"Http.Response"},{"location":"shards/Http/Response/#definition","text":"","title":"Definition"},{"location":"shards/Http/Response/#parameters","text":"Name Type Default Description Status [(Int)] 200 The HTTP status code to return. Headers [(Table [(String)]) (ContextVar [(Table [(String)])]) (None)] None The headers to attach to this response.","title":"Parameters"},{"location":"shards/Http/Response/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Http/Response/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/SendFile/","text":"Http.SendFile \u00b6 ( Http.SendFile :Headers [( Table [( String )]) ( ContextVar [( Table [( String )])]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Headers [(Table [(String)]) (ContextVar [(Table [(String)])]) (None)] None The headers to attach to this response. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"Http.SendFile"},{"location":"shards/Http/SendFile/#httpsendfile","text":"( Http.SendFile :Headers [( Table [( String )]) ( ContextVar [( Table [( String )])]) ( None )] )","title":"Http.SendFile"},{"location":"shards/Http/SendFile/#definition","text":"","title":"Definition"},{"location":"shards/Http/SendFile/#parameters","text":"Name Type Default Description Headers [(Table [(String)]) (ContextVar [(Table [(String)])]) (None)] None The headers to attach to this response.","title":"Parameters"},{"location":"shards/Http/SendFile/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Http/SendFile/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Http/Server/","text":"Http.Server \u00b6 ( Http.Server :Handler [( Wire ) ( None )] :Endpoint [( String )] :Port [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Handler [(Wire) (None)] None The wire that will be spawned and handle a remote request. Endpoint [(String)] \"0.0.0.0\" The URL from where your service can be accessed by a client. Port [(Int)] 7070 The port this service will use. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Http.Server"},{"location":"shards/Http/Server/#httpserver","text":"( Http.Server :Handler [( Wire ) ( None )] :Endpoint [( String )] :Port [( Int )] )","title":"Http.Server"},{"location":"shards/Http/Server/#definition","text":"","title":"Definition"},{"location":"shards/Http/Server/#parameters","text":"Name Type Default Description Handler [(Wire) (None)] None The wire that will be spawned and handle a remote request. Endpoint [(String)] \"0.0.0.0\" The URL from where your service can be accessed by a client. Port [(Int)] 7070 The port this service will use.","title":"Parameters"},{"location":"shards/Http/Server/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Http/Server/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Inputs/KeyDown/","text":"Inputs.KeyDown \u00b6 ( Inputs.KeyDown :Key [( String )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Repeat [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Key [(String)] \"\" TODO! Action [(Shard) (Seq [(Shard)]) (None)] None TODO! Repeat [(Bool)] false TODO! Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Inputs.KeyDown"},{"location":"shards/Inputs/KeyDown/#inputskeydown","text":"( Inputs.KeyDown :Key [( String )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Repeat [( Bool )] )","title":"Inputs.KeyDown"},{"location":"shards/Inputs/KeyDown/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/KeyDown/#parameters","text":"Name Type Default Description Key [(String)] \"\" TODO! Action [(Shard) (Seq [(Shard)]) (None)] None TODO! Repeat [(Bool)] false TODO!","title":"Parameters"},{"location":"shards/Inputs/KeyDown/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Inputs/KeyDown/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Inputs/KeyUp/","text":"Inputs.KeyUp \u00b6 ( Inputs.KeyUp :Key [( String )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Repeat [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Key [(String)] \"\" TODO! Action [(Shard) (Seq [(Shard)]) (None)] None TODO! Repeat [(Bool)] false TODO! Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Inputs.KeyUp"},{"location":"shards/Inputs/KeyUp/#inputskeyup","text":"( Inputs.KeyUp :Key [( String )] :Action [( Shard ) ( Seq [( Shard )]) ( None )] :Repeat [( Bool )] )","title":"Inputs.KeyUp"},{"location":"shards/Inputs/KeyUp/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/KeyUp/#parameters","text":"Name Type Default Description Key [(String)] \"\" TODO! Action [(Shard) (Seq [(Shard)]) (None)] None TODO! Repeat [(Bool)] false TODO!","title":"Parameters"},{"location":"shards/Inputs/KeyUp/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Inputs/KeyUp/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Inputs/Mouse/","text":"Inputs.Mouse \u00b6 ( Inputs.Mouse :Hidden [( Bool )] :Capture [( Bool )] :Relative [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Hidden [(Bool)] false If the cursor should be hidden. Capture [(Bool)] false If the mouse should be confined to the application window. Relative [(Bool)] false If the mouse should only report relative movements. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Inputs.Mouse"},{"location":"shards/Inputs/Mouse/#inputsmouse","text":"( Inputs.Mouse :Hidden [( Bool )] :Capture [( Bool )] :Relative [( Bool )] )","title":"Inputs.Mouse"},{"location":"shards/Inputs/Mouse/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/Mouse/#parameters","text":"Name Type Default Description Hidden [(Bool)] false If the cursor should be hidden. Capture [(Bool)] false If the mouse should be confined to the application window. Relative [(Bool)] false If the mouse should only report relative movements.","title":"Parameters"},{"location":"shards/Inputs/Mouse/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Inputs/Mouse/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Inputs/MouseDelta/","text":"Inputs.MouseDelta \u00b6 ( Inputs.MouseDelta ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float2)]","title":"Inputs.MouseDelta"},{"location":"shards/Inputs/MouseDelta/#inputsmousedelta","text":"( Inputs.MouseDelta )","title":"Inputs.MouseDelta"},{"location":"shards/Inputs/MouseDelta/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/MouseDelta/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Inputs/MouseDelta/#output","text":"Type Description [(Float2)]","title":"Output"},{"location":"shards/Inputs/MouseDown/","text":"Inputs.MouseDown \u00b6 ( Inputs.MouseDown :Left [( Shard ) ( Seq [( Shard )]) ( None )] :Right [( Shard ) ( Seq [( Shard )]) ( None )] :Middle [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Left [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the left mouse button is pressed down. Right [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the right mouse button is pressed down. Middle [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the middle mouse button is pressed down. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Inputs.MouseDown"},{"location":"shards/Inputs/MouseDown/#inputsmousedown","text":"( Inputs.MouseDown :Left [( Shard ) ( Seq [( Shard )]) ( None )] :Right [( Shard ) ( Seq [( Shard )]) ( None )] :Middle [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Inputs.MouseDown"},{"location":"shards/Inputs/MouseDown/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/MouseDown/#parameters","text":"Name Type Default Description Left [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the left mouse button is pressed down. Right [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the right mouse button is pressed down. Middle [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the middle mouse button is pressed down.","title":"Parameters"},{"location":"shards/Inputs/MouseDown/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Inputs/MouseDown/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Inputs/MousePixelPos/","text":"Inputs.MousePixelPos \u00b6 ( Inputs.MousePixelPos ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Int2)]","title":"Inputs.MousePixelPos"},{"location":"shards/Inputs/MousePixelPos/#inputsmousepixelpos","text":"( Inputs.MousePixelPos )","title":"Inputs.MousePixelPos"},{"location":"shards/Inputs/MousePixelPos/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/MousePixelPos/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Inputs/MousePixelPos/#output","text":"Type Description [(Int2)]","title":"Output"},{"location":"shards/Inputs/MousePos/","text":"Inputs.MousePos \u00b6 ( Inputs.MousePos ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float2)]","title":"Inputs.MousePos"},{"location":"shards/Inputs/MousePos/#inputsmousepos","text":"( Inputs.MousePos )","title":"Inputs.MousePos"},{"location":"shards/Inputs/MousePos/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/MousePos/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Inputs/MousePos/#output","text":"Type Description [(Float2)]","title":"Output"},{"location":"shards/Inputs/MouseUp/","text":"Inputs.MouseUp \u00b6 ( Inputs.MouseUp :Left [( Shard ) ( Seq [( Shard )]) ( None )] :Right [( Shard ) ( Seq [( Shard )]) ( None )] :Middle [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Left [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the left mouse button is pressed down. Right [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the right mouse button is pressed down. Middle [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the middle mouse button is pressed down. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Inputs.MouseUp"},{"location":"shards/Inputs/MouseUp/#inputsmouseup","text":"( Inputs.MouseUp :Left [( Shard ) ( Seq [( Shard )]) ( None )] :Right [( Shard ) ( Seq [( Shard )]) ( None )] :Middle [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Inputs.MouseUp"},{"location":"shards/Inputs/MouseUp/#definition","text":"","title":"Definition"},{"location":"shards/Inputs/MouseUp/#parameters","text":"Name Type Default Description Left [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the left mouse button is pressed down. Right [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the right mouse button is pressed down. Middle [(Shard) (Seq [(Shard)]) (None)] None The action to perform when the middle mouse button is pressed down.","title":"Parameters"},{"location":"shards/Inputs/MouseUp/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Inputs/MouseUp/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Math/Abs/","text":"Math.Abs \u00b6 ( Math.Abs ) Definition \u00b6 Calculates Abs() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( Const [ -0.1 -0.2 0.4 ]) ( Math.Abs ) ( Log ) ( Assert.Is [ 0.1 0.2 0.4 ] true ) [info] [2022-08-15 10:09:33.252] [T-5564] [logging.cpp::55] [shards/Math/Abs/Abs.edn] [0.1, 0.2, 0.4]","title":"Math.Abs"},{"location":"shards/Math/Abs/#mathabs","text":"( Math.Abs )","title":"Math.Abs"},{"location":"shards/Math/Abs/#definition","text":"Calculates Abs() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Abs/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Abs/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Abs/#examples","text":"Code Output 1 2 3 4 ( Const [ -0.1 -0.2 0.4 ]) ( Math.Abs ) ( Log ) ( Assert.Is [ 0.1 0.2 0.4 ] true ) [info] [2022-08-15 10:09:33.252] [T-5564] [logging.cpp::55] [shards/Math/Abs/Abs.edn] [0.1, 0.2, 0.4]","title":"Examples"},{"location":"shards/Math/Acos/","text":"Math.Acos \u00b6 ( Math.Acos ) Definition \u00b6 Calculates Acos() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float4 -1.0 0.0 0.5 1.0 ) ( Math.Acos ) ( Log ) ( Math.Subtract ( float4 3.1415927 1.5707963 1.0471976 0.0 )) ( Math.Abs ) ( IsLess ( float4 1 e-05 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.309] [T-5264] [logging.cpp::55] [shards/Math/Acos/Acos.edn] (3.14159, 1.5708, 1.0472, 0)","title":"Math.Acos"},{"location":"shards/Math/Acos/#mathacos","text":"( Math.Acos )","title":"Math.Acos"},{"location":"shards/Math/Acos/#definition","text":"Calculates Acos() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Acos/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Acos/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Acos/#examples","text":"Code Output 1 2 3 4 5 ( float4 -1.0 0.0 0.5 1.0 ) ( Math.Acos ) ( Log ) ( Math.Subtract ( float4 3.1415927 1.5707963 1.0471976 0.0 )) ( Math.Abs ) ( IsLess ( float4 1 e-05 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.309] [T-5264] [logging.cpp::55] [shards/Math/Acos/Acos.edn] (3.14159, 1.5708, 1.0472, 0)","title":"Examples"},{"location":"shards/Math/Acosh/","text":"Math.Acosh \u00b6 ( Math.Acosh ) Definition \u00b6 Calculates Acosh() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 1.0 2.0 2.5 ) ( Math.Acosh ) ( Log ) ( Math.Subtract ( float3 0 1.3169578 1.5667992 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.365] [T-5168] [logging.cpp::55] [shards/Math/Acosh/Acosh.edn] (0, 1.31696, 1.5668)","title":"Math.Acosh"},{"location":"shards/Math/Acosh/#mathacosh","text":"( Math.Acosh )","title":"Math.Acosh"},{"location":"shards/Math/Acosh/#definition","text":"Calculates Acosh() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Acosh/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Acosh/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Acosh/#examples","text":"Code Output 1 2 3 4 5 ( float3 1.0 2.0 2.5 ) ( Math.Acosh ) ( Log ) ( Math.Subtract ( float3 0 1.3169578 1.5667992 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.365] [T-5168] [logging.cpp::55] [shards/Math/Acosh/Acosh.edn] (0, 1.31696, 1.5668)","title":"Examples"},{"location":"shards/Math/Add/","text":"Math.Add \u00b6 ( Math.Add :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Details \u00b6 Addition is a binary operation, i.e. it needs two arguments to give a result. The Math.Add shard takes in the Input and the parameter :Operand to produce the Output . Both Input and :Operand can be an integer, a float, or a sequence of such entities (but both value types should match for a given operation). The Output is generally of the same type as the Input provided to the shard. Binary operations on sequences \u00b6 Taking Math.Add operator as an example. If sequences are passed as arguments, the operator takes pairs of correspondingly placed elements from these sequences and computes the result for each pair. This gives rise to different scenarios. Input and :Operand sequence sizes are equal Since each element in Input sequence has a corresponding element in :Operand sequence, the Output sequence also has the same number of resultant elements and hence the same size as the argument sequences. Entity Sequence Seq. Size Input [a b c] 3 :Operand [1 2 3] 3 Output [(a+1) (b+2) (c+3)] 3 Input sequence size < :Operand sequence size Here a few :Operand elements ( :Operand sequence size - Input sequence size) will have no Input elements to pair off with. These :Operand elements are ignored in the final Output . Hence the Output sequence size here will the same as the Input sequence size. Entity Sequence Seq. Size Input [a b] 2 :Operand [1 2 3] 3 Output [(a+1) (b+2) (_+3)] => [(a+1) (b+2)] 2 Input sequence size > :Operand sequence size Once all the :Operand elements have been paired off and computed with the corresponding Input elements, the remaining Input elements ( Input sequence size - :Operand sequence size) will continue looping over the :Operand sequence till all of the Input sequence elements have been used. As a result the Output sequence will again be the same size as the Input sequence. Entity Sequence Seq. Size Input [a b c d e] 5 :Operand [1 2] 2 Output [(a+1) (b+2) (c+1) (d+2) (e+1)] 5 Note Such sequence operations are useful in transforming and translating 2D/3D grid values (a frequent requirement in graphics rendering). This is done by passing the transform inputs as an Input sequence (to be applied to every row/line for a 2D grid or to every 2D-matrix/plane for a 3D grid) of the 2D matrix and the :Operand sequence as the set of 2D/3D coordinates (represented linearly) that is to be transformed. Examples \u00b6 Code Output 1 2 3 4 5 6 7 ;; Add integers ( int 5 ) ;; :Input ( Log ) ;; prints input => 5 ( Math.Add 2 ) ;; :Operand ( Log ) ;; prints input + operand => 7 ( Assert.Is 7 true ) ;; expect: (5 + 2) => 7 [info] [2022-08-15 10:09:33.424] [T-5992] [logging.cpp::55] [shards/Math/Add/1.edn] 5 [info] [2022-08-15 10:09:33.425] [T-5992] [logging.cpp::55] [shards/Math/Add/1.edn] 7 Code Output 1 2 3 4 5 6 7 ;; Add floats ( float 5.3 ) ;; :Input ( Log ) ;; prints input => 5.3 ( Math.Add 2.1 ) ;; :Operand ( Log ) ;; prints input + operand => 7.4 ( Assert.Is 7.4 true ) ;; expect: (5.3 + 2.1) => 7.4 [info] [2022-08-15 10:09:33.488] [T-6348] [logging.cpp::55] [shards/Math/Add/2.edn] 5.3 [info] [2022-08-15 10:09:33.489] [T-6348] [logging.cpp::55] [shards/Math/Add/2.edn] 7.4 Code Output 1 2 3 4 5 6 7 8 ;; Add equal-sized sequences [ 4 5.1 6.4 ] ;; :Input ( Log ) ;; prints input => [4 5.1 6.4] ( Math.Add [ 3 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ( Log ) ;; prints input + operand => [7 9.1 8.6] ( Assert.Is [ 7 9.1 8.6 ] true ) ;; expect: [(4 + 3) (5.1 + 4.0) (6.4 + 2.2)] => [7 9.1 8.6] [info] [2022-08-15 10:09:33.568] [T-6812] [logging.cpp::55] [shards/Math/Add/3.edn] [4, 5.1, 6.4] [info] [2022-08-15 10:09:33.569] [T-6812] [logging.cpp::55] [shards/Math/Add/3.edn] [7, 9.1, 8.6] Code Output 1 2 3 4 5 6 7 8 9 ;; Add unequal-sized sequences (input size < operand size) [ 4.0 ] ;; :Input ( Log ) ;; prints input => [4.0] ( Math.Add [ 3.0 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; since input size < operand size, remaining operand seq elements ignored ( Log ) ;; prints input + operand => [7.0] ( Assert.Is [ 7.0 ] true ) ;; expect: [(4.0 + 3.0) ... ... ] => [7.0] [info] [2022-08-15 10:09:33.625] [T-5048] [logging.cpp::55] [shards/Math/Add/4.edn] [4] [info] [2022-08-15 10:09:33.626] [T-5048] [logging.cpp::55] [shards/Math/Add/4.edn] [7] Code Output 1 2 3 4 5 6 7 8 9 ;; Add unequal-sized sequences (input size > operand size) [ 4 2 1 5 8 ] ;; :Input ( Log ) ;; prints input => [4 2 1 5 8] ( Math.Add [ 6 4 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; for (input size > operand size): remaining input seq elements continually loop over operand seq elements ( Log ) ;; prints input + operand => [10 6 7 9 14] ( Assert.Is [ 10 6 7 9 14 ] true ) ;; expect: [(4 + 6) (2 + 4) (1 + 6) (5 + 4) (8 + 6)] => [10 6 7 9 14] [info] [2022-08-15 10:09:33.682] [T-5180] [logging.cpp::55] [shards/Math/Add/5.edn] [4, 2, 1, 5, 8] [info] [2022-08-15 10:09:33.683] [T-5180] [logging.cpp::55] [shards/Math/Add/5.edn] [10, 6, 7, 9, 14]","title":"Math.Add"},{"location":"shards/Math/Add/#mathadd","text":"( Math.Add :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Add"},{"location":"shards/Math/Add/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Add/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Add/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Add/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Add/#details","text":"Addition is a binary operation, i.e. it needs two arguments to give a result. The Math.Add shard takes in the Input and the parameter :Operand to produce the Output . Both Input and :Operand can be an integer, a float, or a sequence of such entities (but both value types should match for a given operation). The Output is generally of the same type as the Input provided to the shard.","title":"Details"},{"location":"shards/Math/Add/#binary-operations-on-sequences","text":"Taking Math.Add operator as an example. If sequences are passed as arguments, the operator takes pairs of correspondingly placed elements from these sequences and computes the result for each pair. This gives rise to different scenarios. Input and :Operand sequence sizes are equal Since each element in Input sequence has a corresponding element in :Operand sequence, the Output sequence also has the same number of resultant elements and hence the same size as the argument sequences. Entity Sequence Seq. Size Input [a b c] 3 :Operand [1 2 3] 3 Output [(a+1) (b+2) (c+3)] 3 Input sequence size < :Operand sequence size Here a few :Operand elements ( :Operand sequence size - Input sequence size) will have no Input elements to pair off with. These :Operand elements are ignored in the final Output . Hence the Output sequence size here will the same as the Input sequence size. Entity Sequence Seq. Size Input [a b] 2 :Operand [1 2 3] 3 Output [(a+1) (b+2) (_+3)] => [(a+1) (b+2)] 2 Input sequence size > :Operand sequence size Once all the :Operand elements have been paired off and computed with the corresponding Input elements, the remaining Input elements ( Input sequence size - :Operand sequence size) will continue looping over the :Operand sequence till all of the Input sequence elements have been used. As a result the Output sequence will again be the same size as the Input sequence. Entity Sequence Seq. Size Input [a b c d e] 5 :Operand [1 2] 2 Output [(a+1) (b+2) (c+1) (d+2) (e+1)] 5 Note Such sequence operations are useful in transforming and translating 2D/3D grid values (a frequent requirement in graphics rendering). This is done by passing the transform inputs as an Input sequence (to be applied to every row/line for a 2D grid or to every 2D-matrix/plane for a 3D grid) of the 2D matrix and the :Operand sequence as the set of 2D/3D coordinates (represented linearly) that is to be transformed.","title":"Binary operations on sequences"},{"location":"shards/Math/Add/#examples","text":"Code Output 1 2 3 4 5 6 7 ;; Add integers ( int 5 ) ;; :Input ( Log ) ;; prints input => 5 ( Math.Add 2 ) ;; :Operand ( Log ) ;; prints input + operand => 7 ( Assert.Is 7 true ) ;; expect: (5 + 2) => 7 [info] [2022-08-15 10:09:33.424] [T-5992] [logging.cpp::55] [shards/Math/Add/1.edn] 5 [info] [2022-08-15 10:09:33.425] [T-5992] [logging.cpp::55] [shards/Math/Add/1.edn] 7 Code Output 1 2 3 4 5 6 7 ;; Add floats ( float 5.3 ) ;; :Input ( Log ) ;; prints input => 5.3 ( Math.Add 2.1 ) ;; :Operand ( Log ) ;; prints input + operand => 7.4 ( Assert.Is 7.4 true ) ;; expect: (5.3 + 2.1) => 7.4 [info] [2022-08-15 10:09:33.488] [T-6348] [logging.cpp::55] [shards/Math/Add/2.edn] 5.3 [info] [2022-08-15 10:09:33.489] [T-6348] [logging.cpp::55] [shards/Math/Add/2.edn] 7.4 Code Output 1 2 3 4 5 6 7 8 ;; Add equal-sized sequences [ 4 5.1 6.4 ] ;; :Input ( Log ) ;; prints input => [4 5.1 6.4] ( Math.Add [ 3 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ( Log ) ;; prints input + operand => [7 9.1 8.6] ( Assert.Is [ 7 9.1 8.6 ] true ) ;; expect: [(4 + 3) (5.1 + 4.0) (6.4 + 2.2)] => [7 9.1 8.6] [info] [2022-08-15 10:09:33.568] [T-6812] [logging.cpp::55] [shards/Math/Add/3.edn] [4, 5.1, 6.4] [info] [2022-08-15 10:09:33.569] [T-6812] [logging.cpp::55] [shards/Math/Add/3.edn] [7, 9.1, 8.6] Code Output 1 2 3 4 5 6 7 8 9 ;; Add unequal-sized sequences (input size < operand size) [ 4.0 ] ;; :Input ( Log ) ;; prints input => [4.0] ( Math.Add [ 3.0 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; since input size < operand size, remaining operand seq elements ignored ( Log ) ;; prints input + operand => [7.0] ( Assert.Is [ 7.0 ] true ) ;; expect: [(4.0 + 3.0) ... ... ] => [7.0] [info] [2022-08-15 10:09:33.625] [T-5048] [logging.cpp::55] [shards/Math/Add/4.edn] [4] [info] [2022-08-15 10:09:33.626] [T-5048] [logging.cpp::55] [shards/Math/Add/4.edn] [7] Code Output 1 2 3 4 5 6 7 8 9 ;; Add unequal-sized sequences (input size > operand size) [ 4 2 1 5 8 ] ;; :Input ( Log ) ;; prints input => [4 2 1 5 8] ( Math.Add [ 6 4 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; for (input size > operand size): remaining input seq elements continually loop over operand seq elements ( Log ) ;; prints input + operand => [10 6 7 9 14] ( Assert.Is [ 10 6 7 9 14 ] true ) ;; expect: [(4 + 6) (2 + 4) (1 + 6) (5 + 4) (8 + 6)] => [10 6 7 9 14] [info] [2022-08-15 10:09:33.682] [T-5180] [logging.cpp::55] [shards/Math/Add/5.edn] [4, 2, 1, 5, 8] [info] [2022-08-15 10:09:33.683] [T-5180] [logging.cpp::55] [shards/Math/Add/5.edn] [10, 6, 7, 9, 14]","title":"Examples"},{"location":"shards/Math/And/","text":"Math.And \u00b6 ( Math.And :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 ( int4 0 2 4 8 ) ( Math.And ;:Operand ( int4 3 3 3 3 )) ( Log ) ( Assert.Is ( int4 0 2 0 0 ) true ) [info] [2022-08-15 10:09:33.739] [T-1732] [logging.cpp::55] [shards/Math/And/And.edn] (0, 2, 0, 0)","title":"Math.And"},{"location":"shards/Math/And/#mathand","text":"( Math.And :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.And"},{"location":"shards/Math/And/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/And/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/And/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/And/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/And/#examples","text":"Code Output 1 2 3 4 5 6 ( int4 0 2 4 8 ) ( Math.And ;:Operand ( int4 3 3 3 3 )) ( Log ) ( Assert.Is ( int4 0 2 0 0 ) true ) [info] [2022-08-15 10:09:33.739] [T-1732] [logging.cpp::55] [shards/Math/And/And.edn] (0, 2, 0, 0)","title":"Examples"},{"location":"shards/Math/Asin/","text":"Math.Asin \u00b6 ( Math.Asin ) Definition \u00b6 Calculates Asin() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float4 -1.0 0.0 0.5 1.0 ) ( Math.Asin ) ( Log ) ( Math.Subtract ( float4 -1.5707963 0.0 0.52359878 1.5707963 )) ( Math.Abs ) ( IsLess ( float4 1 e-05 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.797] [T-1096] [logging.cpp::55] [shards/Math/Asin/Asin.edn] (-1.5708, 0, 0.523599, 1.5708)","title":"Math.Asin"},{"location":"shards/Math/Asin/#mathasin","text":"( Math.Asin )","title":"Math.Asin"},{"location":"shards/Math/Asin/#definition","text":"Calculates Asin() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Asin/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Asin/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Asin/#examples","text":"Code Output 1 2 3 4 5 ( float4 -1.0 0.0 0.5 1.0 ) ( Math.Asin ) ( Log ) ( Math.Subtract ( float4 -1.5707963 0.0 0.52359878 1.5707963 )) ( Math.Abs ) ( IsLess ( float4 1 e-05 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.797] [T-1096] [logging.cpp::55] [shards/Math/Asin/Asin.edn] (-1.5708, 0, 0.523599, 1.5708)","title":"Examples"},{"location":"shards/Math/Asinh/","text":"Math.Asinh \u00b6 ( Math.Asinh ) Definition \u00b6 Calculates Asinh() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Asinh ) ( Log ) ( Math.Subtract ( float3 -0.88137359 0.0 0.88137359 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.854] [T-6568] [logging.cpp::55] [shards/Math/Asinh/Asinh.edn] (-0.881374, 0, 0.881374)","title":"Math.Asinh"},{"location":"shards/Math/Asinh/#mathasinh","text":"( Math.Asinh )","title":"Math.Asinh"},{"location":"shards/Math/Asinh/#definition","text":"Calculates Asinh() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Asinh/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Asinh/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Asinh/#examples","text":"Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Asinh ) ( Log ) ( Math.Subtract ( float3 -0.88137359 0.0 0.88137359 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.854] [T-6568] [logging.cpp::55] [shards/Math/Asinh/Asinh.edn] (-0.881374, 0, 0.881374)","title":"Examples"},{"location":"shards/Math/Atan/","text":"Math.Atan \u00b6 ( Math.Atan ) Definition \u00b6 Calculates Atan() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Atan ) ( Log ) ( Math.Subtract ( float3 -0.78539816 0.0 0.78539816 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.910] [T-6036] [logging.cpp::55] [shards/Math/Atan/Atan.edn] (-0.785398, 0, 0.785398)","title":"Math.Atan"},{"location":"shards/Math/Atan/#mathatan","text":"( Math.Atan )","title":"Math.Atan"},{"location":"shards/Math/Atan/#definition","text":"Calculates Atan() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Atan/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Atan/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Atan/#examples","text":"Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Atan ) ( Log ) ( Math.Subtract ( float3 -0.78539816 0.0 0.78539816 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.910] [T-6036] [logging.cpp::55] [shards/Math/Atan/Atan.edn] (-0.785398, 0, 0.785398)","title":"Examples"},{"location":"shards/Math/Atanh/","text":"Math.Atanh \u00b6 ( Math.Atanh ) Definition \u00b6 Calculates Atanh() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -0.5 0.0 0.5 ) ( Math.Atanh ) ( Log ) ( Math.Subtract ( float3 -0.54930614 0.0 0.54930614 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.968] [T-6112] [logging.cpp::55] [shards/Math/Atanh/Atanh.edn] (-0.549306, 0, 0.549306)","title":"Math.Atanh"},{"location":"shards/Math/Atanh/#mathatanh","text":"( Math.Atanh )","title":"Math.Atanh"},{"location":"shards/Math/Atanh/#definition","text":"Calculates Atanh() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Atanh/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Atanh/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Atanh/#examples","text":"Code Output 1 2 3 4 5 ( float3 -0.5 0.0 0.5 ) ( Math.Atanh ) ( Log ) ( Math.Subtract ( float3 -0.54930614 0.0 0.54930614 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:33.968] [T-6112] [logging.cpp::55] [shards/Math/Atanh/Atanh.edn] (-0.549306, 0, 0.549306)","title":"Examples"},{"location":"shards/Math/AxisAngleX/","text":"Math.AxisAngleX \u00b6 ( Math.AxisAngleX ) Definition \u00b6 Input \u00b6 Type Description [(Float)] Output \u00b6 Type Description [(Float4)]","title":"Math.AxisAngleX"},{"location":"shards/Math/AxisAngleX/#mathaxisanglex","text":"( Math.AxisAngleX )","title":"Math.AxisAngleX"},{"location":"shards/Math/AxisAngleX/#definition","text":"","title":"Definition"},{"location":"shards/Math/AxisAngleX/#input","text":"Type Description [(Float)]","title":"Input"},{"location":"shards/Math/AxisAngleX/#output","text":"Type Description [(Float4)]","title":"Output"},{"location":"shards/Math/AxisAngleY/","text":"Math.AxisAngleY \u00b6 ( Math.AxisAngleY ) Definition \u00b6 Input \u00b6 Type Description [(Float)] Output \u00b6 Type Description [(Float4)]","title":"Math.AxisAngleY"},{"location":"shards/Math/AxisAngleY/#mathaxisangley","text":"( Math.AxisAngleY )","title":"Math.AxisAngleY"},{"location":"shards/Math/AxisAngleY/#definition","text":"","title":"Definition"},{"location":"shards/Math/AxisAngleY/#input","text":"Type Description [(Float)]","title":"Input"},{"location":"shards/Math/AxisAngleY/#output","text":"Type Description [(Float4)]","title":"Output"},{"location":"shards/Math/AxisAngleZ/","text":"Math.AxisAngleZ \u00b6 ( Math.AxisAngleZ ) Definition \u00b6 Input \u00b6 Type Description [(Float)] Output \u00b6 Type Description [(Float4)]","title":"Math.AxisAngleZ"},{"location":"shards/Math/AxisAngleZ/#mathaxisanglez","text":"( Math.AxisAngleZ )","title":"Math.AxisAngleZ"},{"location":"shards/Math/AxisAngleZ/#definition","text":"","title":"Definition"},{"location":"shards/Math/AxisAngleZ/#input","text":"Type Description [(Float)]","title":"Input"},{"location":"shards/Math/AxisAngleZ/#output","text":"Type Description [(Float4)]","title":"Output"},{"location":"shards/Math/Cbrt/","text":"Math.Cbrt \u00b6 ( Math.Cbrt ) Definition \u00b6 Calculates Cbrt() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -27.0 1.0 8.0 ) ( Math.Cbrt ) ( Log ) ( Math.Subtract ( float3 -3.0 1.0 2.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.026] [T-6460] [logging.cpp::55] [shards/Math/Cbrt/Cbrt.edn] (-3, 1, 2)","title":"Math.Cbrt"},{"location":"shards/Math/Cbrt/#mathcbrt","text":"( Math.Cbrt )","title":"Math.Cbrt"},{"location":"shards/Math/Cbrt/#definition","text":"Calculates Cbrt() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Cbrt/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Cbrt/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Cbrt/#examples","text":"Code Output 1 2 3 4 5 ( float3 -27.0 1.0 8.0 ) ( Math.Cbrt ) ( Log ) ( Math.Subtract ( float3 -3.0 1.0 2.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.026] [T-6460] [logging.cpp::55] [shards/Math/Cbrt/Cbrt.edn] (-3, 1, 2)","title":"Examples"},{"location":"shards/Math/Ceil/","text":"Math.Ceil \u00b6 ( Math.Ceil ) Definition \u00b6 Calculates Ceil() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Ceil ) ( Log ) ( Assert.Is ( float3 0.0 4.0 8.0 ) true ) [info] [2022-08-15 10:09:34.084] [T-3144] [logging.cpp::55] [shards/Math/Ceil/Ceil.edn] (-0, 4, 8)","title":"Math.Ceil"},{"location":"shards/Math/Ceil/#mathceil","text":"( Math.Ceil )","title":"Math.Ceil"},{"location":"shards/Math/Ceil/#definition","text":"Calculates Ceil() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Ceil/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Ceil/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Ceil/#examples","text":"Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Ceil ) ( Log ) ( Assert.Is ( float3 0.0 4.0 8.0 ) true ) [info] [2022-08-15 10:09:34.084] [T-3144] [logging.cpp::55] [shards/Math/Ceil/Ceil.edn] (-0, 4, 8)","title":"Examples"},{"location":"shards/Math/Cos/","text":"Math.Cos \u00b6 ( Math.Cos ) Definition \u00b6 Calculates Cos() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 0 3.1415927 6.2831853 ) ( Math.Cos ) ( Log ) ( Math.Subtract ( float3 1.0 -1.0 1.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.140] [T-6916] [logging.cpp::55] [shards/Math/Cos/Cos.edn] (1, -1, 1)","title":"Math.Cos"},{"location":"shards/Math/Cos/#mathcos","text":"( Math.Cos )","title":"Math.Cos"},{"location":"shards/Math/Cos/#definition","text":"Calculates Cos() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Cos/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Cos/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Cos/#examples","text":"Code Output 1 2 3 4 5 ( float3 0 3.1415927 6.2831853 ) ( Math.Cos ) ( Log ) ( Math.Subtract ( float3 1.0 -1.0 1.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.140] [T-6916] [logging.cpp::55] [shards/Math/Cos/Cos.edn] (1, -1, 1)","title":"Examples"},{"location":"shards/Math/Cosh/","text":"Math.Cosh \u00b6 ( Math.Cosh ) Definition \u00b6 Calculates Cosh() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Cosh ) ( Log ) ( Math.Subtract ( float3 1.5430806 1.0 1.5430806 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.198] [T-5560] [logging.cpp::55] [shards/Math/Cosh/Cosh.edn] (1.54308, 1, 1.54308)","title":"Math.Cosh"},{"location":"shards/Math/Cosh/#mathcosh","text":"( Math.Cosh )","title":"Math.Cosh"},{"location":"shards/Math/Cosh/#definition","text":"Calculates Cosh() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Cosh/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Cosh/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Cosh/#examples","text":"Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Cosh ) ( Log ) ( Math.Subtract ( float3 1.5430806 1.0 1.5430806 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.198] [T-5560] [logging.cpp::55] [shards/Math/Cosh/Cosh.edn] (1.54308, 1, 1.54308)","title":"Examples"},{"location":"shards/Math/Cross/","text":"Math.Cross \u00b6 ( Math.Cross :Operand [( Float2 ) ( Seq [( Float2 )]) ( Float3 ) ( Seq [( Float3 )]) ( Float4 ) ( Seq [( Float4 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Seq [( Float2 )])]) ( ContextVar [( Float3 )]) ( ContextVar [( Seq [( Float3 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)]) (ContextVar [(Float2)]) (ContextVar [(Seq [(Float2)])]) (ContextVar [(Float3)]) (ContextVar [(Seq [(Float3)])]) (ContextVar [(Float4)]) (ContextVar [(Seq [(Float4)])])] 0 The operand. Input \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Math.Cross"},{"location":"shards/Math/Cross/#mathcross","text":"( Math.Cross :Operand [( Float2 ) ( Seq [( Float2 )]) ( Float3 ) ( Seq [( Float3 )]) ( Float4 ) ( Seq [( Float4 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Seq [( Float2 )])]) ( ContextVar [( Float3 )]) ( ContextVar [( Seq [( Float3 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] )","title":"Math.Cross"},{"location":"shards/Math/Cross/#definition","text":"","title":"Definition"},{"location":"shards/Math/Cross/#parameters","text":"Name Type Default Description Operand [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)]) (ContextVar [(Float2)]) (ContextVar [(Seq [(Float2)])]) (ContextVar [(Float3)]) (ContextVar [(Seq [(Float3)])]) (ContextVar [(Float4)]) (ContextVar [(Seq [(Float4)])])] 0 The operand.","title":"Parameters"},{"location":"shards/Math/Cross/#input","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Cross/#output","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Dec/","text":"Math.Dec \u00b6 ( Math.Dec :Value [( ContextVar [( Int )]) ( ContextVar [( Int2 )]) ( ContextVar [( Int3 )]) ( ContextVar [( Int4 )]) ( ContextVar [( Int8 )]) ( ContextVar [( Int16 )]) ( ContextVar [( Float )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float4 )]) ( ContextVar [( Color )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Value [(ContextVar [(Int)]) (ContextVar [(Int2)]) (ContextVar [(Int3)]) (ContextVar [(Int4)]) (ContextVar [(Int8)]) (ContextVar [(Int16)]) (ContextVar [(Float)]) (ContextVar [(Float2)]) (ContextVar [(Float3)]) (ContextVar [(Float4)]) (ContextVar [(Color)]) (ContextVar [(Seq [(Any)])])] None The value to increase/decrease. Input \u00b6 Type Description [(Any)] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Any)] The result of the operation, usually in the same type as the input value. Details \u00b6 This shard decrements the :Value parameter by 1. The :Value parameter should be a variable that holds a valid numeric value. See also Math.Inc Examples \u00b6 Code Output 1 2 3 4 5 6 7 10.0 >= .mutable ( Math.Dec ;:Value .mutable ) .mutable ( Log ) ( Assert.Is 9.0 true ) [info] [2022-08-15 10:09:34.256] [T-2920] [logging.cpp::55] [shards/Math/Dec/Dec.edn] 9","title":"Math.Dec"},{"location":"shards/Math/Dec/#mathdec","text":"( Math.Dec :Value [( ContextVar [( Int )]) ( ContextVar [( Int2 )]) ( ContextVar [( Int3 )]) ( ContextVar [( Int4 )]) ( ContextVar [( Int8 )]) ( ContextVar [( Int16 )]) ( ContextVar [( Float )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float4 )]) ( ContextVar [( Color )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Dec"},{"location":"shards/Math/Dec/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Dec/#parameters","text":"Name Type Default Description Value [(ContextVar [(Int)]) (ContextVar [(Int2)]) (ContextVar [(Int3)]) (ContextVar [(Int4)]) (ContextVar [(Int8)]) (ContextVar [(Int16)]) (ContextVar [(Float)]) (ContextVar [(Float2)]) (ContextVar [(Float3)]) (ContextVar [(Float4)]) (ContextVar [(Color)]) (ContextVar [(Seq [(Any)])])] None The value to increase/decrease.","title":"Parameters"},{"location":"shards/Math/Dec/#input","text":"Type Description [(Any)] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Dec/#output","text":"Type Description [(Any)] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Dec/#details","text":"This shard decrements the :Value parameter by 1. The :Value parameter should be a variable that holds a valid numeric value. See also Math.Inc","title":"Details"},{"location":"shards/Math/Dec/#examples","text":"Code Output 1 2 3 4 5 6 7 10.0 >= .mutable ( Math.Dec ;:Value .mutable ) .mutable ( Log ) ( Assert.Is 9.0 true ) [info] [2022-08-15 10:09:34.256] [T-2920] [logging.cpp::55] [shards/Math/Dec/Dec.edn] 9","title":"Examples"},{"location":"shards/Math/DegreesToRadians/","text":"Math.DegreesToRadians \u00b6 ( Math.DegreesToRadians ) Definition \u00b6 Input \u00b6 Type Description [(Float)] Output \u00b6 Type Description [(Float)]","title":"Math.DegreesToRadians"},{"location":"shards/Math/DegreesToRadians/#mathdegreestoradians","text":"( Math.DegreesToRadians )","title":"Math.DegreesToRadians"},{"location":"shards/Math/DegreesToRadians/#definition","text":"","title":"Definition"},{"location":"shards/Math/DegreesToRadians/#input","text":"Type Description [(Float)]","title":"Input"},{"location":"shards/Math/DegreesToRadians/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/Math/Divide/","text":"Math.Divide \u00b6 ( Math.Divide :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 ( float 9 ) ( Math.Divide ;:Operand 2.0 ) ( Log ) ( Assert.Is 4.5 true ) [info] [2022-08-15 10:09:34.315] [T-5788] [logging.cpp::55] [shards/Math/Divide/Divide.edn] 4.5","title":"Math.Divide"},{"location":"shards/Math/Divide/#mathdivide","text":"( Math.Divide :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Divide"},{"location":"shards/Math/Divide/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Divide/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Divide/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Divide/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Divide/#examples","text":"Code Output 1 2 3 4 5 6 ( float 9 ) ( Math.Divide ;:Operand 2.0 ) ( Log ) ( Assert.Is 4.5 true ) [info] [2022-08-15 10:09:34.315] [T-5788] [logging.cpp::55] [shards/Math/Divide/Divide.edn] 4.5","title":"Examples"},{"location":"shards/Math/Dot/","text":"Math.Dot \u00b6 ( Math.Dot :Operand [( Float2 ) ( Seq [( Float2 )]) ( Float3 ) ( Seq [( Float3 )]) ( Float4 ) ( Seq [( Float4 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Seq [( Float2 )])]) ( ContextVar [( Float3 )]) ( ContextVar [( Seq [( Float3 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)]) (ContextVar [(Float2)]) (ContextVar [(Seq [(Float2)])]) (ContextVar [(Float3)]) (ContextVar [(Seq [(Float3)])]) (ContextVar [(Float4)]) (ContextVar [(Seq [(Float4)])])] 0 The operand. Input \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float)] The result of the operation, usually in the same type as the input value.","title":"Math.Dot"},{"location":"shards/Math/Dot/#mathdot","text":"( Math.Dot :Operand [( Float2 ) ( Seq [( Float2 )]) ( Float3 ) ( Seq [( Float3 )]) ( Float4 ) ( Seq [( Float4 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Seq [( Float2 )])]) ( ContextVar [( Float3 )]) ( ContextVar [( Seq [( Float3 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] )","title":"Math.Dot"},{"location":"shards/Math/Dot/#definition","text":"","title":"Definition"},{"location":"shards/Math/Dot/#parameters","text":"Name Type Default Description Operand [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)]) (ContextVar [(Float2)]) (ContextVar [(Seq [(Float2)])]) (ContextVar [(Float3)]) (ContextVar [(Seq [(Float3)])]) (ContextVar [(Float4)]) (ContextVar [(Seq [(Float4)])])] 0 The operand.","title":"Parameters"},{"location":"shards/Math/Dot/#input","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Dot/#output","text":"Type Description [(Float)] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Erf/","text":"Math.Erf \u00b6 ( Math.Erf ) Definition \u00b6 Calculates Erf() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 0.0 1.0 2.0 ) ( Math.Erf ) ( Log ) ( Math.Subtract ( float3 0.0 0.84270079 0.99532226 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.378] [T-2368] [logging.cpp::55] [shards/Math/Erf/Erf.edn] (0, 0.842701, 0.995322)","title":"Math.Erf"},{"location":"shards/Math/Erf/#matherf","text":"( Math.Erf )","title":"Math.Erf"},{"location":"shards/Math/Erf/#definition","text":"Calculates Erf() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Erf/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Erf/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Erf/#examples","text":"Code Output 1 2 3 4 5 ( float3 0.0 1.0 2.0 ) ( Math.Erf ) ( Log ) ( Math.Subtract ( float3 0.0 0.84270079 0.99532226 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.378] [T-2368] [logging.cpp::55] [shards/Math/Erf/Erf.edn] (0, 0.842701, 0.995322)","title":"Examples"},{"location":"shards/Math/Erfc/","text":"Math.Erfc \u00b6 ( Math.Erfc ) Definition \u00b6 Calculates Erfc() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 0.0 1.0 2.0 ) ( Math.Erfc ) ( Log ) ( Math.Subtract ( float3 1.0 0.15729920 4.677735 e-3 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.437] [T-1348] [logging.cpp::55] [shards/Math/Erfc/Erfc.edn] (1, 0.157299, 0.00467773)","title":"Math.Erfc"},{"location":"shards/Math/Erfc/#matherfc","text":"( Math.Erfc )","title":"Math.Erfc"},{"location":"shards/Math/Erfc/#definition","text":"Calculates Erfc() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Erfc/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Erfc/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Erfc/#examples","text":"Code Output 1 2 3 4 5 ( float3 0.0 1.0 2.0 ) ( Math.Erfc ) ( Log ) ( Math.Subtract ( float3 1.0 0.15729920 4.677735 e-3 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.437] [T-1348] [logging.cpp::55] [shards/Math/Erfc/Erfc.edn] (1, 0.157299, 0.00467773)","title":"Examples"},{"location":"shards/Math/Exp/","text":"Math.Exp \u00b6 ( Math.Exp ) Definition \u00b6 Calculates Exp() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( float 0 ) ( Math.Exp ) ( Log ) ( Assert.Is ( float 1 ) true ) [info] [2022-08-15 10:09:34.496] [T-6780] [logging.cpp::55] [shards/Math/Exp/Exp.edn] 1","title":"Math.Exp"},{"location":"shards/Math/Exp/#mathexp","text":"( Math.Exp )","title":"Math.Exp"},{"location":"shards/Math/Exp/#definition","text":"Calculates Exp() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Exp/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Exp/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Exp/#examples","text":"Code Output 1 2 3 4 ( float 0 ) ( Math.Exp ) ( Log ) ( Assert.Is ( float 1 ) true ) [info] [2022-08-15 10:09:34.496] [T-6780] [logging.cpp::55] [shards/Math/Exp/Exp.edn] 1","title":"Examples"},{"location":"shards/Math/Exp2/","text":"Math.Exp2 \u00b6 ( Math.Exp2 ) Definition \u00b6 Calculates Exp2() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( float 5 ) ( Math.Exp2 ) ( Log ) ( Assert.Is ( float 32 ) true ) [info] [2022-08-15 10:09:34.559] [T-5168] [logging.cpp::55] [shards/Math/Exp2/Exp2.edn] 32","title":"Math.Exp2"},{"location":"shards/Math/Exp2/#mathexp2","text":"( Math.Exp2 )","title":"Math.Exp2"},{"location":"shards/Math/Exp2/#definition","text":"Calculates Exp2() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Exp2/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Exp2/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Exp2/#examples","text":"Code Output 1 2 3 4 ( float 5 ) ( Math.Exp2 ) ( Log ) ( Assert.Is ( float 32 ) true ) [info] [2022-08-15 10:09:34.559] [T-5168] [logging.cpp::55] [shards/Math/Exp2/Exp2.edn] 32","title":"Examples"},{"location":"shards/Math/Expm1/","text":"Math.Expm1 \u00b6 ( Math.Expm1 ) Definition \u00b6 Calculates Expm1() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( float 0 ) ( Math.Expm1 ) ( Log ) ( Assert.Is ( float 0 ) true ) [info] [2022-08-15 10:09:34.621] [T-3536] [logging.cpp::55] [shards/Math/Expm1/Expm1.edn] 0","title":"Math.Expm1"},{"location":"shards/Math/Expm1/#mathexpm1","text":"( Math.Expm1 )","title":"Math.Expm1"},{"location":"shards/Math/Expm1/#definition","text":"Calculates Expm1() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Expm1/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Expm1/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Expm1/#examples","text":"Code Output 1 2 3 4 ( float 0 ) ( Math.Expm1 ) ( Log ) ( Assert.Is ( float 0 ) true ) [info] [2022-08-15 10:09:34.621] [T-3536] [logging.cpp::55] [shards/Math/Expm1/Expm1.edn] 0","title":"Examples"},{"location":"shards/Math/FMod/","text":"Math.FMod \u00b6 ( Math.FMod :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Math.FMod"},{"location":"shards/Math/FMod/#mathfmod","text":"( Math.FMod :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.FMod"},{"location":"shards/Math/FMod/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/FMod/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/FMod/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/FMod/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/FastInvSqrt/","text":"Math.FastInvSqrt \u00b6 ( Math.FastInvSqrt ) Definition \u00b6 Calculates FastInvSqrt() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 4.0 ( Math.FastInvSqrt ) ( Log ) ( Math.Subtract 0.4999978 ) ( Math.Abs ) ( IsLess 1 e-05 ) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.680] [T-6768] [logging.cpp::55] [shards/Math/FastInvSqrt/FastInvSqrt.edn] 0.499998","title":"Math.FastInvSqrt"},{"location":"shards/Math/FastInvSqrt/#mathfastinvsqrt","text":"( Math.FastInvSqrt )","title":"Math.FastInvSqrt"},{"location":"shards/Math/FastInvSqrt/#definition","text":"Calculates FastInvSqrt() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/FastInvSqrt/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/FastInvSqrt/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/FastInvSqrt/#examples","text":"Code Output 1 2 3 4 5 4.0 ( Math.FastInvSqrt ) ( Log ) ( Math.Subtract 0.4999978 ) ( Math.Abs ) ( IsLess 1 e-05 ) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.680] [T-6768] [logging.cpp::55] [shards/Math/FastInvSqrt/FastInvSqrt.edn] 0.499998","title":"Examples"},{"location":"shards/Math/FastSqrt/","text":"Math.FastSqrt \u00b6 ( Math.FastSqrt ) Definition \u00b6 Calculates FastSqrt() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 4.0 ( Math.FastSqrt ) ( Log ) ( Math.Subtract 2.0 ) ( Math.Abs ) ( IsLess 1 e-05 ) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.738] [T-644] [logging.cpp::55] [shards/Math/FastSqrt/FastSqrt.edn] 1.99999","title":"Math.FastSqrt"},{"location":"shards/Math/FastSqrt/#mathfastsqrt","text":"( Math.FastSqrt )","title":"Math.FastSqrt"},{"location":"shards/Math/FastSqrt/#definition","text":"Calculates FastSqrt() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/FastSqrt/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/FastSqrt/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/FastSqrt/#examples","text":"Code Output 1 2 3 4 5 4.0 ( Math.FastSqrt ) ( Log ) ( Math.Subtract 2.0 ) ( Math.Abs ) ( IsLess 1 e-05 ) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.738] [T-644] [logging.cpp::55] [shards/Math/FastSqrt/FastSqrt.edn] 1.99999","title":"Examples"},{"location":"shards/Math/Floor/","text":"Math.Floor \u00b6 ( Math.Floor ) Definition \u00b6 Calculates Floor() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Floor ) ( Log ) ( Assert.Is ( float3 -1.0 4.0 7.0 ) true ) [info] [2022-08-15 10:09:34.794] [T-600] [logging.cpp::55] [shards/Math/Floor/Floor.edn] (-1, 4, 7)","title":"Math.Floor"},{"location":"shards/Math/Floor/#mathfloor","text":"( Math.Floor )","title":"Math.Floor"},{"location":"shards/Math/Floor/#definition","text":"Calculates Floor() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Floor/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Floor/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Floor/#examples","text":"Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Floor ) ( Log ) ( Assert.Is ( float3 -1.0 4.0 7.0 ) true ) [info] [2022-08-15 10:09:34.794] [T-600] [logging.cpp::55] [shards/Math/Floor/Floor.edn] (-1, 4, 7)","title":"Examples"},{"location":"shards/Math/Inc/","text":"Math.Inc \u00b6 ( Math.Inc :Value [( ContextVar [( Int )]) ( ContextVar [( Int2 )]) ( ContextVar [( Int3 )]) ( ContextVar [( Int4 )]) ( ContextVar [( Int8 )]) ( ContextVar [( Int16 )]) ( ContextVar [( Float )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float4 )]) ( ContextVar [( Color )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Value [(ContextVar [(Int)]) (ContextVar [(Int2)]) (ContextVar [(Int3)]) (ContextVar [(Int4)]) (ContextVar [(Int8)]) (ContextVar [(Int16)]) (ContextVar [(Float)]) (ContextVar [(Float2)]) (ContextVar [(Float3)]) (ContextVar [(Float4)]) (ContextVar [(Color)]) (ContextVar [(Seq [(Any)])])] None The value to increase/decrease. Input \u00b6 Type Description [(Any)] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Any)] The result of the operation, usually in the same type as the input value. Details \u00b6 This shard increments the :Value parameter by 1. The :Value parameter should be a variable that holds a valid numeric value. See also Math.Dec Examples \u00b6 Code Output 1 2 3 4 5 6 10.0 >= .mutable ( Math.Inc ;:Value .mutable ) .mutable ( Log ) ( Assert.Is 11.0 true ) [info] [2022-08-15 10:09:34.853] [T-5660] [logging.cpp::55] [shards/Math/Inc/Inc.edn] 11","title":"Math.Inc"},{"location":"shards/Math/Inc/#mathinc","text":"( Math.Inc :Value [( ContextVar [( Int )]) ( ContextVar [( Int2 )]) ( ContextVar [( Int3 )]) ( ContextVar [( Int4 )]) ( ContextVar [( Int8 )]) ( ContextVar [( Int16 )]) ( ContextVar [( Float )]) ( ContextVar [( Float2 )]) ( ContextVar [( Float3 )]) ( ContextVar [( Float4 )]) ( ContextVar [( Color )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Inc"},{"location":"shards/Math/Inc/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Inc/#parameters","text":"Name Type Default Description Value [(ContextVar [(Int)]) (ContextVar [(Int2)]) (ContextVar [(Int3)]) (ContextVar [(Int4)]) (ContextVar [(Int8)]) (ContextVar [(Int16)]) (ContextVar [(Float)]) (ContextVar [(Float2)]) (ContextVar [(Float3)]) (ContextVar [(Float4)]) (ContextVar [(Color)]) (ContextVar [(Seq [(Any)])])] None The value to increase/decrease.","title":"Parameters"},{"location":"shards/Math/Inc/#input","text":"Type Description [(Any)] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Inc/#output","text":"Type Description [(Any)] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Inc/#details","text":"This shard increments the :Value parameter by 1. The :Value parameter should be a variable that holds a valid numeric value. See also Math.Dec","title":"Details"},{"location":"shards/Math/Inc/#examples","text":"Code Output 1 2 3 4 5 6 10.0 >= .mutable ( Math.Inc ;:Value .mutable ) .mutable ( Log ) ( Assert.Is 11.0 true ) [info] [2022-08-15 10:09:34.853] [T-5660] [logging.cpp::55] [shards/Math/Inc/Inc.edn] 11","title":"Examples"},{"location":"shards/Math/LGamma/","text":"Math.LGamma \u00b6 ( Math.LGamma ) Definition \u00b6 Calculates LGamma() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.LGamma ) ( Log ) ( Math.Subtract ( float3 0.0 0.572365 12.801827 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.910] [T-4224] [logging.cpp::55] [shards/Math/LGamma/LGamma.edn] (0, 0.572365, 12.8018)","title":"Math.LGamma"},{"location":"shards/Math/LGamma/#mathlgamma","text":"( Math.LGamma )","title":"Math.LGamma"},{"location":"shards/Math/LGamma/#definition","text":"Calculates LGamma() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/LGamma/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/LGamma/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/LGamma/#examples","text":"Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.LGamma ) ( Log ) ( Math.Subtract ( float3 0.0 0.572365 12.801827 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.910] [T-4224] [logging.cpp::55] [shards/Math/LGamma/LGamma.edn] (0, 0.572365, 12.8018)","title":"Examples"},{"location":"shards/Math/LShift/","text":"Math.LShift \u00b6 ( Math.LShift :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( int 4 ) ( Math.LShift 2 ) ( Log ) ( Assert.Is 16 true ) [info] [2022-08-15 10:09:35.139] [T-5864] [logging.cpp::55] [shards/Math/LShift/LShift.edn] 16","title":"Math.LShift"},{"location":"shards/Math/LShift/#mathlshift","text":"( Math.LShift :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.LShift"},{"location":"shards/Math/LShift/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/LShift/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/LShift/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/LShift/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/LShift/#examples","text":"Code Output 1 2 3 4 ( int 4 ) ( Math.LShift 2 ) ( Log ) ( Assert.Is 16 true ) [info] [2022-08-15 10:09:35.139] [T-5864] [logging.cpp::55] [shards/Math/LShift/LShift.edn] 16","title":"Examples"},{"location":"shards/Math/Length/","text":"Math.Length \u00b6 ( Math.Length ) Definition \u00b6 Input \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float)] The result of the operation, usually in the same type as the input value.","title":"Math.Length"},{"location":"shards/Math/Length/#mathlength","text":"( Math.Length )","title":"Math.Length"},{"location":"shards/Math/Length/#definition","text":"","title":"Definition"},{"location":"shards/Math/Length/#input","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Length/#output","text":"Type Description [(Float)] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/LengthSquared/","text":"Math.LengthSquared \u00b6 ( Math.LengthSquared ) Definition \u00b6 Input \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float)] The result of the operation, usually in the same type as the input value.","title":"Math.LengthSquared"},{"location":"shards/Math/LengthSquared/#mathlengthsquared","text":"( Math.LengthSquared )","title":"Math.LengthSquared"},{"location":"shards/Math/LengthSquared/#definition","text":"","title":"Definition"},{"location":"shards/Math/LengthSquared/#input","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/LengthSquared/#output","text":"Type Description [(Float)] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Log/","text":"Math.Log \u00b6 ( Math.Log ) Definition \u00b6 Calculates Log() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.Log ) ( Log ) ( Math.Subtract ( float3 0.0 -0.69314718 2.3025851 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.967] [T-6432] [logging.cpp::55] [shards/Math/Log/Log.edn] (0, -0.693147, 2.30259)","title":"Math.Log"},{"location":"shards/Math/Log/#mathlog","text":"( Math.Log )","title":"Math.Log"},{"location":"shards/Math/Log/#definition","text":"Calculates Log() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Log/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Log/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Log/#examples","text":"Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.Log ) ( Log ) ( Math.Subtract ( float3 0.0 -0.69314718 2.3025851 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:34.967] [T-6432] [logging.cpp::55] [shards/Math/Log/Log.edn] (0, -0.693147, 2.30259)","title":"Examples"},{"location":"shards/Math/Log10/","text":"Math.Log10 \u00b6 ( Math.Log10 ) Definition \u00b6 Calculates Log10() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.Log10 ) ( Log ) ( Math.Subtract ( float3 0.0 -0.30102999 1.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.024] [T-6568] [logging.cpp::55] [shards/Math/Log10/Log10.edn] (0, -0.30103, 1)","title":"Math.Log10"},{"location":"shards/Math/Log10/#mathlog10","text":"( Math.Log10 )","title":"Math.Log10"},{"location":"shards/Math/Log10/#definition","text":"Calculates Log10() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Log10/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Log10/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Log10/#examples","text":"Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.Log10 ) ( Log ) ( Math.Subtract ( float3 0.0 -0.30102999 1.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.024] [T-6568] [logging.cpp::55] [shards/Math/Log10/Log10.edn] (0, -0.30103, 1)","title":"Examples"},{"location":"shards/Math/Log1p/","text":"Math.Log1p \u00b6 ( Math.Log1p ) Definition \u00b6 Calculates Log1p() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Math.Log1p"},{"location":"shards/Math/Log1p/#mathlog1p","text":"( Math.Log1p )","title":"Math.Log1p"},{"location":"shards/Math/Log1p/#definition","text":"Calculates Log1p() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Log1p/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Log1p/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Log2/","text":"Math.Log2 \u00b6 ( Math.Log2 ) Definition \u00b6 Calculates Log2() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.Log2 ) ( Log ) ( Math.Subtract ( float3 0.0 -1.0 3.3219281 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.083] [T-5720] [logging.cpp::55] [shards/Math/Log2/Log2.edn] (0, -1, 3.32193)","title":"Math.Log2"},{"location":"shards/Math/Log2/#mathlog2","text":"( Math.Log2 )","title":"Math.Log2"},{"location":"shards/Math/Log2/#definition","text":"Calculates Log2() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Log2/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Log2/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Log2/#examples","text":"Code Output 1 2 3 4 5 ( float3 1.0 0.5 10.0 ) ( Math.Log2 ) ( Log ) ( Math.Subtract ( float3 0.0 -1.0 3.3219281 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.083] [T-5720] [logging.cpp::55] [shards/Math/Log2/Log2.edn] (0, -1, 3.32193)","title":"Examples"},{"location":"shards/Math/LookAt/","text":"Math.LookAt \u00b6 ( Math.LookAt ) Definition \u00b6 Input \u00b6 Type Description [(Table {\"Position\" (Float3) \"Target\" (Float3)})] Output \u00b6 Type Description [(Seq [(Float4)])]","title":"Math.LookAt"},{"location":"shards/Math/LookAt/#mathlookat","text":"( Math.LookAt )","title":"Math.LookAt"},{"location":"shards/Math/LookAt/#definition","text":"","title":"Definition"},{"location":"shards/Math/LookAt/#input","text":"Type Description [(Table {\"Position\" (Float3) \"Target\" (Float3)})]","title":"Input"},{"location":"shards/Math/LookAt/#output","text":"Type Description [(Seq [(Float4)])]","title":"Output"},{"location":"shards/Math/MatMul/","text":"Math.MatMul \u00b6 ( Math.MatMul :Operand [( Float2 ) ( Seq [( Float2 )]) ( Float3 ) ( Seq [( Float3 )]) ( Float4 ) ( Seq [( Float4 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Seq [( Float2 )])]) ( ContextVar [( Float3 )]) ( ContextVar [( Seq [( Float3 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Operand [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)]) (ContextVar [(Float2)]) (ContextVar [(Seq [(Float2)])]) (ContextVar [(Float3)]) (ContextVar [(Seq [(Float3)])]) (ContextVar [(Float4)]) (ContextVar [(Seq [(Float4)])])] 0 The operand. Input \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Math.MatMul"},{"location":"shards/Math/MatMul/#mathmatmul","text":"( Math.MatMul :Operand [( Float2 ) ( Seq [( Float2 )]) ( Float3 ) ( Seq [( Float3 )]) ( Float4 ) ( Seq [( Float4 )]) ( ContextVar [( Float2 )]) ( ContextVar [( Seq [( Float2 )])]) ( ContextVar [( Float3 )]) ( ContextVar [( Seq [( Float3 )])]) ( ContextVar [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] )","title":"Math.MatMul"},{"location":"shards/Math/MatMul/#definition","text":"","title":"Definition"},{"location":"shards/Math/MatMul/#parameters","text":"Name Type Default Description Operand [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)]) (ContextVar [(Float2)]) (ContextVar [(Seq [(Float2)])]) (ContextVar [(Float3)]) (ContextVar [(Seq [(Float3)])]) (ContextVar [(Float4)]) (ContextVar [(Seq [(Float4)])])] 0 The operand.","title":"Parameters"},{"location":"shards/Math/MatMul/#input","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/MatMul/#output","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Mean/","text":"Math.Mean \u00b6 ( Math.Mean :Kind [( Enum )] ) Definition \u00b6 Calculates the mean of a sequence of floating point numbers. Parameters \u00b6 Name Type Default Description Kind [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x6d65616e The kind of Pythagorean means. Input \u00b6 Type Description [(Seq [(Float)])] A sequence of floating point numbers. Output \u00b6 Type Description [(Float)] The calculated mean. Examples \u00b6 Code Output 1 2 3 4 5 6 ( Const [ -1.0 0.0 1.0 2.0 5.0 ]) ( Math.Mean ;:Kind Mean.Arithmetic ) ( Log ) ( Assert.Is 1.4 true ) [info] [2022-08-15 10:09:35.196] [T-3992] [logging.cpp::55] [shards/Math/Mean/Mean.edn] 1.4","title":"Math.Mean"},{"location":"shards/Math/Mean/#mathmean","text":"( Math.Mean :Kind [( Enum )] )","title":"Math.Mean"},{"location":"shards/Math/Mean/#definition","text":"Calculates the mean of a sequence of floating point numbers.","title":"Definition"},{"location":"shards/Math/Mean/#parameters","text":"Name Type Default Description Kind [(Enum)] Enum: 0 vendor: 0x66726167 type: 0x6d65616e The kind of Pythagorean means.","title":"Parameters"},{"location":"shards/Math/Mean/#input","text":"Type Description [(Seq [(Float)])] A sequence of floating point numbers.","title":"Input"},{"location":"shards/Math/Mean/#output","text":"Type Description [(Float)] The calculated mean.","title":"Output"},{"location":"shards/Math/Mean/#examples","text":"Code Output 1 2 3 4 5 6 ( Const [ -1.0 0.0 1.0 2.0 5.0 ]) ( Math.Mean ;:Kind Mean.Arithmetic ) ( Log ) ( Assert.Is 1.4 true ) [info] [2022-08-15 10:09:35.196] [T-3992] [logging.cpp::55] [shards/Math/Mean/Mean.edn] 1.4","title":"Examples"},{"location":"shards/Math/Mod/","text":"Math.Mod \u00b6 ( Math.Mod :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 ( int4 1 2 3 4 ) ( Math.Mod ;:Operand ( int4 2 2 2 2 )) ( Log ) ( Assert.Is ( int4 1 0 1 0 ) true ) [info] [2022-08-15 10:09:35.253] [T-7036] [logging.cpp::55] [shards/Math/Mod/Mod.edn] (1, 0, 1, 0)","title":"Math.Mod"},{"location":"shards/Math/Mod/#mathmod","text":"( Math.Mod :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Mod"},{"location":"shards/Math/Mod/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Mod/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Mod/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Mod/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Mod/#examples","text":"Code Output 1 2 3 4 5 6 ( int4 1 2 3 4 ) ( Math.Mod ;:Operand ( int4 2 2 2 2 )) ( Log ) ( Assert.Is ( int4 1 0 1 0 ) true ) [info] [2022-08-15 10:09:35.253] [T-7036] [logging.cpp::55] [shards/Math/Mod/Mod.edn] (1, 0, 1, 0)","title":"Examples"},{"location":"shards/Math/Multiply/","text":"Math.Multiply \u00b6 ( Math.Multiply :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Details \u00b6 Multiplication is a binary operation, i.e., it needs two arguments to give a result. The Math.Multiply shard takes in the Input and the parameter :Operand to produce the Output . Both Input and :Operand can be an integer, a float, or a sequence of such entities (but both value types should match for a given operation). The Output is generally of the same type as the Input provided to the shard. See also Binary operations on sequences Examples \u00b6 Code Output 1 2 3 4 5 6 7 ;; Multiply integers ( int 5 ) ;; :Input ( Log ) ;; prints input => 5 ( Math.Multiply 2 ) ;; :Operand ( Log ) ;; prints input * operand => 10 ( Assert.Is 10 true ) ;; expect: (5 * 2) => 10 [info] [2022-08-15 10:09:35.314] [T-6916] [logging.cpp::55] [shards/Math/Multiply/1.edn] 5 [info] [2022-08-15 10:09:35.314] [T-6916] [logging.cpp::55] [shards/Math/Multiply/1.edn] 10 Code Output 1 2 3 4 5 6 7 ;; Multiply floats ( float 5.3 ) ;; :Input ( Log ) ;; prints input => 5.3 ( Math.Multiply 2.1 ) ;; :Operand ( Log ) ;; prints input * operand => 11.13 ( Assert.Is 11.13 true ) ;; expect: (5.3 * 2.1) => 11.13 [info] [2022-08-15 10:09:35.373] [T-5560] [logging.cpp::55] [shards/Math/Multiply/2.edn] 5.3 [info] [2022-08-15 10:09:35.373] [T-5560] [logging.cpp::55] [shards/Math/Multiply/2.edn] 11.13 Code Output 1 2 3 4 5 6 7 8 ;; Multiply equal-sized sequences [ 4 5.1 6.4 ] ;; :Input ( Log ) ;; prints input => [4 5.1 6.4] ( Math.Multiply [ 3 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ( Log ) ;; prints input * operand => [12 20.4 14.08] ( Assert.Is [ 12 20.4 14.08 ] true ) ;; expect: [(4 * 3) (5.1 * 4.0) (6.4 * 2.2)] => [12 20.4 14.08] [info] [2022-08-15 10:09:35.431] [T-920] [logging.cpp::55] [shards/Math/Multiply/3.edn] [4, 5.1, 6.4] [info] [2022-08-15 10:09:35.432] [T-920] [logging.cpp::55] [shards/Math/Multiply/3.edn] [12, 20.4, 14.08] Code Output 1 2 3 4 5 6 7 8 9 ;; Multiply unequal-sized sequences (input size < operand size) [ 4.0 ] ;; :Input ( Log ) ;; prints input => [4.0] ( Math.Multiply [ 3.0 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; since input size < operand size, remaining operand seq elements ignored ( Log ) ;; prints input * operand => [12.0] ( Assert.Is [ 12.0 ] true ) ;; expect: [(4.0 * 3.0) ... ...] => [12.0] [info] [2022-08-15 10:09:35.489] [T-676] [logging.cpp::55] [shards/Math/Multiply/4.edn] [4] [info] [2022-08-15 10:09:35.490] [T-676] [logging.cpp::55] [shards/Math/Multiply/4.edn] [12] Code Output 1 2 3 4 5 6 7 8 9 ;; Multiply unequal-sized sequences (input size > operand size) [ 4 2 1 5 8 ] ;; :Input ( Log ) ;; prints input => [4 2 1 5 8] ( Math.Multiply [ 6 4 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; for (input size > operand size): remaining input seq elements continually loop over operand seq elements ( Log ) ;; prints input + operand => [24 8 6 20 48] ( Assert.Is [ 24 8 6 20 48 ] true ) ;; expect: [(4 * 6) (2 * 4) (1 * 6) (5 * 4) (8 * 6)] => [24 8 6 20 48] [info] [2022-08-15 10:09:35.548] [T-1052] [logging.cpp::55] [shards/Math/Multiply/5.edn] [4, 2, 1, 5, 8] [info] [2022-08-15 10:09:35.549] [T-1052] [logging.cpp::55] [shards/Math/Multiply/5.edn] [24, 8, 6, 20, 48]","title":"Math.Multiply"},{"location":"shards/Math/Multiply/#mathmultiply","text":"( Math.Multiply :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Multiply"},{"location":"shards/Math/Multiply/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Multiply/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Multiply/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Multiply/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Multiply/#details","text":"Multiplication is a binary operation, i.e., it needs two arguments to give a result. The Math.Multiply shard takes in the Input and the parameter :Operand to produce the Output . Both Input and :Operand can be an integer, a float, or a sequence of such entities (but both value types should match for a given operation). The Output is generally of the same type as the Input provided to the shard. See also Binary operations on sequences","title":"Details"},{"location":"shards/Math/Multiply/#examples","text":"Code Output 1 2 3 4 5 6 7 ;; Multiply integers ( int 5 ) ;; :Input ( Log ) ;; prints input => 5 ( Math.Multiply 2 ) ;; :Operand ( Log ) ;; prints input * operand => 10 ( Assert.Is 10 true ) ;; expect: (5 * 2) => 10 [info] [2022-08-15 10:09:35.314] [T-6916] [logging.cpp::55] [shards/Math/Multiply/1.edn] 5 [info] [2022-08-15 10:09:35.314] [T-6916] [logging.cpp::55] [shards/Math/Multiply/1.edn] 10 Code Output 1 2 3 4 5 6 7 ;; Multiply floats ( float 5.3 ) ;; :Input ( Log ) ;; prints input => 5.3 ( Math.Multiply 2.1 ) ;; :Operand ( Log ) ;; prints input * operand => 11.13 ( Assert.Is 11.13 true ) ;; expect: (5.3 * 2.1) => 11.13 [info] [2022-08-15 10:09:35.373] [T-5560] [logging.cpp::55] [shards/Math/Multiply/2.edn] 5.3 [info] [2022-08-15 10:09:35.373] [T-5560] [logging.cpp::55] [shards/Math/Multiply/2.edn] 11.13 Code Output 1 2 3 4 5 6 7 8 ;; Multiply equal-sized sequences [ 4 5.1 6.4 ] ;; :Input ( Log ) ;; prints input => [4 5.1 6.4] ( Math.Multiply [ 3 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ( Log ) ;; prints input * operand => [12 20.4 14.08] ( Assert.Is [ 12 20.4 14.08 ] true ) ;; expect: [(4 * 3) (5.1 * 4.0) (6.4 * 2.2)] => [12 20.4 14.08] [info] [2022-08-15 10:09:35.431] [T-920] [logging.cpp::55] [shards/Math/Multiply/3.edn] [4, 5.1, 6.4] [info] [2022-08-15 10:09:35.432] [T-920] [logging.cpp::55] [shards/Math/Multiply/3.edn] [12, 20.4, 14.08] Code Output 1 2 3 4 5 6 7 8 9 ;; Multiply unequal-sized sequences (input size < operand size) [ 4.0 ] ;; :Input ( Log ) ;; prints input => [4.0] ( Math.Multiply [ 3.0 4.0 2.2 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; since input size < operand size, remaining operand seq elements ignored ( Log ) ;; prints input * operand => [12.0] ( Assert.Is [ 12.0 ] true ) ;; expect: [(4.0 * 3.0) ... ...] => [12.0] [info] [2022-08-15 10:09:35.489] [T-676] [logging.cpp::55] [shards/Math/Multiply/4.edn] [4] [info] [2022-08-15 10:09:35.490] [T-676] [logging.cpp::55] [shards/Math/Multiply/4.edn] [12] Code Output 1 2 3 4 5 6 7 8 9 ;; Multiply unequal-sized sequences (input size > operand size) [ 4 2 1 5 8 ] ;; :Input ( Log ) ;; prints input => [4 2 1 5 8] ( Math.Multiply [ 6 4 ]) ;; :Operand ;; input seq elements compute with corresponding operand seq elements ;; for (input size > operand size): remaining input seq elements continually loop over operand seq elements ( Log ) ;; prints input + operand => [24 8 6 20 48] ( Assert.Is [ 24 8 6 20 48 ] true ) ;; expect: [(4 * 6) (2 * 4) (1 * 6) (5 * 4) (8 * 6)] => [24 8 6 20 48] [info] [2022-08-15 10:09:35.548] [T-1052] [logging.cpp::55] [shards/Math/Multiply/5.edn] [4, 2, 1, 5, 8] [info] [2022-08-15 10:09:35.549] [T-1052] [logging.cpp::55] [shards/Math/Multiply/5.edn] [24, 8, 6, 20, 48]","title":"Examples"},{"location":"shards/Math/Normalize/","text":"Math.Normalize \u00b6 ( Math.Normalize :Positive [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Positive [(Bool)] false If the output should be in the range 0.0~1.0 instead of -1.0~1.0. Input \u00b6 Type Description [(Seq [(Float)]) (Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Seq [(Float)]) (Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Math.Normalize"},{"location":"shards/Math/Normalize/#mathnormalize","text":"( Math.Normalize :Positive [( Bool )] )","title":"Math.Normalize"},{"location":"shards/Math/Normalize/#definition","text":"","title":"Definition"},{"location":"shards/Math/Normalize/#parameters","text":"Name Type Default Description Positive [(Bool)] false If the output should be in the range 0.0~1.0 instead of -1.0~1.0.","title":"Parameters"},{"location":"shards/Math/Normalize/#input","text":"Type Description [(Seq [(Float)]) (Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Normalize/#output","text":"Type Description [(Seq [(Float)]) (Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Or/","text":"Math.Or \u00b6 ( Math.Or :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 ( int4 0 2 4 8 ) ( Math.Or ;:Operand ( int4 3 3 3 3 )) ( Log ) ( Assert.Is ( int4 3 3 7 11 ) true ) [info] [2022-08-15 10:09:35.607] [T-1348] [logging.cpp::55] [shards/Math/Or/Or.edn] (3, 3, 7, 11)","title":"Math.Or"},{"location":"shards/Math/Or/#mathor","text":"( Math.Or :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Or"},{"location":"shards/Math/Or/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Or/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Or/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Or/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Or/#examples","text":"Code Output 1 2 3 4 5 6 ( int4 0 2 4 8 ) ( Math.Or ;:Operand ( int4 3 3 3 3 )) ( Log ) ( Assert.Is ( int4 3 3 7 11 ) true ) [info] [2022-08-15 10:09:35.607] [T-1348] [logging.cpp::55] [shards/Math/Or/Or.edn] (3, 3, 7, 11)","title":"Examples"},{"location":"shards/Math/Orthographic/","text":"Math.Orthographic \u00b6 ( Math.Orthographic :Width [( Int ) ( Float )] :Height [( Int ) ( Float )] :Near [( Int ) ( Float )] :Far [( Int ) ( Float )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Width [(Int) (Float)] 1280 Width size. Height [(Int) (Float)] 720 Height size. Near [(Int) (Float)] 0 Near plane. Far [(Int) (Float)] 1000 Far plane. Input \u00b6 Type Description [(None)] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Math.Orthographic"},{"location":"shards/Math/Orthographic/#mathorthographic","text":"( Math.Orthographic :Width [( Int ) ( Float )] :Height [( Int ) ( Float )] :Near [( Int ) ( Float )] :Far [( Int ) ( Float )] )","title":"Math.Orthographic"},{"location":"shards/Math/Orthographic/#definition","text":"","title":"Definition"},{"location":"shards/Math/Orthographic/#parameters","text":"Name Type Default Description Width [(Int) (Float)] 1280 Width size. Height [(Int) (Float)] 720 Height size. Near [(Int) (Float)] 0 Near plane. Far [(Int) (Float)] 1000 Far plane.","title":"Parameters"},{"location":"shards/Math/Orthographic/#input","text":"Type Description [(None)] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Orthographic/#output","text":"Type Description [(Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Pow/","text":"Math.Pow \u00b6 ( Math.Pow :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 2.0 ( Math.Pow ;:Operand 3.0 ) ( Log ) ( Assert.Is 8.0 true ) [info] [2022-08-15 10:09:35.664] [T-1464] [logging.cpp::55] [shards/Math/Pow/Pow.edn] 8","title":"Math.Pow"},{"location":"shards/Math/Pow/#mathpow","text":"( Math.Pow :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Pow"},{"location":"shards/Math/Pow/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Pow/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Pow/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Pow/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Pow/#examples","text":"Code Output 1 2 3 4 5 6 2.0 ( Math.Pow ;:Operand 3.0 ) ( Log ) ( Assert.Is 8.0 true ) [info] [2022-08-15 10:09:35.664] [T-1464] [logging.cpp::55] [shards/Math/Pow/Pow.edn] 8","title":"Examples"},{"location":"shards/Math/RShift/","text":"Math.RShift \u00b6 ( Math.RShift :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( int 4 ) ( Math.RShift 2 ) ( Log ) ( Assert.Is 1 true ) [info] [2022-08-15 10:09:35.780] [T-5612] [logging.cpp::55] [shards/Math/RShift/RShift.edn] 1","title":"Math.RShift"},{"location":"shards/Math/RShift/#mathrshift","text":"( Math.RShift :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.RShift"},{"location":"shards/Math/RShift/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/RShift/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/RShift/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/RShift/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/RShift/#examples","text":"Code Output 1 2 3 4 ( int 4 ) ( Math.RShift 2 ) ( Log ) ( Assert.Is 1 true ) [info] [2022-08-15 10:09:35.780] [T-5612] [logging.cpp::55] [shards/Math/RShift/RShift.edn] 1","title":"Examples"},{"location":"shards/Math/RadiansToDegrees/","text":"Math.RadiansToDegrees \u00b6 ( Math.RadiansToDegrees ) Definition \u00b6 Input \u00b6 Type Description [(Float)] Output \u00b6 Type Description [(Float)]","title":"Math.RadiansToDegrees"},{"location":"shards/Math/RadiansToDegrees/#mathradianstodegrees","text":"( Math.RadiansToDegrees )","title":"Math.RadiansToDegrees"},{"location":"shards/Math/RadiansToDegrees/#definition","text":"","title":"Definition"},{"location":"shards/Math/RadiansToDegrees/#input","text":"Type Description [(Float)]","title":"Input"},{"location":"shards/Math/RadiansToDegrees/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/Math/Rotation/","text":"Math.Rotation \u00b6 ( Math.Rotation ) Definition \u00b6 Input \u00b6 Type Description [(Float4)] Output \u00b6 Type Description [(Seq [(Float4)])]","title":"Math.Rotation"},{"location":"shards/Math/Rotation/#mathrotation","text":"( Math.Rotation )","title":"Math.Rotation"},{"location":"shards/Math/Rotation/#definition","text":"","title":"Definition"},{"location":"shards/Math/Rotation/#input","text":"Type Description [(Float4)]","title":"Input"},{"location":"shards/Math/Rotation/#output","text":"Type Description [(Seq [(Float4)])]","title":"Output"},{"location":"shards/Math/Round/","text":"Math.Round \u00b6 ( Math.Round ) Definition \u00b6 Calculates Round() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Round ) ( Log ) ( Assert.Is ( float3 -1.0 4.0 8.0 ) true ) [info] [2022-08-15 10:09:35.722] [T-6624] [logging.cpp::55] [shards/Math/Round/Round.edn] (-1, 4, 8)","title":"Math.Round"},{"location":"shards/Math/Round/#mathround","text":"( Math.Round )","title":"Math.Round"},{"location":"shards/Math/Round/#definition","text":"Calculates Round() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Round/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Round/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Round/#examples","text":"Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Round ) ( Log ) ( Assert.Is ( float3 -1.0 4.0 8.0 ) true ) [info] [2022-08-15 10:09:35.722] [T-6624] [logging.cpp::55] [shards/Math/Round/Round.edn] (-1, 4, 8)","title":"Examples"},{"location":"shards/Math/Scaling/","text":"Math.Scaling \u00b6 ( Math.Scaling ) Definition \u00b6 Input \u00b6 Type Description [(Float3)] Output \u00b6 Type Description [(Seq [(Float4)])]","title":"Math.Scaling"},{"location":"shards/Math/Scaling/#mathscaling","text":"( Math.Scaling )","title":"Math.Scaling"},{"location":"shards/Math/Scaling/#definition","text":"","title":"Definition"},{"location":"shards/Math/Scaling/#input","text":"Type Description [(Float3)]","title":"Input"},{"location":"shards/Math/Scaling/#output","text":"Type Description [(Seq [(Float4)])]","title":"Output"},{"location":"shards/Math/Sin/","text":"Math.Sin \u00b6 ( Math.Sin ) Definition \u00b6 Calculates Sin() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 0.0 1.0 1.5707963 ) ( Math.Sin ) ( Log ) ( Math.Subtract ( float3 0.0 0.84147098 1.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.837] [T-6768] [logging.cpp::55] [shards/Math/Sin/Sin.edn] (0, 0.841471, 1)","title":"Math.Sin"},{"location":"shards/Math/Sin/#mathsin","text":"( Math.Sin )","title":"Math.Sin"},{"location":"shards/Math/Sin/#definition","text":"Calculates Sin() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Sin/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Sin/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Sin/#examples","text":"Code Output 1 2 3 4 5 ( float3 0.0 1.0 1.5707963 ) ( Math.Sin ) ( Log ) ( Math.Subtract ( float3 0.0 0.84147098 1.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.837] [T-6768] [logging.cpp::55] [shards/Math/Sin/Sin.edn] (0, 0.841471, 1)","title":"Examples"},{"location":"shards/Math/Sinh/","text":"Math.Sinh \u00b6 ( Math.Sinh ) Definition \u00b6 Calculates Sinh() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Sinh ) ( Log ) ( Math.Subtract ( float3 -1.1752012 0.0 1.1752012 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.897] [T-644] [logging.cpp::55] [shards/Math/Sinh/Sinh.edn] (-1.1752, 0, 1.1752)","title":"Math.Sinh"},{"location":"shards/Math/Sinh/#mathsinh","text":"( Math.Sinh )","title":"Math.Sinh"},{"location":"shards/Math/Sinh/#definition","text":"Calculates Sinh() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Sinh/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Sinh/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Sinh/#examples","text":"Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Sinh ) ( Log ) ( Math.Subtract ( float3 -1.1752012 0.0 1.1752012 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.897] [T-644] [logging.cpp::55] [shards/Math/Sinh/Sinh.edn] (-1.1752, 0, 1.1752)","title":"Examples"},{"location":"shards/Math/Sqrt/","text":"Math.Sqrt \u00b6 ( Math.Sqrt ) Definition \u00b6 Calculates Sqrt() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 1.0 2.0 4.0 ) ( Math.Sqrt ) ( Log ) ( Math.Subtract ( float3 1.0 1.4142136 2.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.955] [T-5984] [logging.cpp::55] [shards/Math/Sqrt/Sqrt.edn] (1, 1.41421, 2)","title":"Math.Sqrt"},{"location":"shards/Math/Sqrt/#mathsqrt","text":"( Math.Sqrt )","title":"Math.Sqrt"},{"location":"shards/Math/Sqrt/#definition","text":"Calculates Sqrt() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Sqrt/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Sqrt/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Sqrt/#examples","text":"Code Output 1 2 3 4 5 ( float3 1.0 2.0 4.0 ) ( Math.Sqrt ) ( Log ) ( Math.Subtract ( float3 1.0 1.4142136 2.0 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:35.955] [T-5984] [logging.cpp::55] [shards/Math/Sqrt/Sqrt.edn] (1, 1.41421, 2)","title":"Examples"},{"location":"shards/Math/Subtract/","text":"Math.Subtract \u00b6 ( Math.Subtract :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 ( int 7 ) ( Math.Subtract ;:Operand 2 ) ( Log ) ( Assert.Is 5 true ) [info] [2022-08-15 10:09:36.012] [T-5336] [logging.cpp::55] [shards/Math/Subtract/Subtract.edn] 5","title":"Math.Subtract"},{"location":"shards/Math/Subtract/#mathsubtract","text":"( Math.Subtract :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Subtract"},{"location":"shards/Math/Subtract/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Subtract/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Subtract/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] Any valid integer(s), floating point number(s), or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Subtract/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Float) (Float2) (Float3) (Float4) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Subtract/#examples","text":"Code Output 1 2 3 4 5 6 ( int 7 ) ( Math.Subtract ;:Operand 2 ) ( Log ) ( Assert.Is 5 true ) [info] [2022-08-15 10:09:36.012] [T-5336] [logging.cpp::55] [shards/Math/Subtract/Subtract.edn] 5","title":"Examples"},{"location":"shards/Math/TGamma/","text":"Math.TGamma \u00b6 ( Math.TGamma ) Definition \u00b6 Calculates TGamma() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 10.0 ( Math.TGamma ) ( Log ) ( Assert.Is 362880.0 true ) [info] [2022-08-15 10:09:36.187] [T-3076] [logging.cpp::55] [shards/Math/TGamma/TGamma.edn] 362880","title":"Math.TGamma"},{"location":"shards/Math/TGamma/#mathtgamma","text":"( Math.TGamma )","title":"Math.TGamma"},{"location":"shards/Math/TGamma/#definition","text":"Calculates TGamma() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/TGamma/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/TGamma/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/TGamma/#examples","text":"Code Output 1 2 3 4 10.0 ( Math.TGamma ) ( Log ) ( Assert.Is 362880.0 true ) [info] [2022-08-15 10:09:36.187] [T-3076] [logging.cpp::55] [shards/Math/TGamma/TGamma.edn] 362880","title":"Examples"},{"location":"shards/Math/Tan/","text":"Math.Tan \u00b6 ( Math.Tan ) Definition \u00b6 Calculates Tan() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Tan ) ( Log ) ( Math.Subtract ( float3 -1.5574077 0.0 1.5574077 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:36.070] [T-5880] [logging.cpp::55] [shards/Math/Tan/Tan.edn] (-1.55741, 0, 1.55741)","title":"Math.Tan"},{"location":"shards/Math/Tan/#mathtan","text":"( Math.Tan )","title":"Math.Tan"},{"location":"shards/Math/Tan/#definition","text":"Calculates Tan() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Tan/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Tan/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Tan/#examples","text":"Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Tan ) ( Log ) ( Math.Subtract ( float3 -1.5574077 0.0 1.5574077 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:36.070] [T-5880] [logging.cpp::55] [shards/Math/Tan/Tan.edn] (-1.55741, 0, 1.55741)","title":"Examples"},{"location":"shards/Math/Tanh/","text":"Math.Tanh \u00b6 ( Math.Tanh ) Definition \u00b6 Calculates Tanh() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Tanh ) ( Log ) ( Math.Subtract ( float3 -0.76159416 0.0 0.76159416 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:36.129] [T-5192] [logging.cpp::55] [shards/Math/Tanh/Tanh.edn] (-0.761594, 0, 0.761594)","title":"Math.Tanh"},{"location":"shards/Math/Tanh/#mathtanh","text":"( Math.Tanh )","title":"Math.Tanh"},{"location":"shards/Math/Tanh/#definition","text":"Calculates Tanh() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Tanh/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Tanh/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Tanh/#examples","text":"Code Output 1 2 3 4 5 ( float3 -1.0 0.0 1.0 ) ( Math.Tanh ) ( Log ) ( Math.Subtract ( float3 -0.76159416 0.0 0.76159416 )) ( Math.Abs ) ( IsLess ( float3 1 e-05 1 e-05 1 e-05 )) ( Assert.Is true true ) [info] [2022-08-15 10:09:36.129] [T-5192] [logging.cpp::55] [shards/Math/Tanh/Tanh.edn] (-0.761594, 0, 0.761594)","title":"Examples"},{"location":"shards/Math/Translation/","text":"Math.Translation \u00b6 ( Math.Translation ) Definition \u00b6 Input \u00b6 Type Description [(Float3)] Output \u00b6 Type Description [(Seq [(Float4)])]","title":"Math.Translation"},{"location":"shards/Math/Translation/#mathtranslation","text":"( Math.Translation )","title":"Math.Translation"},{"location":"shards/Math/Translation/#definition","text":"","title":"Definition"},{"location":"shards/Math/Translation/#input","text":"Type Description [(Float3)]","title":"Input"},{"location":"shards/Math/Translation/#output","text":"Type Description [(Seq [(Float4)])]","title":"Output"},{"location":"shards/Math/Transpose/","text":"Math.Transpose \u00b6 ( Math.Transpose ) Definition \u00b6 Input \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Math.Transpose"},{"location":"shards/Math/Transpose/#mathtranspose","text":"( Math.Transpose )","title":"Math.Transpose"},{"location":"shards/Math/Transpose/#definition","text":"","title":"Definition"},{"location":"shards/Math/Transpose/#input","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Transpose/#output","text":"Type Description [(Float2) (Seq [(Float2)]) (Float3) (Seq [(Float3)]) (Float4) (Seq [(Float4)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Trunc/","text":"Math.Trunc \u00b6 ( Math.Trunc ) Definition \u00b6 Calculates Trunc() on the input value and returns its result, or a sequence of results if input is a sequence. Input \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Trunc ) ( Log ) ( Assert.Is ( float3 0 4 7 ) true ) [info] [2022-08-15 10:09:36.246] [T-1416] [logging.cpp::55] [shards/Math/Trunc/Trunc.edn] (-0, 4, 7)","title":"Math.Trunc"},{"location":"shards/Math/Trunc/#mathtrunc","text":"( Math.Trunc )","title":"Math.Trunc"},{"location":"shards/Math/Trunc/#definition","text":"Calculates Trunc() on the input value and returns its result, or a sequence of results if input is a sequence.","title":"Definition"},{"location":"shards/Math/Trunc/#input","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] Any valid floating point number(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Trunc/#output","text":"Type Description [(Float) (Float2) (Float3) (Float4) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Trunc/#examples","text":"Code Output 1 2 3 4 ( float3 -0.95 4.0 7.54 ) ( Math.Trunc ) ( Log ) ( Assert.Is ( float3 0 4 7 ) true ) [info] [2022-08-15 10:09:36.246] [T-1416] [logging.cpp::55] [shards/Math/Trunc/Trunc.edn] (-0, 4, 7)","title":"Examples"},{"location":"shards/Math/Xor/","text":"Math.Xor \u00b6 ( Math.Xor :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] ) Definition \u00b6 Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences). Parameters \u00b6 Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation. Input \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation. Output \u00b6 Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value. Examples \u00b6 Code Output 1 2 3 4 5 6 ( int4 0 2 4 8 ) ( Math.Xor ;:Operand ( int4 3 3 3 3 )) ( Log ) ( Assert.Is ( int4 3 1 7 11 ) true ) [info] [2022-08-15 10:09:36.305] [T-6784] [logging.cpp::55] [shards/Math/Xor/Xor.edn] (3, 1, 7, 11)","title":"Math.Xor"},{"location":"shards/Math/Xor/#mathxor","text":"( Math.Xor :Operand [( Int ) ( ContextVar [( Int )]) ( Int2 ) ( ContextVar [( Int2 )]) ( Int3 ) ( ContextVar [( Int3 )]) ( Int4 ) ( ContextVar [( Int4 )]) ( Int8 ) ( ContextVar [( Int8 )]) ( Int16 ) ( ContextVar [( Int16 )]) ( Float ) ( ContextVar [( Float )]) ( Float2 ) ( ContextVar [( Float2 )]) ( Float3 ) ( ContextVar [( Float3 )]) ( Float4 ) ( ContextVar [( Float4 )]) ( Color ) ( ContextVar [( Color )]) ( Seq [( Any )]) ( ContextVar [( Seq [( Any )])])] )","title":"Math.Xor"},{"location":"shards/Math/Xor/#definition","text":"Applies the binary operation on the input value and the operand and returns the result (or a sequence of results if the input and the operand are sequences).","title":"Definition"},{"location":"shards/Math/Xor/#parameters","text":"Name Type Default Description Operand [(Int) (ContextVar [(Int)]) (Int2) (ContextVar [(Int2)]) (Int3) (ContextVar [(Int3)]) (Int4) (ContextVar [(Int4)]) (Int8) (ContextVar [(Int8)]) (Int16) (ContextVar [(Int16)]) (Float) (ContextVar [(Float)]) (Float2) (ContextVar [(Float2)]) (Float3) (ContextVar [(Float3)]) (Float4) (ContextVar [(Float4)]) (Color) (ContextVar [(Color)]) (Seq [(Any)]) (ContextVar [(Seq [(Any)])])] 0 The operand for this operation.","title":"Parameters"},{"location":"shards/Math/Xor/#input","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] Any valid integer(s) or a sequence of such entities supported by this operation.","title":"Input"},{"location":"shards/Math/Xor/#output","text":"Type Description [(Int) (Int2) (Int3) (Int4) (Int8) (Int16) (Color) (Seq [(Any)])] The result of the operation, usually in the same type as the input value.","title":"Output"},{"location":"shards/Math/Xor/#examples","text":"Code Output 1 2 3 4 5 6 ( int4 0 2 4 8 ) ( Math.Xor ;:Operand ( int4 3 3 3 3 )) ( Log ) ( Assert.Is ( int4 3 1 7 11 ) true ) [info] [2022-08-15 10:09:36.305] [T-6784] [logging.cpp::55] [shards/Math/Xor/Xor.edn] (3, 1, 7, 11)","title":"Examples"},{"location":"shards/Network/Client/","text":"Network.Client \u00b6 ( Network.Client :Address [( String ) ( ContextVar [( String )])] :Port [( Int ) ( ContextVar [( Int )])] :Receive [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Address [(String) (ContextVar [(String)])] \"localhost\" The local bind address or the remote address. Port [(Int) (ContextVar [(Int)])] 9191 The port to bind if server or to connect to if client. Receive [(Shard) (Seq [(Shard)]) (None)] None The flow to execute when a packet is received. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Network.Client"},{"location":"shards/Network/Client/#networkclient","text":"( Network.Client :Address [( String ) ( ContextVar [( String )])] :Port [( Int ) ( ContextVar [( Int )])] :Receive [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Network.Client"},{"location":"shards/Network/Client/#definition","text":"","title":"Definition"},{"location":"shards/Network/Client/#parameters","text":"Name Type Default Description Address [(String) (ContextVar [(String)])] \"localhost\" The local bind address or the remote address. Port [(Int) (ContextVar [(Int)])] 9191 The port to bind if server or to connect to if client. Receive [(Shard) (Seq [(Shard)]) (None)] None The flow to execute when a packet is received.","title":"Parameters"},{"location":"shards/Network/Client/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Network/Client/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Network/Send/","text":"Network.Send \u00b6 ( Network.Send ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Network.Send"},{"location":"shards/Network/Send/#networksend","text":"( Network.Send )","title":"Network.Send"},{"location":"shards/Network/Send/#definition","text":"","title":"Definition"},{"location":"shards/Network/Send/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Network/Send/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Network/Server/","text":"Network.Server \u00b6 ( Network.Server :Address [( String ) ( ContextVar [( String )])] :Port [( Int ) ( ContextVar [( Int )])] :Receive [( Shard ) ( Seq [( Shard )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Address [(String) (ContextVar [(String)])] \"localhost\" The local bind address or the remote address. Port [(Int) (ContextVar [(Int)])] 9191 The port to bind if server or to connect to if client. Receive [(Shard) (Seq [(Shard)]) (None)] None The flow to execute when a packet is received. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Network.Server"},{"location":"shards/Network/Server/#networkserver","text":"( Network.Server :Address [( String ) ( ContextVar [( String )])] :Port [( Int ) ( ContextVar [( Int )])] :Receive [( Shard ) ( Seq [( Shard )]) ( None )] )","title":"Network.Server"},{"location":"shards/Network/Server/#definition","text":"","title":"Definition"},{"location":"shards/Network/Server/#parameters","text":"Name Type Default Description Address [(String) (ContextVar [(String)])] \"localhost\" The local bind address or the remote address. Port [(Int) (ContextVar [(Int)])] 9191 The port to bind if server or to connect to if client. Receive [(Shard) (Seq [(Shard)]) (None)] None The flow to execute when a packet is received.","title":"Parameters"},{"location":"shards/Network/Server/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Network/Server/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Physics/Ball/","text":"Physics.Ball \u00b6 ( Physics.Ball :Position [( Float3 ) ( ContextVar [( Float3 )])] :Rotation [( Float4 ) ( ContextVar [( Float4 )])] :Radius [( Float )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Position [(Float3) (ContextVar [(Float3)])] (0, 0, 0) The position wrt. the body it is attached to. Rotation [(Float4) (ContextVar [(Float4)])] (0, 0, 0, 1) The rotation wrt. the body it is attached to Radius [(Float)] 0.5 The radius of the sphere. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"Physics.Ball"},{"location":"shards/Physics/Ball/#physicsball","text":"( Physics.Ball :Position [( Float3 ) ( ContextVar [( Float3 )])] :Rotation [( Float4 ) ( ContextVar [( Float4 )])] :Radius [( Float )] )","title":"Physics.Ball"},{"location":"shards/Physics/Ball/#definition","text":"","title":"Definition"},{"location":"shards/Physics/Ball/#parameters","text":"Name Type Default Description Position [(Float3) (ContextVar [(Float3)])] (0, 0, 0) The position wrt. the body it is attached to. Rotation [(Float4) (ContextVar [(Float4)])] (0, 0, 0, 1) The rotation wrt. the body it is attached to Radius [(Float)] 0.5 The radius of the sphere.","title":"Parameters"},{"location":"shards/Physics/Ball/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Physics/Ball/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Physics/CastRay/","text":"Physics.CastRay \u00b6 ( Physics.CastRay ) Definition \u00b6 Input \u00b6 Type Description [(Seq [(Float3)])] Output \u00b6 Type Description [(Seq [(Object)])]","title":"Physics.CastRay"},{"location":"shards/Physics/CastRay/#physicscastray","text":"( Physics.CastRay )","title":"Physics.CastRay"},{"location":"shards/Physics/CastRay/#definition","text":"","title":"Definition"},{"location":"shards/Physics/CastRay/#input","text":"Type Description [(Seq [(Float3)])]","title":"Input"},{"location":"shards/Physics/CastRay/#output","text":"Type Description [(Seq [(Object)])]","title":"Output"},{"location":"shards/Physics/Cuboid/","text":"Physics.Cuboid \u00b6 ( Physics.Cuboid :Position [( Float3 ) ( ContextVar [( Float3 )])] :Rotation [( Float4 ) ( ContextVar [( Float4 )])] :HalfExtents [( Float3 )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Position [(Float3) (ContextVar [(Float3)])] (0, 0, 0) The position wrt. the body it is attached to. Rotation [(Float4) (ContextVar [(Float4)])] (0, 0, 0, 1) The rotation wrt. the body it is attached to HalfExtents [(Float3)] (0.5, 0.5, 0.5) The half-extents of the cuboid shape. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"Physics.Cuboid"},{"location":"shards/Physics/Cuboid/#physicscuboid","text":"( Physics.Cuboid :Position [( Float3 ) ( ContextVar [( Float3 )])] :Rotation [( Float4 ) ( ContextVar [( Float4 )])] :HalfExtents [( Float3 )] )","title":"Physics.Cuboid"},{"location":"shards/Physics/Cuboid/#definition","text":"","title":"Definition"},{"location":"shards/Physics/Cuboid/#parameters","text":"Name Type Default Description Position [(Float3) (ContextVar [(Float3)])] (0, 0, 0) The position wrt. the body it is attached to. Rotation [(Float4) (ContextVar [(Float4)])] (0, 0, 0, 1) The rotation wrt. the body it is attached to HalfExtents [(Float3)] (0.5, 0.5, 0.5) The half-extents of the cuboid shape.","title":"Parameters"},{"location":"shards/Physics/Cuboid/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Physics/Cuboid/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/Physics/DynamicBody/","text":"Physics.DynamicBody \u00b6 ( Physics.DynamicBody :Shapes [( ContextVar [( Object )]) ( ContextVar [( Object )]) ( None )] :Position [( Float3 ) ( ContextVar [( Float3 )]) ( Seq [( Float3 )]) ( ContextVar [( Seq [( Float3 )])])] :Rotation [( Float4 ) ( ContextVar [( Float4 )]) ( Seq [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] :Name [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Shapes [(ContextVar [(Object)]) (ContextVar [(Object)]) (None)] None The shape or shapes of this rigid body. Position [(Float3) (ContextVar [(Float3)]) (Seq [(Float3)]) (ContextVar [(Seq [(Float3)])])] (0, 0, 0) The initial position of this rigid body. Can be updated in the case of a kinematic rigid body. Rotation [(Float4) (ContextVar [(Float4)]) (Seq [(Float4)]) (ContextVar [(Seq [(Float4)])])] (0, 0, 0, 1) The initial rotation of this rigid body. Either axis angles in radians Float3 or a quaternion Float4. Can be updated in the case of a kinematic rigid body. Name [(String) (None)] None The optional name of the variable that will be exposed to identify, apply forces (if dynamic) and control this rigid body. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Seq [(Float4)]) (Seq [(Seq [(Float4)])])]","title":"Physics.DynamicBody"},{"location":"shards/Physics/DynamicBody/#physicsdynamicbody","text":"( Physics.DynamicBody :Shapes [( ContextVar [( Object )]) ( ContextVar [( Object )]) ( None )] :Position [( Float3 ) ( ContextVar [( Float3 )]) ( Seq [( Float3 )]) ( ContextVar [( Seq [( Float3 )])])] :Rotation [( Float4 ) ( ContextVar [( Float4 )]) ( Seq [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] :Name [( String ) ( None )] )","title":"Physics.DynamicBody"},{"location":"shards/Physics/DynamicBody/#definition","text":"","title":"Definition"},{"location":"shards/Physics/DynamicBody/#parameters","text":"Name Type Default Description Shapes [(ContextVar [(Object)]) (ContextVar [(Object)]) (None)] None The shape or shapes of this rigid body. Position [(Float3) (ContextVar [(Float3)]) (Seq [(Float3)]) (ContextVar [(Seq [(Float3)])])] (0, 0, 0) The initial position of this rigid body. Can be updated in the case of a kinematic rigid body. Rotation [(Float4) (ContextVar [(Float4)]) (Seq [(Float4)]) (ContextVar [(Seq [(Float4)])])] (0, 0, 0, 1) The initial rotation of this rigid body. Either axis angles in radians Float3 or a quaternion Float4. Can be updated in the case of a kinematic rigid body. Name [(String) (None)] None The optional name of the variable that will be exposed to identify, apply forces (if dynamic) and control this rigid body.","title":"Parameters"},{"location":"shards/Physics/DynamicBody/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Physics/DynamicBody/#output","text":"Type Description [(Seq [(Float4)]) (Seq [(Seq [(Float4)])])]","title":"Output"},{"location":"shards/Physics/Impulse/","text":"Physics.Impulse \u00b6 ( Physics.Impulse :RigidBody [( ContextVar [( Object )]) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description RigidBody [(ContextVar [(Object)]) (None)] None The rigidbody to apply the impulse to. Input \u00b6 Type Description [(Float3)] Output \u00b6 Type Description [(Float3)]","title":"Physics.Impulse"},{"location":"shards/Physics/Impulse/#physicsimpulse","text":"( Physics.Impulse :RigidBody [( ContextVar [( Object )]) ( None )] )","title":"Physics.Impulse"},{"location":"shards/Physics/Impulse/#definition","text":"","title":"Definition"},{"location":"shards/Physics/Impulse/#parameters","text":"Name Type Default Description RigidBody [(ContextVar [(Object)]) (None)] None The rigidbody to apply the impulse to.","title":"Parameters"},{"location":"shards/Physics/Impulse/#input","text":"Type Description [(Float3)]","title":"Input"},{"location":"shards/Physics/Impulse/#output","text":"Type Description [(Float3)]","title":"Output"},{"location":"shards/Physics/KinematicBody/","text":"Physics.KinematicBody \u00b6 ( Physics.KinematicBody :Shapes [( ContextVar [( Object )]) ( ContextVar [( Object )]) ( None )] :Position [( Float3 ) ( ContextVar [( Float3 )]) ( Seq [( Float3 )]) ( ContextVar [( Seq [( Float3 )])])] :Rotation [( Float4 ) ( ContextVar [( Float4 )]) ( Seq [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] :Name [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Shapes [(ContextVar [(Object)]) (ContextVar [(Object)]) (None)] None The shape or shapes of this rigid body. Position [(Float3) (ContextVar [(Float3)]) (Seq [(Float3)]) (ContextVar [(Seq [(Float3)])])] (0, 0, 0) The initial position of this rigid body. Can be updated in the case of a kinematic rigid body. Rotation [(Float4) (ContextVar [(Float4)]) (Seq [(Float4)]) (ContextVar [(Seq [(Float4)])])] (0, 0, 0, 1) The initial rotation of this rigid body. Either axis angles in radians Float3 or a quaternion Float4. Can be updated in the case of a kinematic rigid body. Name [(String) (None)] None The optional name of the variable that will be exposed to identify, apply forces (if dynamic) and control this rigid body. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Seq [(Float4)]) (Seq [(Seq [(Float4)])])]","title":"Physics.KinematicBody"},{"location":"shards/Physics/KinematicBody/#physicskinematicbody","text":"( Physics.KinematicBody :Shapes [( ContextVar [( Object )]) ( ContextVar [( Object )]) ( None )] :Position [( Float3 ) ( ContextVar [( Float3 )]) ( Seq [( Float3 )]) ( ContextVar [( Seq [( Float3 )])])] :Rotation [( Float4 ) ( ContextVar [( Float4 )]) ( Seq [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] :Name [( String ) ( None )] )","title":"Physics.KinematicBody"},{"location":"shards/Physics/KinematicBody/#definition","text":"","title":"Definition"},{"location":"shards/Physics/KinematicBody/#parameters","text":"Name Type Default Description Shapes [(ContextVar [(Object)]) (ContextVar [(Object)]) (None)] None The shape or shapes of this rigid body. Position [(Float3) (ContextVar [(Float3)]) (Seq [(Float3)]) (ContextVar [(Seq [(Float3)])])] (0, 0, 0) The initial position of this rigid body. Can be updated in the case of a kinematic rigid body. Rotation [(Float4) (ContextVar [(Float4)]) (Seq [(Float4)]) (ContextVar [(Seq [(Float4)])])] (0, 0, 0, 1) The initial rotation of this rigid body. Either axis angles in radians Float3 or a quaternion Float4. Can be updated in the case of a kinematic rigid body. Name [(String) (None)] None The optional name of the variable that will be exposed to identify, apply forces (if dynamic) and control this rigid body.","title":"Parameters"},{"location":"shards/Physics/KinematicBody/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Physics/KinematicBody/#output","text":"Type Description [(Seq [(Float4)]) (Seq [(Seq [(Float4)])])]","title":"Output"},{"location":"shards/Physics/Simulation/","text":"Physics.Simulation \u00b6 ( Physics.Simulation :Gravity [( Float )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Gravity [(Float)] (0, -9.81, 0) The gravity force vector. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Physics.Simulation"},{"location":"shards/Physics/Simulation/#physicssimulation","text":"( Physics.Simulation :Gravity [( Float )] )","title":"Physics.Simulation"},{"location":"shards/Physics/Simulation/#definition","text":"","title":"Definition"},{"location":"shards/Physics/Simulation/#parameters","text":"Name Type Default Description Gravity [(Float)] (0, -9.81, 0) The gravity force vector.","title":"Parameters"},{"location":"shards/Physics/Simulation/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Physics/Simulation/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Physics/StaticBody/","text":"Physics.StaticBody \u00b6 ( Physics.StaticBody :Shapes [( ContextVar [( Object )]) ( ContextVar [( Object )]) ( None )] :Position [( Float3 ) ( ContextVar [( Float3 )]) ( Seq [( Float3 )]) ( ContextVar [( Seq [( Float3 )])])] :Rotation [( Float4 ) ( ContextVar [( Float4 )]) ( Seq [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] :Name [( String ) ( None )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Shapes [(ContextVar [(Object)]) (ContextVar [(Object)]) (None)] None The shape or shapes of this rigid body. Position [(Float3) (ContextVar [(Float3)]) (Seq [(Float3)]) (ContextVar [(Seq [(Float3)])])] (0, 0, 0) The initial position of this rigid body. Can be updated in the case of a kinematic rigid body. Rotation [(Float4) (ContextVar [(Float4)]) (Seq [(Float4)]) (ContextVar [(Seq [(Float4)])])] (0, 0, 0, 1) The initial rotation of this rigid body. Either axis angles in radians Float3 or a quaternion Float4. Can be updated in the case of a kinematic rigid body. Name [(String) (None)] None The optional name of the variable that will be exposed to identify, apply forces (if dynamic) and control this rigid body. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"Physics.StaticBody"},{"location":"shards/Physics/StaticBody/#physicsstaticbody","text":"( Physics.StaticBody :Shapes [( ContextVar [( Object )]) ( ContextVar [( Object )]) ( None )] :Position [( Float3 ) ( ContextVar [( Float3 )]) ( Seq [( Float3 )]) ( ContextVar [( Seq [( Float3 )])])] :Rotation [( Float4 ) ( ContextVar [( Float4 )]) ( Seq [( Float4 )]) ( ContextVar [( Seq [( Float4 )])])] :Name [( String ) ( None )] )","title":"Physics.StaticBody"},{"location":"shards/Physics/StaticBody/#definition","text":"","title":"Definition"},{"location":"shards/Physics/StaticBody/#parameters","text":"Name Type Default Description Shapes [(ContextVar [(Object)]) (ContextVar [(Object)]) (None)] None The shape or shapes of this rigid body. Position [(Float3) (ContextVar [(Float3)]) (Seq [(Float3)]) (ContextVar [(Seq [(Float3)])])] (0, 0, 0) The initial position of this rigid body. Can be updated in the case of a kinematic rigid body. Rotation [(Float4) (ContextVar [(Float4)]) (Seq [(Float4)]) (ContextVar [(Seq [(Float4)])])] (0, 0, 0, 1) The initial rotation of this rigid body. Either axis angles in radians Float3 or a quaternion Float4. Can be updated in the case of a kinematic rigid body. Name [(String) (None)] None The optional name of the variable that will be exposed to identify, apply forces (if dynamic) and control this rigid body.","title":"Parameters"},{"location":"shards/Physics/StaticBody/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Physics/StaticBody/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Process/Run/","text":"Process.Run \u00b6 ( Process.Run :Executable [( Path ) ( String )] :Arguments [( None ) ( Seq [( String )]) ( ContextVar [( Seq [( String )])])] :Timeout [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Executable [(Path) (String)] \"\" The executable to run. Arguments [(None) (Seq [(String)]) (ContextVar [(Seq [(String)])])] None The arguments to pass to the executable. Timeout [(Int)] 30 The maximum time to wait for the executable to finish in seconds. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"Process.Run"},{"location":"shards/Process/Run/#processrun","text":"( Process.Run :Executable [( Path ) ( String )] :Arguments [( None ) ( Seq [( String )]) ( ContextVar [( Seq [( String )])])] :Timeout [( Int )] )","title":"Process.Run"},{"location":"shards/Process/Run/#definition","text":"","title":"Definition"},{"location":"shards/Process/Run/#parameters","text":"Name Type Default Description Executable [(Path) (String)] \"\" The executable to run. Arguments [(None) (Seq [(String)]) (ContextVar [(Seq [(String)])])] None The arguments to pass to the executable. Timeout [(Int)] 30 The maximum time to wait for the executable to finish in seconds.","title":"Parameters"},{"location":"shards/Process/Run/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Process/Run/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Process/StackTrace/","text":"Process.StackTrace \u00b6 ( Process.StackTrace ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(String)]","title":"Process.StackTrace"},{"location":"shards/Process/StackTrace/#processstacktrace","text":"( Process.StackTrace )","title":"Process.StackTrace"},{"location":"shards/Process/StackTrace/#definition","text":"","title":"Definition"},{"location":"shards/Process/StackTrace/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Process/StackTrace/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Reflect/Name/","text":"Reflect.Name \u00b6 ( Reflect.Name ) Definition \u00b6 Input \u00b6 Type Description [(Shard)] Output \u00b6 Type Description [(String)]","title":"Reflect.Name"},{"location":"shards/Reflect/Name/#reflectname","text":"( Reflect.Name )","title":"Reflect.Name"},{"location":"shards/Reflect/Name/#definition","text":"","title":"Definition"},{"location":"shards/Reflect/Name/#input","text":"Type Description [(Shard)]","title":"Input"},{"location":"shards/Reflect/Name/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Reflect/Shards/","text":"Reflect.Shards \u00b6 ( Reflect.Shards ) Definition \u00b6 Given a wire as input it will recurse deep inside it and gather all shards in the wire, its sub-wires and sub-flows. Input \u00b6 Type Description [(Wire)] Output \u00b6 Type Description [(Seq [(Shard)])]","title":"Reflect.Shards"},{"location":"shards/Reflect/Shards/#reflectshards","text":"( Reflect.Shards )","title":"Reflect.Shards"},{"location":"shards/Reflect/Shards/#definition","text":"Given a wire as input it will recurse deep inside it and gather all shards in the wire, its sub-wires and sub-flows.","title":"Definition"},{"location":"shards/Reflect/Shards/#input","text":"Type Description [(Wire)]","title":"Input"},{"location":"shards/Reflect/Shards/#output","text":"Type Description [(Seq [(Shard)])]","title":"Output"},{"location":"shards/Regex/Match/","text":"Regex.Match \u00b6 ( Regex.Match :Regex [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Regex [(String)] \"\" The regular expression. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Seq [(String)])]","title":"Regex.Match"},{"location":"shards/Regex/Match/#regexmatch","text":"( Regex.Match :Regex [( String )] )","title":"Regex.Match"},{"location":"shards/Regex/Match/#definition","text":"","title":"Definition"},{"location":"shards/Regex/Match/#parameters","text":"Name Type Default Description Regex [(String)] \"\" The regular expression.","title":"Parameters"},{"location":"shards/Regex/Match/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Regex/Match/#output","text":"Type Description [(Seq [(String)])]","title":"Output"},{"location":"shards/Regex/Replace/","text":"Regex.Replace \u00b6 ( Regex.Replace :Regex [( String )] :Replacement [( String ) ( ContextVar [( String )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Regex [(String)] \"\" The regular expression. Replacement [(String) (ContextVar [(String)])] None The replacement expression. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"Regex.Replace"},{"location":"shards/Regex/Replace/#regexreplace","text":"( Regex.Replace :Regex [( String )] :Replacement [( String ) ( ContextVar [( String )])] )","title":"Regex.Replace"},{"location":"shards/Regex/Replace/#definition","text":"","title":"Definition"},{"location":"shards/Regex/Replace/#parameters","text":"Name Type Default Description Regex [(String)] \"\" The regular expression. Replacement [(String) (ContextVar [(String)])] None The replacement expression.","title":"Parameters"},{"location":"shards/Regex/Replace/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Regex/Replace/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Regex/Search/","text":"Regex.Search \u00b6 ( Regex.Search :Regex [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Regex [(String)] \"\" The regular expression. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Seq [(String)])]","title":"Regex.Search"},{"location":"shards/Regex/Search/#regexsearch","text":"( Regex.Search :Regex [( String )] )","title":"Regex.Search"},{"location":"shards/Regex/Search/#definition","text":"","title":"Definition"},{"location":"shards/Regex/Search/#parameters","text":"Name Type Default Description Regex [(String)] \"\" The regular expression.","title":"Parameters"},{"location":"shards/Regex/Search/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Regex/Search/#output","text":"Type Description [(Seq [(String)])]","title":"Output"},{"location":"shards/SVG/ToImage/","text":"SVG.ToImage \u00b6 ( SVG.ToImage :Size [( Int2 )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Size [(Int2)] (0, 0) The desired output size, if (0, 0) will default to the size defined in the svg data. Input \u00b6 Type Description [(String) (Bytes)] Output \u00b6 Type Description [(Image)]","title":"SVG.ToImage"},{"location":"shards/SVG/ToImage/#svgtoimage","text":"( SVG.ToImage :Size [( Int2 )] )","title":"SVG.ToImage"},{"location":"shards/SVG/ToImage/#definition","text":"","title":"Definition"},{"location":"shards/SVG/ToImage/#parameters","text":"Name Type Default Description Size [(Int2)] (0, 0) The desired output size, if (0, 0) will default to the size defined in the svg data.","title":"Parameters"},{"location":"shards/SVG/ToImage/#input","text":"Type Description [(String) (Bytes)]","title":"Input"},{"location":"shards/SVG/ToImage/#output","text":"Type Description [(Image)]","title":"Output"},{"location":"shards/Shader/Literal/","text":"Shader.Literal \u00b6 ( Shader.Literal :Source [( String ) ( ContextVar [( String )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Source [(String) (ContextVar [(String)])] None The shader source to insert Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(None)]","title":"Shader.Literal"},{"location":"shards/Shader/Literal/#shaderliteral","text":"( Shader.Literal :Source [( String ) ( ContextVar [( String )])] )","title":"Shader.Literal"},{"location":"shards/Shader/Literal/#definition","text":"","title":"Definition"},{"location":"shards/Shader/Literal/#parameters","text":"Name Type Default Description Source [(String) (ContextVar [(String)])] None The shader source to insert","title":"Parameters"},{"location":"shards/Shader/Literal/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Shader/Literal/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/Shader/ReadBuffer/","text":"Shader.ReadBuffer \u00b6 ( Shader.ReadBuffer :Name [( String )] :Type [( Enum )] :Dimension [( Int )] :BufferName [( String )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1) BufferName [(String)] \"object\" The name of the buffer to read from (object/view) (default: object) Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Any)]","title":"Shader.ReadBuffer"},{"location":"shards/Shader/ReadBuffer/#shaderreadbuffer","text":"( Shader.ReadBuffer :Name [( String )] :Type [( Enum )] :Dimension [( Int )] :BufferName [( String )] )","title":"Shader.ReadBuffer"},{"location":"shards/Shader/ReadBuffer/#definition","text":"","title":"Definition"},{"location":"shards/Shader/ReadBuffer/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1) BufferName [(String)] \"object\" The name of the buffer to read from (object/view) (default: object)","title":"Parameters"},{"location":"shards/Shader/ReadBuffer/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Shader/ReadBuffer/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Shader/ReadGlobal/","text":"Shader.ReadGlobal \u00b6 ( Shader.ReadGlobal :Name [( String )] :Type [( Enum )] :Dimension [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1) Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Any)]","title":"Shader.ReadGlobal"},{"location":"shards/Shader/ReadGlobal/#shaderreadglobal","text":"( Shader.ReadGlobal :Name [( String )] :Type [( Enum )] :Dimension [( Int )] )","title":"Shader.ReadGlobal"},{"location":"shards/Shader/ReadGlobal/#definition","text":"","title":"Definition"},{"location":"shards/Shader/ReadGlobal/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1)","title":"Parameters"},{"location":"shards/Shader/ReadGlobal/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Shader/ReadGlobal/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Shader/ReadInput/","text":"Shader.ReadInput \u00b6 ( Shader.ReadInput :Name [( String )] :Type [( Enum )] :Dimension [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1) Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Any)]","title":"Shader.ReadInput"},{"location":"shards/Shader/ReadInput/#shaderreadinput","text":"( Shader.ReadInput :Name [( String )] :Type [( Enum )] :Dimension [( Int )] )","title":"Shader.ReadInput"},{"location":"shards/Shader/ReadInput/#definition","text":"","title":"Definition"},{"location":"shards/Shader/ReadInput/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1)","title":"Parameters"},{"location":"shards/Shader/ReadInput/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Shader/ReadInput/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/Shader/WriteGlobal/","text":"Shader.WriteGlobal \u00b6 ( Shader.WriteGlobal :Name [( String )] :Type [( Enum )] :Dimension [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1) Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(None)]","title":"Shader.WriteGlobal"},{"location":"shards/Shader/WriteGlobal/#shaderwriteglobal","text":"( Shader.WriteGlobal :Name [( String )] :Type [( Enum )] :Dimension [( Int )] )","title":"Shader.WriteGlobal"},{"location":"shards/Shader/WriteGlobal/#definition","text":"","title":"Definition"},{"location":"shards/Shader/WriteGlobal/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1)","title":"Parameters"},{"location":"shards/Shader/WriteGlobal/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Shader/WriteGlobal/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/Shader/WriteOutput/","text":"Shader.WriteOutput \u00b6 ( Shader.WriteOutput :Name [( String )] :Type [( Enum )] :Dimension [( Int )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1) Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(None)]","title":"Shader.WriteOutput"},{"location":"shards/Shader/WriteOutput/#shaderwriteoutput","text":"( Shader.WriteOutput :Name [( String )] :Type [( Enum )] :Dimension [( Int )] )","title":"Shader.WriteOutput"},{"location":"shards/Shader/WriteOutput/#definition","text":"","title":"Definition"},{"location":"shards/Shader/WriteOutput/#parameters","text":"Name Type Default Description Name [(String)] \"\" The name of the field to read/write Type [(Enum)] Enum: 7 vendor: 0x63676678 type: 0x5f6531 The expected type (default: Float32) Dimension [(Int)] 1 The expected dimension of the type. 1 for scalars. 2,3,4 for vectors. (default: 1)","title":"Parameters"},{"location":"shards/Shader/WriteOutput/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/Shader/WriteOutput/#output","text":"Type Description [(None)]","title":"Output"},{"location":"shards/Snappy/Compress/","text":"Snappy.Compress \u00b6 ( Snappy.Compress ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"Snappy.Compress"},{"location":"shards/Snappy/Compress/#snappycompress","text":"( Snappy.Compress )","title":"Snappy.Compress"},{"location":"shards/Snappy/Compress/#definition","text":"","title":"Definition"},{"location":"shards/Snappy/Compress/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/Snappy/Compress/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Snappy/Decompress/","text":"Snappy.Decompress \u00b6 ( Snappy.Decompress ) Definition \u00b6 Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"Snappy.Decompress"},{"location":"shards/Snappy/Decompress/#snappydecompress","text":"( Snappy.Decompress )","title":"Snappy.Decompress"},{"location":"shards/Snappy/Decompress/#definition","text":"","title":"Definition"},{"location":"shards/Snappy/Decompress/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/Snappy/Decompress/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Sr25519/PublicKey/","text":"Sr25519.PublicKey \u00b6 ( Sr25519.PublicKey ) Definition \u00b6 Input \u00b6 Type Description [(Bytes) (String)] Output \u00b6 Type Description [(Bytes)]","title":"Sr25519.PublicKey"},{"location":"shards/Sr25519/PublicKey/#sr25519publickey","text":"( Sr25519.PublicKey )","title":"Sr25519.PublicKey"},{"location":"shards/Sr25519/PublicKey/#definition","text":"","title":"Definition"},{"location":"shards/Sr25519/PublicKey/#input","text":"Type Description [(Bytes) (String)]","title":"Input"},{"location":"shards/Sr25519/PublicKey/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Sr25519/Seed/","text":"Sr25519.Seed \u00b6 ( Sr25519.Seed ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(Bytes)]","title":"Sr25519.Seed"},{"location":"shards/Sr25519/Seed/#sr25519seed","text":"( Sr25519.Seed )","title":"Sr25519.Seed"},{"location":"shards/Sr25519/Seed/#definition","text":"","title":"Definition"},{"location":"shards/Sr25519/Seed/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Sr25519/Seed/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/Sr25519/Sign/","text":"Sr25519.Sign \u00b6 ( Sr25519.Sign :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to sign the hashed message input. Input \u00b6 Type Description [(Bytes)] Output \u00b6 Type Description [(Bytes)]","title":"Sr25519.Sign"},{"location":"shards/Sr25519/Sign/#sr25519sign","text":"( Sr25519.Sign :Key [( Bytes ) ( ContextVar [( Bytes )]) ( String ) ( ContextVar [( String )])] )","title":"Sr25519.Sign"},{"location":"shards/Sr25519/Sign/#definition","text":"","title":"Definition"},{"location":"shards/Sr25519/Sign/#parameters","text":"Name Type Default Description Key [(Bytes) (ContextVar [(Bytes)]) (String) (ContextVar [(String)])] None The private key to be used to sign the hashed message input.","title":"Parameters"},{"location":"shards/Sr25519/Sign/#input","text":"Type Description [(Bytes)]","title":"Input"},{"location":"shards/Sr25519/Sign/#output","text":"Type Description [(Bytes)]","title":"Output"},{"location":"shards/String/EncodeURI/","text":"String.EncodeURI \u00b6 ( String.EncodeURI ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"String.EncodeURI"},{"location":"shards/String/EncodeURI/#stringencodeuri","text":"( String.EncodeURI )","title":"String.EncodeURI"},{"location":"shards/String/EncodeURI/#definition","text":"","title":"Definition"},{"location":"shards/String/EncodeURI/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/String/EncodeURI/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/String/Join/","text":"String.Join \u00b6 ( String.Join :Separator [( String )] ) Definition \u00b6 Concatenates all the elements of a string sequence, using the specified separator between each element. Parameters \u00b6 Name Type Default Description Separator [(String)] \"\" The string to use as a separator. Input \u00b6 Type Description [(Seq [(String)])] A sequence of string values that will be joined together. Output \u00b6 Type Description [(String)] A string consisting of all the elements of the sequence delimited by the separator. Examples \u00b6 Code Output 1 2 3 4 5 6 7 8 9 [ \"The quick brown fox \" \"jumps over the lazy dog\" \".\" ] ( String.Join ) ( Log ) ( Assert.Is \"The quick brown fox jumps over the lazy dog.\" :Abort true ) [ \"2001\" \"01\" \"01\" ] ( String.Join \"/\" ) ( Log ) ( Assert.Is \"2001/01/01\" :Abort true ) [info] [2022-08-15 10:09:36.363] [T-3452] [logging.cpp::55] [shards/String/Join/1.edn] The quick brown fox jumps over the lazy dog. [info] [2022-08-15 10:09:36.364] [T-3452] [logging.cpp::55] [shards/String/Join/1.edn] 2001/01/01","title":"String.Join"},{"location":"shards/String/Join/#stringjoin","text":"( String.Join :Separator [( String )] )","title":"String.Join"},{"location":"shards/String/Join/#definition","text":"Concatenates all the elements of a string sequence, using the specified separator between each element.","title":"Definition"},{"location":"shards/String/Join/#parameters","text":"Name Type Default Description Separator [(String)] \"\" The string to use as a separator.","title":"Parameters"},{"location":"shards/String/Join/#input","text":"Type Description [(Seq [(String)])] A sequence of string values that will be joined together.","title":"Input"},{"location":"shards/String/Join/#output","text":"Type Description [(String)] A string consisting of all the elements of the sequence delimited by the separator.","title":"Output"},{"location":"shards/String/Join/#examples","text":"Code Output 1 2 3 4 5 6 7 8 9 [ \"The quick brown fox \" \"jumps over the lazy dog\" \".\" ] ( String.Join ) ( Log ) ( Assert.Is \"The quick brown fox jumps over the lazy dog.\" :Abort true ) [ \"2001\" \"01\" \"01\" ] ( String.Join \"/\" ) ( Log ) ( Assert.Is \"2001/01/01\" :Abort true ) [info] [2022-08-15 10:09:36.363] [T-3452] [logging.cpp::55] [shards/String/Join/1.edn] The quick brown fox jumps over the lazy dog. [info] [2022-08-15 10:09:36.364] [T-3452] [logging.cpp::55] [shards/String/Join/1.edn] 2001/01/01","title":"Examples"},{"location":"shards/String/ToLower/","text":"String.ToLower \u00b6 ( String.ToLower ) Definition \u00b6 Converts a string to lowercase Input \u00b6 Type Description [(String)] A string. Output \u00b6 Type Description [(String)] A string in lowercase. Examples \u00b6 Code Output 1 2 \"Hello\" ( String.ToLower ) ( Log ) ( Assert.Is \"hello\" :Abort true ) [info] [2022-08-15 10:09:36.422] [T-5076] [logging.cpp::55] [shards/String/ToLower/1.edn] hello","title":"String.ToLower"},{"location":"shards/String/ToLower/#stringtolower","text":"( String.ToLower )","title":"String.ToLower"},{"location":"shards/String/ToLower/#definition","text":"Converts a string to lowercase","title":"Definition"},{"location":"shards/String/ToLower/#input","text":"Type Description [(String)] A string.","title":"Input"},{"location":"shards/String/ToLower/#output","text":"Type Description [(String)] A string in lowercase.","title":"Output"},{"location":"shards/String/ToLower/#examples","text":"Code Output 1 2 \"Hello\" ( String.ToLower ) ( Log ) ( Assert.Is \"hello\" :Abort true ) [info] [2022-08-15 10:09:36.422] [T-5076] [logging.cpp::55] [shards/String/ToLower/1.edn] hello","title":"Examples"},{"location":"shards/String/ToUpper/","text":"String.ToUpper \u00b6 ( String.ToUpper ) Definition \u00b6 Converts a string to uppercase Input \u00b6 Type Description [(String)] A string. Output \u00b6 Type Description [(String)] A string in uppercase. Examples \u00b6 Code Output 1 2 \"Hello\" ( String.ToUpper ) ( Log ) ( Assert.Is \"HELLO\" :Abort true ) [info] [2022-08-15 10:09:36.481] [T-6984] [logging.cpp::55] [shards/String/ToUpper/1.edn] HELLO","title":"String.ToUpper"},{"location":"shards/String/ToUpper/#stringtoupper","text":"( String.ToUpper )","title":"String.ToUpper"},{"location":"shards/String/ToUpper/#definition","text":"Converts a string to uppercase","title":"Definition"},{"location":"shards/String/ToUpper/#input","text":"Type Description [(String)] A string.","title":"Input"},{"location":"shards/String/ToUpper/#output","text":"Type Description [(String)] A string in uppercase.","title":"Output"},{"location":"shards/String/ToUpper/#examples","text":"Code Output 1 2 \"Hello\" ( String.ToUpper ) ( Log ) ( Assert.Is \"HELLO\" :Abort true ) [info] [2022-08-15 10:09:36.481] [T-6984] [logging.cpp::55] [shards/String/ToUpper/1.edn] HELLO","title":"Examples"},{"location":"shards/String/Trim/","text":"String.Trim \u00b6 ( String.Trim ) Definition \u00b6 Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"String.Trim"},{"location":"shards/String/Trim/#stringtrim","text":"( String.Trim )","title":"String.Trim"},{"location":"shards/String/Trim/#definition","text":"","title":"Definition"},{"location":"shards/String/Trim/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/String/Trim/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Substrate/AccountId/","text":"Substrate.AccountId \u00b6 ( Substrate.AccountId :ECDSA [( Bool )] :Version [( Int )] ) Definition \u00b6 Returns the account id of the input public key. Parameters \u00b6 Name Type Default Description ECDSA [(Bool)] false If the input public key is an ECDSA and not the default Sr25519/Ed25519. Version [(Int)] 42 The substrate version prefix. Input \u00b6 Type Description [(Bytes)] The public key bytes, must be a valid Sr25519 or Ed25519 public key. Output \u00b6 Type Description [(String)] The Substrate account id in SS58 format.","title":"Substrate.AccountId"},{"location":"shards/Substrate/AccountId/#substrateaccountid","text":"( Substrate.AccountId :ECDSA [( Bool )] :Version [( Int )] )","title":"Substrate.AccountId"},{"location":"shards/Substrate/AccountId/#definition","text":"Returns the account id of the input public key.","title":"Definition"},{"location":"shards/Substrate/AccountId/#parameters","text":"Name Type Default Description ECDSA [(Bool)] false If the input public key is an ECDSA and not the default Sr25519/Ed25519. Version [(Int)] 42 The substrate version prefix.","title":"Parameters"},{"location":"shards/Substrate/AccountId/#input","text":"Type Description [(Bytes)] The public key bytes, must be a valid Sr25519 or Ed25519 public key.","title":"Input"},{"location":"shards/Substrate/AccountId/#output","text":"Type Description [(String)] The Substrate account id in SS58 format.","title":"Output"},{"location":"shards/Substrate/Decode/","text":"Substrate.Decode \u00b6 ( Substrate.Decode :Types [( Seq [( Enum )])] :Hints [( Seq [( String ) ( None )])] :Version [( Int )] ) Definition \u00b6 Decode SCALE encoded bytes into values Parameters \u00b6 Name Type Default Description Types [(Seq [(Enum)])] None The list of types expected to decode. Hints [(Seq [(String) (None)])] None The hints of the types to decode, either \"i8\"/\"u8\", \"i16\"/\"u16\" etc... for int types, \"c\" for Compact int, \"a\" for AccountId or nil for other types. Version [(Int)] 42 The substrate version prefix. Input \u00b6 Type Description [(Bytes)] The encoded SCALE bytes. Output \u00b6 Type Description [(Seq [(Any)])] The decoded values.","title":"Substrate.Decode"},{"location":"shards/Substrate/Decode/#substratedecode","text":"( Substrate.Decode :Types [( Seq [( Enum )])] :Hints [( Seq [( String ) ( None )])] :Version [( Int )] )","title":"Substrate.Decode"},{"location":"shards/Substrate/Decode/#definition","text":"Decode SCALE encoded bytes into values","title":"Definition"},{"location":"shards/Substrate/Decode/#parameters","text":"Name Type Default Description Types [(Seq [(Enum)])] None The list of types expected to decode. Hints [(Seq [(String) (None)])] None The hints of the types to decode, either \"i8\"/\"u8\", \"i16\"/\"u16\" etc... for int types, \"c\" for Compact int, \"a\" for AccountId or nil for other types. Version [(Int)] 42 The substrate version prefix.","title":"Parameters"},{"location":"shards/Substrate/Decode/#input","text":"Type Description [(Bytes)] The encoded SCALE bytes.","title":"Input"},{"location":"shards/Substrate/Decode/#output","text":"Type Description [(Seq [(Any)])] The decoded values.","title":"Output"},{"location":"shards/Substrate/Encode/","text":"Substrate.Encode \u00b6 ( Substrate.Encode :Hints [( Seq [( String ) ( None )])] ) Definition \u00b6 Encode values into a byte array in SCALE format Parameters \u00b6 Name Type Default Description Hints [(Seq [(String) (None)])] None The hints of types to encode, either \"i8\"/\"u8\", \"i16\"/\"u16\" etc... for int types, \"c\" for Compact int, \"a\" for AccountId or nil for other types. Input \u00b6 Type Description [(Seq [(Any)])] A sequence of values to SCALE encode. Output \u00b6 Type Description [(Bytes)] The encoded SCALE bytes.","title":"Substrate.Encode"},{"location":"shards/Substrate/Encode/#substrateencode","text":"( Substrate.Encode :Hints [( Seq [( String ) ( None )])] )","title":"Substrate.Encode"},{"location":"shards/Substrate/Encode/#definition","text":"Encode values into a byte array in SCALE format","title":"Definition"},{"location":"shards/Substrate/Encode/#parameters","text":"Name Type Default Description Hints [(Seq [(String) (None)])] None The hints of types to encode, either \"i8\"/\"u8\", \"i16\"/\"u16\" etc... for int types, \"c\" for Compact int, \"a\" for AccountId or nil for other types.","title":"Parameters"},{"location":"shards/Substrate/Encode/#input","text":"Type Description [(Seq [(Any)])] A sequence of values to SCALE encode.","title":"Input"},{"location":"shards/Substrate/Encode/#output","text":"Type Description [(Bytes)] The encoded SCALE bytes.","title":"Output"},{"location":"shards/Substrate/StorageKey/","text":"Substrate.StorageKey \u00b6 ( Substrate.StorageKey ) Definition \u00b6 Returns the encoded storage key corresponding to the input strings. Input \u00b6 Type Description [(Seq [(String)])] A sequence of two strings representing the key we want to encode. Output \u00b6 Type Description [(Bytes)] The encoded storage key.","title":"Substrate.StorageKey"},{"location":"shards/Substrate/StorageKey/#substratestoragekey","text":"( Substrate.StorageKey )","title":"Substrate.StorageKey"},{"location":"shards/Substrate/StorageKey/#definition","text":"Returns the encoded storage key corresponding to the input strings.","title":"Definition"},{"location":"shards/Substrate/StorageKey/#input","text":"Type Description [(Seq [(String)])] A sequence of two strings representing the key we want to encode.","title":"Input"},{"location":"shards/Substrate/StorageKey/#output","text":"Type Description [(Bytes)] The encoded storage key.","title":"Output"},{"location":"shards/Substrate/StorageMap/","text":"Substrate.StorageMap \u00b6 ( Substrate.StorageMap :PreHashed [( Bool )] ) Definition \u00b6 Returns the encoded storage map corresponding to the input strings. Parameters \u00b6 Name Type Default Description PreHashed [(Bool)] false If the keys are already hashed. Input \u00b6 Type Description [(Seq [(String)])] A sequence of three strings representing the map we want to encode, the last one being SCALE encoded data of the key. Output \u00b6 Type Description [(Bytes)] The encoded storage map.","title":"Substrate.StorageMap"},{"location":"shards/Substrate/StorageMap/#substratestoragemap","text":"( Substrate.StorageMap :PreHashed [( Bool )] )","title":"Substrate.StorageMap"},{"location":"shards/Substrate/StorageMap/#definition","text":"Returns the encoded storage map corresponding to the input strings.","title":"Definition"},{"location":"shards/Substrate/StorageMap/#parameters","text":"Name Type Default Description PreHashed [(Bool)] false If the keys are already hashed.","title":"Parameters"},{"location":"shards/Substrate/StorageMap/#input","text":"Type Description [(Seq [(String)])] A sequence of three strings representing the map we want to encode, the last one being SCALE encoded data of the key.","title":"Input"},{"location":"shards/Substrate/StorageMap/#output","text":"Type Description [(Bytes)] The encoded storage map.","title":"Output"},{"location":"shards/Time/Delta/","text":"Time.Delta \u00b6 ( Time.Delta ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float)]","title":"Time.Delta"},{"location":"shards/Time/Delta/#timedelta","text":"( Time.Delta )","title":"Time.Delta"},{"location":"shards/Time/Delta/#definition","text":"","title":"Definition"},{"location":"shards/Time/Delta/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Time/Delta/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/Time/DeltaMs/","text":"Time.DeltaMs \u00b6 ( Time.DeltaMs ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float)]","title":"Time.DeltaMs"},{"location":"shards/Time/DeltaMs/#timedeltams","text":"( Time.DeltaMs )","title":"Time.DeltaMs"},{"location":"shards/Time/DeltaMs/#definition","text":"","title":"Definition"},{"location":"shards/Time/DeltaMs/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Time/DeltaMs/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/Time/EpochMs/","text":"Time.EpochMs \u00b6 ( Time.EpochMs ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Int)]","title":"Time.EpochMs"},{"location":"shards/Time/EpochMs/#timeepochms","text":"( Time.EpochMs )","title":"Time.EpochMs"},{"location":"shards/Time/EpochMs/#definition","text":"","title":"Definition"},{"location":"shards/Time/EpochMs/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Time/EpochMs/#output","text":"Type Description [(Int)]","title":"Output"},{"location":"shards/Time/Now/","text":"Time.Now \u00b6 ( Time.Now ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float)]","title":"Time.Now"},{"location":"shards/Time/Now/#timenow","text":"( Time.Now )","title":"Time.Now"},{"location":"shards/Time/Now/#definition","text":"","title":"Definition"},{"location":"shards/Time/Now/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Time/Now/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/Time/NowMs/","text":"Time.NowMs \u00b6 ( Time.NowMs ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Float)]","title":"Time.NowMs"},{"location":"shards/Time/NowMs/#timenowms","text":"( Time.NowMs )","title":"Time.NowMs"},{"location":"shards/Time/NowMs/#definition","text":"","title":"Definition"},{"location":"shards/Time/NowMs/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Time/NowMs/#output","text":"Type Description [(Float)]","title":"Output"},{"location":"shards/Time/Pop/","text":"Time.Pop \u00b6 ( Time.Pop :Sequence [( ContextVar [( Any ) ( Int )]) ( None )] ) Definition \u00b6 This shards delays its output until one of the values of the sequence parameter expires. Parameters \u00b6 Name Type Default Description Sequence [(ContextVar [(Any) (Int)]) (None)] None A variables sequence of pairs [value pop-epoch-time-ms] with types [Any Int] Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Any)]","title":"Time.Pop"},{"location":"shards/Time/Pop/#timepop","text":"( Time.Pop :Sequence [( ContextVar [( Any ) ( Int )]) ( None )] )","title":"Time.Pop"},{"location":"shards/Time/Pop/#definition","text":"This shards delays its output until one of the values of the sequence parameter expires.","title":"Definition"},{"location":"shards/Time/Pop/#parameters","text":"Name Type Default Description Sequence [(ContextVar [(Any) (Int)]) (None)] None A variables sequence of pairs [value pop-epoch-time-ms] with types [Any Int]","title":"Parameters"},{"location":"shards/Time/Pop/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Time/Pop/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/UI/","text":"UI \u00b6 ( UI :Queue [( ContextVar [( Object )])] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Initializes a UI context. Parameters \u00b6 Name Type Default Description Queue [(ContextVar [(Object)])] None The draw queue Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"UI"},{"location":"shards/UI/#ui","text":"( UI :Queue [( ContextVar [( Object )])] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI"},{"location":"shards/UI/#definition","text":"Initializes a UI context.","title":"Definition"},{"location":"shards/UI/#parameters","text":"Name Type Default Description Queue [(ContextVar [(Object)])] None The draw queue Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/UI/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/UI/BottomPanel/","text":"UI.BottomPanel \u00b6 ( UI.BottomPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Layout UI elements into the panel. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the panel. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.BottomPanel"},{"location":"shards/UI/BottomPanel/#uibottompanel","text":"( UI.BottomPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.BottomPanel"},{"location":"shards/UI/BottomPanel/#definition","text":"Layout UI elements into the panel.","title":"Definition"},{"location":"shards/UI/BottomPanel/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/BottomPanel/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the panel.","title":"Input"},{"location":"shards/UI/BottomPanel/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Button/","text":"UI.Button \u00b6 ( UI.Button :Label [( String )] :Action [( None ) ( Shard ) ( Seq [( Shard )])] :Wrap [( Bool ) ( None )] ) Definition \u00b6 Clickable button with text. Parameters \u00b6 Name Type Default Description Label [(String)] None The text label of this button. Action [(None) (Shard) (Seq [(Shard)])] None The shards to execute when the button is pressed. Wrap [(Bool) (None)] None Wrap the text depending on the layout. Input \u00b6 Type Description [(Any)] The value that will be passed to the Action shards of the button. Output \u00b6 Type Description [(Bool)] Indicates whether the button was clicked during this frame.","title":"UI.Button"},{"location":"shards/UI/Button/#uibutton","text":"( UI.Button :Label [( String )] :Action [( None ) ( Shard ) ( Seq [( Shard )])] :Wrap [( Bool ) ( None )] )","title":"UI.Button"},{"location":"shards/UI/Button/#definition","text":"Clickable button with text.","title":"Definition"},{"location":"shards/UI/Button/#parameters","text":"Name Type Default Description Label [(String)] None The text label of this button. Action [(None) (Shard) (Seq [(Shard)])] None The shards to execute when the button is pressed. Wrap [(Bool) (None)] None Wrap the text depending on the layout.","title":"Parameters"},{"location":"shards/UI/Button/#input","text":"Type Description [(Any)] The value that will be passed to the Action shards of the button.","title":"Input"},{"location":"shards/UI/Button/#output","text":"Type Description [(Bool)] Indicates whether the button was clicked during this frame.","title":"Output"},{"location":"shards/UI/CentralPanel/","text":"UI.CentralPanel \u00b6 ( UI.CentralPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Layout UI elements into the central panel. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the panel. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.CentralPanel"},{"location":"shards/UI/CentralPanel/#uicentralpanel","text":"( UI.CentralPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.CentralPanel"},{"location":"shards/UI/CentralPanel/#definition","text":"Layout UI elements into the central panel.","title":"Definition"},{"location":"shards/UI/CentralPanel/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/CentralPanel/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the panel.","title":"Input"},{"location":"shards/UI/CentralPanel/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Checkbox/","text":"UI.Checkbox \u00b6 ( UI.Checkbox :Label [( String ) ( None )] :Variable [( Bool ) ( ContextVar [( Bool )]) ( None )] ) Definition \u00b6 Boolean on/off widget with text label. Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The text label of this checkbox. Variable [(Bool) (ContextVar [(Bool)]) (None)] None The variable that holds the input value. Input \u00b6 Type Description [(None)] The value is ignored. Output \u00b6 Type Description [(Bool)] Indicates whether the checkbox state changed during this frame.","title":"UI.Checkbox"},{"location":"shards/UI/Checkbox/#uicheckbox","text":"( UI.Checkbox :Label [( String ) ( None )] :Variable [( Bool ) ( ContextVar [( Bool )]) ( None )] )","title":"UI.Checkbox"},{"location":"shards/UI/Checkbox/#definition","text":"Boolean on/off widget with text label.","title":"Definition"},{"location":"shards/UI/Checkbox/#parameters","text":"Name Type Default Description Label [(String) (None)] None The text label of this checkbox. Variable [(Bool) (ContextVar [(Bool)]) (None)] None The variable that holds the input value.","title":"Parameters"},{"location":"shards/UI/Checkbox/#input","text":"Type Description [(None)] The value is ignored.","title":"Input"},{"location":"shards/UI/Checkbox/#output","text":"Type Description [(Bool)] Indicates whether the checkbox state changed during this frame.","title":"Output"},{"location":"shards/UI/CloseMenu/","text":"UI.CloseMenu \u00b6 ( UI.CloseMenu ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"UI.CloseMenu"},{"location":"shards/UI/CloseMenu/#uiclosemenu","text":"( UI.CloseMenu )","title":"UI.CloseMenu"},{"location":"shards/UI/CloseMenu/#definition","text":"","title":"Definition"},{"location":"shards/UI/CloseMenu/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/UI/CloseMenu/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/UI/Collapsing/","text":"UI.Collapsing \u00b6 ( UI.Collapsing :Heading [( String ) ( None )] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] :DefaultOpen [( Bool )] ) Definition \u00b6 A header which can be collapsed/expanded, revealing a contained UI region. Parameters \u00b6 Name Type Default Description Heading [(String) (None)] None The heading text for this collapsing header. Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. DefaultOpen [(Bool)] false Whether the collapsing header is opened by default. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the collapsing header. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Collapsing"},{"location":"shards/UI/Collapsing/#uicollapsing","text":"( UI.Collapsing :Heading [( String ) ( None )] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] :DefaultOpen [( Bool )] )","title":"UI.Collapsing"},{"location":"shards/UI/Collapsing/#definition","text":"A header which can be collapsed/expanded, revealing a contained UI region.","title":"Definition"},{"location":"shards/UI/Collapsing/#parameters","text":"Name Type Default Description Heading [(String) (None)] None The heading text for this collapsing header. Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. DefaultOpen [(Bool)] false Whether the collapsing header is opened by default.","title":"Parameters"},{"location":"shards/UI/Collapsing/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the collapsing header.","title":"Input"},{"location":"shards/UI/Collapsing/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/FloatInput/","text":"UI.FloatInput \u00b6 ( UI.FloatInput :Variable [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 A numeric input. Parameters \u00b6 Name Type Default Description Variable [(Float) (ContextVar [(Float)])] None The variable that holds the input value. Input \u00b6 Type Description [(None)] The value is ignored. Output \u00b6 Type Description [(Float)] The value produced.","title":"UI.FloatInput"},{"location":"shards/UI/FloatInput/#uifloatinput","text":"( UI.FloatInput :Variable [( Float ) ( ContextVar [( Float )])] )","title":"UI.FloatInput"},{"location":"shards/UI/FloatInput/#definition","text":"A numeric input.","title":"Definition"},{"location":"shards/UI/FloatInput/#parameters","text":"Name Type Default Description Variable [(Float) (ContextVar [(Float)])] None The variable that holds the input value.","title":"Parameters"},{"location":"shards/UI/FloatInput/#input","text":"Type Description [(None)] The value is ignored.","title":"Input"},{"location":"shards/UI/FloatInput/#output","text":"Type Description [(Float)] The value produced.","title":"Output"},{"location":"shards/UI/FloatSlider/","text":"UI.FloatSlider \u00b6 ( UI.FloatSlider :Label [( String ) ( None )] :Variable [( Float ) ( ContextVar [( Float )])] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] ) Definition \u00b6 A numeric slider. Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(Float) (ContextVar [(Float)])] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] None The minimum value. Max [(Float) (ContextVar [(Float)])] None The maximum value. Input \u00b6 Type Description [(None)] The value is ignored. Output \u00b6 Type Description [(Float)] The value produced.","title":"UI.FloatSlider"},{"location":"shards/UI/FloatSlider/#uifloatslider","text":"( UI.FloatSlider :Label [( String ) ( None )] :Variable [( Float ) ( ContextVar [( Float )])] :Min [( Float ) ( ContextVar [( Float )])] :Max [( Float ) ( ContextVar [( Float )])] )","title":"UI.FloatSlider"},{"location":"shards/UI/FloatSlider/#definition","text":"A numeric slider.","title":"Definition"},{"location":"shards/UI/FloatSlider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(Float) (ContextVar [(Float)])] None The variable that holds the input value. Min [(Float) (ContextVar [(Float)])] None The minimum value. Max [(Float) (ContextVar [(Float)])] None The maximum value.","title":"Parameters"},{"location":"shards/UI/FloatSlider/#input","text":"Type Description [(None)] The value is ignored.","title":"Input"},{"location":"shards/UI/FloatSlider/#output","text":"Type Description [(Float)] The value produced.","title":"Output"},{"location":"shards/UI/Group/","text":"UI.Group \u00b6 ( UI.Group :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Visually groups the contents together. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the group. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Group"},{"location":"shards/UI/Group/#uigroup","text":"( UI.Group :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.Group"},{"location":"shards/UI/Group/#definition","text":"Visually groups the contents together.","title":"Definition"},{"location":"shards/UI/Group/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/Group/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the group.","title":"Input"},{"location":"shards/UI/Group/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Horizontal/","text":"UI.Horizontal \u00b6 ( UI.Horizontal :Contents [( None ) ( Shard ) ( Seq [( Shard )])] :Wrap [( Bool )] ) Definition \u00b6 Layout the contents horizontally. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Wrap [(Bool)] false Wrap the content once it reaches the right edge. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the layout. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Horizontal"},{"location":"shards/UI/Horizontal/#uihorizontal","text":"( UI.Horizontal :Contents [( None ) ( Shard ) ( Seq [( Shard )])] :Wrap [( Bool )] )","title":"UI.Horizontal"},{"location":"shards/UI/Horizontal/#definition","text":"Layout the contents horizontally.","title":"Definition"},{"location":"shards/UI/Horizontal/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Wrap [(Bool)] false Wrap the content once it reaches the right edge.","title":"Parameters"},{"location":"shards/UI/Horizontal/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the layout.","title":"Input"},{"location":"shards/UI/Horizontal/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Hyperlink/","text":"UI.Hyperlink \u00b6 ( UI.Hyperlink :Label [( String ) ( None )] ) Definition \u00b6 A clickable hyperlink. Parameters \u00b6 Name Type Default Description Label [(String) (None)] None Optional label for the hyperlink Input \u00b6 Type Description [(String)] The URL. Output \u00b6 Type Description [(String)] The output of this shard will be its input.","title":"UI.Hyperlink"},{"location":"shards/UI/Hyperlink/#uihyperlink","text":"( UI.Hyperlink :Label [( String ) ( None )] )","title":"UI.Hyperlink"},{"location":"shards/UI/Hyperlink/#definition","text":"A clickable hyperlink.","title":"Definition"},{"location":"shards/UI/Hyperlink/#parameters","text":"Name Type Default Description Label [(String) (None)] None Optional label for the hyperlink","title":"Parameters"},{"location":"shards/UI/Hyperlink/#input","text":"Type Description [(String)] The URL.","title":"Input"},{"location":"shards/UI/Hyperlink/#output","text":"Type Description [(String)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/IntInput/","text":"UI.IntInput \u00b6 ( UI.IntInput :Variable [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 A numeric input. Parameters \u00b6 Name Type Default Description Variable [(Int) (ContextVar [(Int)])] None The variable that holds the input value. Input \u00b6 Type Description [(None)] The value is ignored. Output \u00b6 Type Description [(Int)] The value produced.","title":"UI.IntInput"},{"location":"shards/UI/IntInput/#uiintinput","text":"( UI.IntInput :Variable [( Int ) ( ContextVar [( Int )])] )","title":"UI.IntInput"},{"location":"shards/UI/IntInput/#definition","text":"A numeric input.","title":"Definition"},{"location":"shards/UI/IntInput/#parameters","text":"Name Type Default Description Variable [(Int) (ContextVar [(Int)])] None The variable that holds the input value.","title":"Parameters"},{"location":"shards/UI/IntInput/#input","text":"Type Description [(None)] The value is ignored.","title":"Input"},{"location":"shards/UI/IntInput/#output","text":"Type Description [(Int)] The value produced.","title":"Output"},{"location":"shards/UI/IntSlider/","text":"UI.IntSlider \u00b6 ( UI.IntSlider :Label [( String ) ( None )] :Variable [( Int ) ( ContextVar [( Int )])] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] ) Definition \u00b6 A numeric slider. Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(Int) (ContextVar [(Int)])] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] None The minimum value. Max [(Int) (ContextVar [(Int)])] None The maximum value. Input \u00b6 Type Description [(None)] The value is ignored. Output \u00b6 Type Description [(Int)] The value produced.","title":"UI.IntSlider"},{"location":"shards/UI/IntSlider/#uiintslider","text":"( UI.IntSlider :Label [( String ) ( None )] :Variable [( Int ) ( ContextVar [( Int )])] :Min [( Int ) ( ContextVar [( Int )])] :Max [( Int ) ( ContextVar [( Int )])] )","title":"UI.IntSlider"},{"location":"shards/UI/IntSlider/#definition","text":"A numeric slider.","title":"Definition"},{"location":"shards/UI/IntSlider/#parameters","text":"Name Type Default Description Label [(String) (None)] None The label for this widget. Variable [(Int) (ContextVar [(Int)])] None The variable that holds the input value. Min [(Int) (ContextVar [(Int)])] None The minimum value. Max [(Int) (ContextVar [(Int)])] None The maximum value.","title":"Parameters"},{"location":"shards/UI/IntSlider/#input","text":"Type Description [(None)] The value is ignored.","title":"Input"},{"location":"shards/UI/IntSlider/#output","text":"Type Description [(Int)] The value produced.","title":"Output"},{"location":"shards/UI/Label/","text":"UI.Label \u00b6 ( UI.Label :Wrap [( Bool ) ( None )] ) Definition \u00b6 Static text. Parameters \u00b6 Name Type Default Description Wrap [(Bool) (None)] None Wrap the text depending on the layout. Input \u00b6 Type Description [(String)] The text to display. Output \u00b6 Type Description [(String)] The output of this shard will be its input.","title":"UI.Label"},{"location":"shards/UI/Label/#uilabel","text":"( UI.Label :Wrap [( Bool ) ( None )] )","title":"UI.Label"},{"location":"shards/UI/Label/#definition","text":"Static text.","title":"Definition"},{"location":"shards/UI/Label/#parameters","text":"Name Type Default Description Wrap [(Bool) (None)] None Wrap the text depending on the layout.","title":"Parameters"},{"location":"shards/UI/Label/#input","text":"Type Description [(String)] The text to display.","title":"Input"},{"location":"shards/UI/Label/#output","text":"Type Description [(String)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/LeftPanel/","text":"UI.LeftPanel \u00b6 ( UI.LeftPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Layout UI elements into the panel. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the panel. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.LeftPanel"},{"location":"shards/UI/LeftPanel/#uileftpanel","text":"( UI.LeftPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.LeftPanel"},{"location":"shards/UI/LeftPanel/#definition","text":"Layout UI elements into the panel.","title":"Definition"},{"location":"shards/UI/LeftPanel/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/LeftPanel/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the panel.","title":"Input"},{"location":"shards/UI/LeftPanel/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Menu/","text":"UI.Menu \u00b6 ( UI.Menu :Title [( String )] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Creates a menu button that when clicked will show the given menu. If called from within a menu this will instead create a button for a sub-menu. Parameters \u00b6 Name Type Default Description Title [(String)] None The title of the menu. Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the menu. Output \u00b6 Type Description [(Bool)] A boolean value indicating whether the menu is active.","title":"UI.Menu"},{"location":"shards/UI/Menu/#uimenu","text":"( UI.Menu :Title [( String )] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.Menu"},{"location":"shards/UI/Menu/#definition","text":"Creates a menu button that when clicked will show the given menu. If called from within a menu this will instead create a button for a sub-menu.","title":"Definition"},{"location":"shards/UI/Menu/#parameters","text":"Name Type Default Description Title [(String)] None The title of the menu. Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/Menu/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the menu.","title":"Input"},{"location":"shards/UI/Menu/#output","text":"Type Description [(Bool)] A boolean value indicating whether the menu is active.","title":"Output"},{"location":"shards/UI/MenuBar/","text":"UI.MenuBar \u00b6 ( UI.MenuBar :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 The menu bar goes well in a UI.TopPanel . Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the menu bar. Output \u00b6 Type Description [(Bool)] A boolean value indicating whether the menu bar is active.","title":"UI.MenuBar"},{"location":"shards/UI/MenuBar/#uimenubar","text":"( UI.MenuBar :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.MenuBar"},{"location":"shards/UI/MenuBar/#definition","text":"The menu bar goes well in a UI.TopPanel .","title":"Definition"},{"location":"shards/UI/MenuBar/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/MenuBar/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the menu bar.","title":"Input"},{"location":"shards/UI/MenuBar/#output","text":"Type Description [(Bool)] A boolean value indicating whether the menu bar is active.","title":"Output"},{"location":"shards/UI/ProgressBar/","text":"UI.ProgressBar \u00b6 ( UI.ProgressBar :Overlay [( String ) ( None )] ) Definition \u00b6 A progress bar with an optional overlay text. Parameters \u00b6 Name Type Default Description Overlay [(String) (None)] None The text displayed inside the progress bar. Input \u00b6 Type Description [(Float)] The progress amount in the [0.0, 1.0] range, where 1 means completed. Output \u00b6 Type Description [(Float)] The output of this shard will be its input.","title":"UI.ProgressBar"},{"location":"shards/UI/ProgressBar/#uiprogressbar","text":"( UI.ProgressBar :Overlay [( String ) ( None )] )","title":"UI.ProgressBar"},{"location":"shards/UI/ProgressBar/#definition","text":"A progress bar with an optional overlay text.","title":"Definition"},{"location":"shards/UI/ProgressBar/#parameters","text":"Name Type Default Description Overlay [(String) (None)] None The text displayed inside the progress bar.","title":"Parameters"},{"location":"shards/UI/ProgressBar/#input","text":"Type Description [(Float)] The progress amount in the [0.0, 1.0] range, where 1 means completed.","title":"Input"},{"location":"shards/UI/ProgressBar/#output","text":"Type Description [(Float)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/RadioButton/","text":"UI.RadioButton \u00b6 ( UI.RadioButton :Label [( String ) ( None )] :Variable [( Any ) ( ContextVar [( Any )])] :Value [( Any )] ) Definition \u00b6 A radio button for selecting a value amongst multiple choices. Parameters \u00b6 Name Type Default Description Label [(String) (None)] None The text label of this radio button. Variable [(Any) (ContextVar [(Any)])] None The variable that holds the input value. Value [(Any)] None The value to compare with. Input \u00b6 Type Description [(None)] The value is ignored. Output \u00b6 Type Description [(Bool)] Indicates whether the radio button was clicked during this frame.","title":"UI.RadioButton"},{"location":"shards/UI/RadioButton/#uiradiobutton","text":"( UI.RadioButton :Label [( String ) ( None )] :Variable [( Any ) ( ContextVar [( Any )])] :Value [( Any )] )","title":"UI.RadioButton"},{"location":"shards/UI/RadioButton/#definition","text":"A radio button for selecting a value amongst multiple choices.","title":"Definition"},{"location":"shards/UI/RadioButton/#parameters","text":"Name Type Default Description Label [(String) (None)] None The text label of this radio button. Variable [(Any) (ContextVar [(Any)])] None The variable that holds the input value. Value [(Any)] None The value to compare with.","title":"Parameters"},{"location":"shards/UI/RadioButton/#input","text":"Type Description [(None)] The value is ignored.","title":"Input"},{"location":"shards/UI/RadioButton/#output","text":"Type Description [(Bool)] Indicates whether the radio button was clicked during this frame.","title":"Output"},{"location":"shards/UI/Reset/","text":"UI.Reset \u00b6 ( UI.Reset ) Definition \u00b6 Input \u00b6 Type Description [(Any)] Output \u00b6 Type Description [(Any)]","title":"UI.Reset"},{"location":"shards/UI/Reset/#uireset","text":"( UI.Reset )","title":"UI.Reset"},{"location":"shards/UI/Reset/#definition","text":"","title":"Definition"},{"location":"shards/UI/Reset/#input","text":"Type Description [(Any)]","title":"Input"},{"location":"shards/UI/Reset/#output","text":"Type Description [(Any)]","title":"Output"},{"location":"shards/UI/RightPanel/","text":"UI.RightPanel \u00b6 ( UI.RightPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Layout UI elements into the panel. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the panel. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.RightPanel"},{"location":"shards/UI/RightPanel/#uirightpanel","text":"( UI.RightPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.RightPanel"},{"location":"shards/UI/RightPanel/#definition","text":"Layout UI elements into the panel.","title":"Definition"},{"location":"shards/UI/RightPanel/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/RightPanel/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the panel.","title":"Input"},{"location":"shards/UI/RightPanel/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Scope/","text":"UI.Scope \u00b6 ( UI.Scope :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Creates a scoped child UI. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the scope. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Scope"},{"location":"shards/UI/Scope/#uiscope","text":"( UI.Scope :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.Scope"},{"location":"shards/UI/Scope/#definition","text":"Creates a scoped child UI.","title":"Definition"},{"location":"shards/UI/Scope/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/Scope/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the scope.","title":"Input"},{"location":"shards/UI/Scope/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/ScrollArea/","text":"UI.ScrollArea \u00b6 ( UI.ScrollArea :Contents [( None ) ( Shard ) ( Seq [( Shard )])] :Horizontal [( Bool )] :Vertical [( Bool )] :AlwaysShow [( Bool )] ) Definition \u00b6 Add vertical and/or horizontal scrolling to a contained UI. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Horizontal [(Bool)] false Enable horizontal scrolling. Vertical [(Bool)] true Enable vertical scrolling. AlwaysShow [(Bool)] false Always show the enabled scroll bars even if not needed. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the scroll area. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.ScrollArea"},{"location":"shards/UI/ScrollArea/#uiscrollarea","text":"( UI.ScrollArea :Contents [( None ) ( Shard ) ( Seq [( Shard )])] :Horizontal [( Bool )] :Vertical [( Bool )] :AlwaysShow [( Bool )] )","title":"UI.ScrollArea"},{"location":"shards/UI/ScrollArea/#definition","text":"Add vertical and/or horizontal scrolling to a contained UI.","title":"Definition"},{"location":"shards/UI/ScrollArea/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Horizontal [(Bool)] false Enable horizontal scrolling. Vertical [(Bool)] true Enable vertical scrolling. AlwaysShow [(Bool)] false Always show the enabled scroll bars even if not needed.","title":"Parameters"},{"location":"shards/UI/ScrollArea/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the scroll area.","title":"Input"},{"location":"shards/UI/ScrollArea/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Separator/","text":"UI.Separator \u00b6 ( UI.Separator ) Definition \u00b6 A visual separator. A horizontal or vertical line (depending on the layout). Input \u00b6 Type Description [(Any)] The value is ignored. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Separator"},{"location":"shards/UI/Separator/#uiseparator","text":"( UI.Separator )","title":"UI.Separator"},{"location":"shards/UI/Separator/#definition","text":"A visual separator. A horizontal or vertical line (depending on the layout).","title":"Definition"},{"location":"shards/UI/Separator/#input","text":"Type Description [(Any)] The value is ignored.","title":"Input"},{"location":"shards/UI/Separator/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Spinner/","text":"UI.Spinner \u00b6 ( UI.Spinner ) Definition \u00b6 A spinner widget used to indicate loading. Input \u00b6 Type Description [(Any)] The value is ignored. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Spinner"},{"location":"shards/UI/Spinner/#uispinner","text":"( UI.Spinner )","title":"UI.Spinner"},{"location":"shards/UI/Spinner/#definition","text":"A spinner widget used to indicate loading.","title":"Definition"},{"location":"shards/UI/Spinner/#input","text":"Type Description [(Any)] The value is ignored.","title":"Input"},{"location":"shards/UI/Spinner/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/TextInput/","text":"UI.TextInput \u00b6 ( UI.TextInput :Variable [( String ) ( ContextVar [( String )])] :Multiline [( Bool )] ) Definition \u00b6 A widget where text can be entered. Parameters \u00b6 Name Type Default Description Variable [(String) (ContextVar [(String)])] None The variable that holds the input value. Multiline [(Bool)] false Support multiple lines. Input \u00b6 Type Description [(None)] The value is ignored. Output \u00b6 Type Description [(String)] The value produced when changed.","title":"UI.TextInput"},{"location":"shards/UI/TextInput/#uitextinput","text":"( UI.TextInput :Variable [( String ) ( ContextVar [( String )])] :Multiline [( Bool )] )","title":"UI.TextInput"},{"location":"shards/UI/TextInput/#definition","text":"A widget where text can be entered.","title":"Definition"},{"location":"shards/UI/TextInput/#parameters","text":"Name Type Default Description Variable [(String) (ContextVar [(String)])] None The variable that holds the input value. Multiline [(Bool)] false Support multiple lines.","title":"Parameters"},{"location":"shards/UI/TextInput/#input","text":"Type Description [(None)] The value is ignored.","title":"Input"},{"location":"shards/UI/TextInput/#output","text":"Type Description [(String)] The value produced when changed.","title":"Output"},{"location":"shards/UI/TopPanel/","text":"UI.TopPanel \u00b6 ( UI.TopPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Layout UI elements into the panel. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the panel. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.TopPanel"},{"location":"shards/UI/TopPanel/#uitoppanel","text":"( UI.TopPanel :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.TopPanel"},{"location":"shards/UI/TopPanel/#definition","text":"Layout UI elements into the panel.","title":"Definition"},{"location":"shards/UI/TopPanel/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/TopPanel/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the panel.","title":"Input"},{"location":"shards/UI/TopPanel/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Vertical/","text":"UI.Vertical \u00b6 ( UI.Vertical :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Layout the contents vertically. Parameters \u00b6 Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the layout. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Vertical"},{"location":"shards/UI/Vertical/#uivertical","text":"( UI.Vertical :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.Vertical"},{"location":"shards/UI/Vertical/#definition","text":"Layout the contents vertically.","title":"Definition"},{"location":"shards/UI/Vertical/#parameters","text":"Name Type Default Description Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/Vertical/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the layout.","title":"Input"},{"location":"shards/UI/Vertical/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/UI/Window/","text":"UI.Window \u00b6 ( UI.Window :Title [( String )] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] ) Definition \u00b6 Creates a floating window which can be dragged, closed, collapsed, resized. Parameters \u00b6 Name Type Default Description Title [(String)] \"My Window\" The window title displayed on the titlebar. Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents. Input \u00b6 Type Description [(Any)] The value that will be passed to the Contents shards of the rendered window. Output \u00b6 Type Description [(Any)] The output of this shard will be its input.","title":"UI.Window"},{"location":"shards/UI/Window/#uiwindow","text":"( UI.Window :Title [( String )] :Contents [( None ) ( Shard ) ( Seq [( Shard )])] )","title":"UI.Window"},{"location":"shards/UI/Window/#definition","text":"Creates a floating window which can be dragged, closed, collapsed, resized.","title":"Definition"},{"location":"shards/UI/Window/#parameters","text":"Name Type Default Description Title [(String)] \"My Window\" The window title displayed on the titlebar. Contents [(None) (Shard) (Seq [(Shard)])] None The UI contents.","title":"Parameters"},{"location":"shards/UI/Window/#input","text":"Type Description [(Any)] The value that will be passed to the Contents shards of the rendered window.","title":"Input"},{"location":"shards/UI/Window/#output","text":"Type Description [(Any)] The output of this shard will be its input.","title":"Output"},{"location":"shards/WS/Client/","text":"WS.Client \u00b6 ( WS.Client :Host [( String ) ( ContextVar [( String )])] :Target [( String ) ( ContextVar [( String )])] :Port [( Int ) ( ContextVar [( Int )])] :Secure [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Host [(String) (ContextVar [(String)])] \"echo.websocket.org\" The remote host address or IP. Target [(String) (ContextVar [(String)])] \"/\" The remote host target path. Port [(Int) (ContextVar [(Int)])] 443 The remote host port. Secure [(Bool)] true If the connection should be secured. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Object)]","title":"WS.Client"},{"location":"shards/WS/Client/#wsclient","text":"( WS.Client :Host [( String ) ( ContextVar [( String )])] :Target [( String ) ( ContextVar [( String )])] :Port [( Int ) ( ContextVar [( Int )])] :Secure [( Bool )] )","title":"WS.Client"},{"location":"shards/WS/Client/#definition","text":"","title":"Definition"},{"location":"shards/WS/Client/#parameters","text":"Name Type Default Description Host [(String) (ContextVar [(String)])] \"echo.websocket.org\" The remote host address or IP. Target [(String) (ContextVar [(String)])] \"/\" The remote host target path. Port [(Int) (ContextVar [(Int)])] 443 The remote host port. Secure [(Bool)] true If the connection should be secured.","title":"Parameters"},{"location":"shards/WS/Client/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/WS/Client/#output","text":"Type Description [(Object)]","title":"Output"},{"location":"shards/WS/ReadString/","text":"WS.ReadString \u00b6 ( WS.ReadString :Socket [( ContextVar [( Object )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Socket [(ContextVar [(Object)])] None The websocket instance variable. Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(String)]","title":"WS.ReadString"},{"location":"shards/WS/ReadString/#wsreadstring","text":"( WS.ReadString :Socket [( ContextVar [( Object )])] )","title":"WS.ReadString"},{"location":"shards/WS/ReadString/#definition","text":"","title":"Definition"},{"location":"shards/WS/ReadString/#parameters","text":"Name Type Default Description Socket [(ContextVar [(Object)])] None The websocket instance variable.","title":"Parameters"},{"location":"shards/WS/ReadString/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/WS/ReadString/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/WS/WriteString/","text":"WS.WriteString \u00b6 ( WS.WriteString :Socket [( ContextVar [( Object )])] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Socket [(ContextVar [(Object)])] None The websocket instance variable. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"WS.WriteString"},{"location":"shards/WS/WriteString/#wswritestring","text":"( WS.WriteString :Socket [( ContextVar [( Object )])] )","title":"WS.WriteString"},{"location":"shards/WS/WriteString/#definition","text":"","title":"Definition"},{"location":"shards/WS/WriteString/#parameters","text":"Name Type Default Description Socket [(ContextVar [(Object)])] None The websocket instance variable.","title":"Parameters"},{"location":"shards/WS/WriteString/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/WS/WriteString/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Wasm/Run/","text":"Wasm.Run \u00b6 ( Wasm.Run :Module [( Path ) ( String )] :Arguments [( None ) ( Seq [( String )]) ( ContextVar [( Seq [( String )])])] :EntryPoint [( String )] :StackSize [( Int )] :ResetRuntime [( Bool )] :CallConstructors [( Bool )] ) Definition \u00b6 Parameters \u00b6 Name Type Default Description Module [(Path) (String)] \"\" The wasm module to run. Arguments [(None) (Seq [(String)]) (ContextVar [(Seq [(String)])])] None The arguments to pass to the module entrypoint function. EntryPoint [(String)] \"_start\" The entry point function to call when activating. StackSize [(Int)] 1024 The stack size in kilobytes to use. ResetRuntime [(Bool)] true If the runtime should be reset every activation, altho slow this might be useful if certain modules fail to execute properly or leak on multiple activations. CallConstructors [(Bool)] false Use if it might be necessary to force a call to __wasm_call_dtors , modules generated with WASI rust might need this. Input \u00b6 Type Description [(String)] Output \u00b6 Type Description [(String)]","title":"Wasm.Run"},{"location":"shards/Wasm/Run/#wasmrun","text":"( Wasm.Run :Module [( Path ) ( String )] :Arguments [( None ) ( Seq [( String )]) ( ContextVar [( Seq [( String )])])] :EntryPoint [( String )] :StackSize [( Int )] :ResetRuntime [( Bool )] :CallConstructors [( Bool )] )","title":"Wasm.Run"},{"location":"shards/Wasm/Run/#definition","text":"","title":"Definition"},{"location":"shards/Wasm/Run/#parameters","text":"Name Type Default Description Module [(Path) (String)] \"\" The wasm module to run. Arguments [(None) (Seq [(String)]) (ContextVar [(Seq [(String)])])] None The arguments to pass to the module entrypoint function. EntryPoint [(String)] \"_start\" The entry point function to call when activating. StackSize [(Int)] 1024 The stack size in kilobytes to use. ResetRuntime [(Bool)] true If the runtime should be reset every activation, altho slow this might be useful if certain modules fail to execute properly or leak on multiple activations. CallConstructors [(Bool)] false Use if it might be necessary to force a call to __wasm_call_dtors , modules generated with WASI rust might need this.","title":"Parameters"},{"location":"shards/Wasm/Run/#input","text":"Type Description [(String)]","title":"Input"},{"location":"shards/Wasm/Run/#output","text":"Type Description [(String)]","title":"Output"},{"location":"shards/Window/Size/","text":"Window.Size \u00b6 ( Window.Size ) Definition \u00b6 Input \u00b6 Type Description [(None)] Output \u00b6 Type Description [(Int2)]","title":"Window.Size"},{"location":"shards/Window/Size/#windowsize","text":"( Window.Size )","title":"Window.Size"},{"location":"shards/Window/Size/#definition","text":"","title":"Definition"},{"location":"shards/Window/Size/#input","text":"Type Description [(None)]","title":"Input"},{"location":"shards/Window/Size/#output","text":"Type Description [(Int2)]","title":"Output"}]}