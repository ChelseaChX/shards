/* automatically generated by rust-bindgen 0.59.2 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __MINGW64_VERSION_MAJOR: u32 = 10;
pub const __MINGW64_VERSION_MINOR: u32 = 0;
pub const __MINGW64_VERSION_BUGFIX: u32 = 0;
pub const __MINGW64_VERSION_RC: u32 = 0;
pub const __MINGW64_VERSION_STATE: &[u8; 6usize] = b"alpha\0";
pub const __MINGW32_MAJOR_VERSION: u32 = 3;
pub const __MINGW32_MINOR_VERSION: u32 = 11;
pub const _M_IX86: u32 = 300;
pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
pub const __MINGW_SEC_WARN_STR: &[u8; 92usize] =
  b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0";
pub const __MINGW_MSVC2005_DEPREC_STR : & [u8 ; 117usize] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
pub const __MINGW_FORTIFY_LEVEL: u32 = 0;
pub const __MINGW_FORTIFY_VA_ARG: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const __USE_CRTIMP: u32 = 1;
pub const USE___UUIDOF: u32 = 0;
pub const __CRT__NO_INLINE: u32 = 1;
pub const __MSVCRT_VERSION__: u32 = 1792;
pub const _WIN32_WINNT: u32 = 1537;
pub const MINGW_HAS_SECURE_API: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const MINGW_HAS_DDK_H: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
pub const _ARGMAX: u32 = 100;
pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const SHIMAGE_FLAGS_NONE: u32 = 0;
pub const SHIMAGE_FLAGS_BGRA: u32 = 1;
pub const SHIMAGE_FLAGS_PREMULTIPLIED_ALPHA: u32 = 2;
pub const SHIMAGE_FLAGS_16BITS_INT: u32 = 4;
pub const SHIMAGE_FLAGS_32BITS_FLOAT: u32 = 8;
pub const SHVAR_FLAGS_NONE: u32 = 0;
pub const SHVAR_FLAGS_USES_OBJINFO: u32 = 1;
pub const SHVAR_FLAGS_REF_COUNTED: u32 = 2;
pub const SHVAR_FLAGS_EXTERNAL: u32 = 4;
pub const SHARDS_CURRENT_ABI: u32 = 538968321;
pub const SHARDS_CURRENT_ABI_STR: &[u8; 11usize] = b"0x20200101\0";
pub const SH_DEBUG_MODE: u32 = 1;
pub type size_t = ::std::os::raw::c_uint;
pub type wchar_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
  pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
  pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
  assert_eq!(
    ::core::mem::size_of::<max_align_t>(),
    24usize,
    concat!("Size of: ", stringify!(max_align_t))
  );
  assert_eq!(
    ::core::mem::align_of::<max_align_t>(),
    8usize,
    concat!("Alignment of ", stringify!(max_align_t))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__clang_max_align_nonce1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__clang_max_align_nonce2)
    )
  );
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
extern "C" {
  pub fn __debugbreak();
}
extern "C" {
  pub fn __mingw_get_crt_info() -> *const ::std::os::raw::c_char;
}
pub type ssize_t = ::std::os::raw::c_int;
pub type rsize_t = size_t;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct {
  _unused: [u8; 0],
}
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct localeinfo_struct {
  pub locinfo: pthreadlocinfo,
  pub mbcinfo: pthreadmbcinfo,
}
#[test]
fn bindgen_test_layout_localeinfo_struct() {
  assert_eq!(
    ::core::mem::size_of::<localeinfo_struct>(),
    8usize,
    concat!("Size of: ", stringify!(localeinfo_struct))
  );
  assert_eq!(
    ::core::mem::align_of::<localeinfo_struct>(),
    4usize,
    concat!("Alignment of ", stringify!(localeinfo_struct))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<localeinfo_struct>())).locinfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(localeinfo_struct),
      "::",
      stringify!(locinfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<localeinfo_struct>())).mbcinfo as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(localeinfo_struct),
      "::",
      stringify!(mbcinfo)
    )
  );
}
impl Default for localeinfo_struct {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagLC_ID {
  pub wLanguage: ::std::os::raw::c_ushort,
  pub wCountry: ::std::os::raw::c_ushort,
  pub wCodePage: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tagLC_ID() {
  assert_eq!(
    ::core::mem::size_of::<tagLC_ID>(),
    6usize,
    concat!("Size of: ", stringify!(tagLC_ID))
  );
  assert_eq!(
    ::core::mem::align_of::<tagLC_ID>(),
    2usize,
    concat!("Alignment of ", stringify!(tagLC_ID))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLC_ID>())).wLanguage as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLC_ID),
      "::",
      stringify!(wLanguage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLC_ID>())).wCountry as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLC_ID),
      "::",
      stringify!(wCountry)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<tagLC_ID>())).wCodePage as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagLC_ID),
      "::",
      stringify!(wCodePage)
    )
  );
}
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct {
  pub refcount: ::std::os::raw::c_int,
  pub lc_codepage: ::std::os::raw::c_uint,
  pub lc_collate_cp: ::std::os::raw::c_uint,
  pub lc_handle: [::std::os::raw::c_ulong; 6usize],
  pub lc_id: [LC_ID; 6usize],
  pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
  pub lc_clike: ::std::os::raw::c_int,
  pub mb_cur_max: ::std::os::raw::c_int,
  pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
  pub lconv_num_refcount: *mut ::std::os::raw::c_int,
  pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
  pub lconv: *mut lconv,
  pub ctype1_refcount: *mut ::std::os::raw::c_int,
  pub ctype1: *mut ::std::os::raw::c_ushort,
  pub pctype: *const ::std::os::raw::c_ushort,
  pub pclmap: *const ::std::os::raw::c_uchar,
  pub pcumap: *const ::std::os::raw::c_uchar,
  pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
  pub locale: *mut ::std::os::raw::c_char,
  pub wlocale: *mut wchar_t,
  pub refcount: *mut ::std::os::raw::c_int,
  pub wrefcount: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<threadlocaleinfostruct__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(threadlocaleinfostruct__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<threadlocaleinfostruct__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(threadlocaleinfostruct__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).locale as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct__bindgen_ty_1),
      "::",
      stringify!(locale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).wlocale as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct__bindgen_ty_1),
      "::",
      stringify!(wlocale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).refcount as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct__bindgen_ty_1),
      "::",
      stringify!(refcount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).wrefcount as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct__bindgen_ty_1),
      "::",
      stringify!(wrefcount)
    )
  );
}
impl Default for threadlocaleinfostruct__bindgen_ty_1 {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct() {
  assert_eq!(
    ::core::mem::size_of::<threadlocaleinfostruct>(),
    216usize,
    concat!("Size of: ", stringify!(threadlocaleinfostruct))
  );
  assert_eq!(
    ::core::mem::align_of::<threadlocaleinfostruct>(),
    4usize,
    concat!("Alignment of ", stringify!(threadlocaleinfostruct))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).refcount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(refcount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).lc_codepage as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lc_codepage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct>())).lc_collate_cp as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lc_collate_cp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).lc_handle as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lc_handle)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).lc_id as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lc_id)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).lc_category as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lc_category)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).lc_clike as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lc_clike)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).mb_cur_max as *const _ as usize },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(mb_cur_max)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct>())).lconv_intl_refcount as *const _ as usize
    },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lconv_intl_refcount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct>())).lconv_num_refcount as *const _ as usize
    },
    180usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lconv_num_refcount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct>())).lconv_mon_refcount as *const _ as usize
    },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lconv_mon_refcount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).lconv as *const _ as usize },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lconv)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct>())).ctype1_refcount as *const _ as usize
    },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(ctype1_refcount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).ctype1 as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(ctype1)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).pctype as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(pctype)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).pclmap as *const _ as usize },
    204usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(pclmap)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<threadlocaleinfostruct>())).pcumap as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(pcumap)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<threadlocaleinfostruct>())).lc_time_curr as *const _ as usize
    },
    212usize,
    concat!(
      "Offset of field: ",
      stringify!(threadlocaleinfostruct),
      "::",
      stringify!(lc_time_curr)
    )
  );
}
impl Default for threadlocaleinfostruct {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type threadlocinfo = threadlocaleinfostruct;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type int_least32_t = ::std::os::raw::c_int;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub const SHType_None: SHType = 0;
pub const SHType_Any: SHType = 1;
pub const SHType_Enum: SHType = 2;
pub const SHType_Bool: SHType = 3;
pub const SHType_Int: SHType = 4;
pub const SHType_Int2: SHType = 5;
pub const SHType_Int3: SHType = 6;
pub const SHType_Int4: SHType = 7;
pub const SHType_Int8: SHType = 8;
pub const SHType_Int16: SHType = 9;
pub const SHType_Float: SHType = 10;
pub const SHType_Float2: SHType = 11;
pub const SHType_Float3: SHType = 12;
pub const SHType_Float4: SHType = 13;
pub const SHType_Color: SHType = 14;
pub const SHType_ShardRef: SHType = 15;
pub const SHType_EndOfBlittableTypes: SHType = 50;
pub const SHType_Bytes: SHType = 51;
pub const SHType_String: SHType = 52;
pub const SHType_Path: SHType = 53;
pub const SHType_ContextVar: SHType = 54;
pub const SHType_Image: SHType = 55;
pub const SHType_Seq: SHType = 56;
pub const SHType_Table: SHType = 57;
pub const SHType_Wire: SHType = 58;
pub const SHType_Object: SHType = 59;
pub const SHType_Array: SHType = 60;
pub const SHType_Set: SHType = 61;
pub const SHType_Audio: SHType = 62;
pub type SHType = u8;
pub const SHWireState_Continue: SHWireState = 0;
pub const SHWireState_Return: SHWireState = 1;
pub const SHWireState_Rebase: SHWireState = 2;
pub const SHWireState_Restart: SHWireState = 3;
pub const SHWireState_Stop: SHWireState = 4;
pub type SHWireState = u8;
pub const SHInlineShards_NotInline: SHInlineShards = 0;
pub const SHInlineShards_NoopShard: SHInlineShards = 1;
pub const SHInlineShards_CoreConst: SHInlineShards = 2;
pub const SHInlineShards_CoreSleep: SHInlineShards = 3;
pub const SHInlineShards_CoreInput: SHInlineShards = 4;
pub const SHInlineShards_CoreForRange: SHInlineShards = 5;
pub const SHInlineShards_CoreRepeat: SHInlineShards = 6;
pub const SHInlineShards_CoreOnce: SHInlineShards = 7;
pub const SHInlineShards_CoreGet: SHInlineShards = 8;
pub const SHInlineShards_CoreSet: SHInlineShards = 9;
pub const SHInlineShards_CoreRefRegular: SHInlineShards = 10;
pub const SHInlineShards_CoreRefTable: SHInlineShards = 11;
pub const SHInlineShards_CoreUpdate: SHInlineShards = 12;
pub const SHInlineShards_CoreSwap: SHInlineShards = 13;
pub const SHInlineShards_CorePush: SHInlineShards = 14;
pub const SHInlineShards_CoreIs: SHInlineShards = 15;
pub const SHInlineShards_CoreIsNot: SHInlineShards = 16;
pub const SHInlineShards_CoreAnd: SHInlineShards = 17;
pub const SHInlineShards_CoreOr: SHInlineShards = 18;
pub const SHInlineShards_CoreNot: SHInlineShards = 19;
pub const SHInlineShards_CoreIsMore: SHInlineShards = 20;
pub const SHInlineShards_CoreIsLess: SHInlineShards = 21;
pub const SHInlineShards_CoreIsMoreEqual: SHInlineShards = 22;
pub const SHInlineShards_CoreIsLessEqual: SHInlineShards = 23;
pub const SHInlineShards_MathAdd: SHInlineShards = 24;
pub const SHInlineShards_MathSubtract: SHInlineShards = 25;
pub const SHInlineShards_MathMultiply: SHInlineShards = 26;
pub const SHInlineShards_MathDivide: SHInlineShards = 27;
pub const SHInlineShards_MathXor: SHInlineShards = 28;
pub const SHInlineShards_MathAnd: SHInlineShards = 29;
pub const SHInlineShards_MathOr: SHInlineShards = 30;
pub const SHInlineShards_MathMod: SHInlineShards = 31;
pub const SHInlineShards_MathLShift: SHInlineShards = 32;
pub const SHInlineShards_MathRShift: SHInlineShards = 33;
pub const SHInlineShards_MathAbs: SHInlineShards = 34;
pub const SHInlineShards_MathExp: SHInlineShards = 35;
pub const SHInlineShards_MathExp2: SHInlineShards = 36;
pub const SHInlineShards_MathExpm1: SHInlineShards = 37;
pub const SHInlineShards_MathLog: SHInlineShards = 38;
pub const SHInlineShards_MathLog10: SHInlineShards = 39;
pub const SHInlineShards_MathLog2: SHInlineShards = 40;
pub const SHInlineShards_MathLog1p: SHInlineShards = 41;
pub const SHInlineShards_MathSqrt: SHInlineShards = 42;
pub const SHInlineShards_MathFastSqrt: SHInlineShards = 43;
pub const SHInlineShards_MathFastInvSqrt: SHInlineShards = 44;
pub const SHInlineShards_MathCbrt: SHInlineShards = 45;
pub const SHInlineShards_MathSin: SHInlineShards = 46;
pub const SHInlineShards_MathCos: SHInlineShards = 47;
pub const SHInlineShards_MathTan: SHInlineShards = 48;
pub const SHInlineShards_MathAsin: SHInlineShards = 49;
pub const SHInlineShards_MathAcos: SHInlineShards = 50;
pub const SHInlineShards_MathAtan: SHInlineShards = 51;
pub const SHInlineShards_MathSinh: SHInlineShards = 52;
pub const SHInlineShards_MathCosh: SHInlineShards = 53;
pub const SHInlineShards_MathTanh: SHInlineShards = 54;
pub const SHInlineShards_MathAsinh: SHInlineShards = 55;
pub const SHInlineShards_MathAcosh: SHInlineShards = 56;
pub const SHInlineShards_MathAtanh: SHInlineShards = 57;
pub const SHInlineShards_MathErf: SHInlineShards = 58;
pub const SHInlineShards_MathErfc: SHInlineShards = 59;
pub const SHInlineShards_MathTGamma: SHInlineShards = 60;
pub const SHInlineShards_MathLGamma: SHInlineShards = 61;
pub const SHInlineShards_MathCeil: SHInlineShards = 62;
pub const SHInlineShards_MathFloor: SHInlineShards = 63;
pub const SHInlineShards_MathTrunc: SHInlineShards = 64;
pub const SHInlineShards_MathRound: SHInlineShards = 65;
pub type SHInlineShards = u32;
pub type SHArray = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHPayloadArray {
  pub elements: *mut SHVarPayload,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_SHPayloadArray() {
  assert_eq!(
    ::core::mem::size_of::<SHPayloadArray>(),
    12usize,
    concat!("Size of: ", stringify!(SHPayloadArray))
  );
  assert_eq!(
    ::core::mem::align_of::<SHPayloadArray>(),
    4usize,
    concat!("Alignment of ", stringify!(SHPayloadArray))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHPayloadArray>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHPayloadArray),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHPayloadArray>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHPayloadArray),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHPayloadArray>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHPayloadArray),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for SHPayloadArray {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHSeq {
  pub elements: *mut SHVar,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_SHSeq() {
  assert_eq!(
    ::core::mem::size_of::<SHSeq>(),
    12usize,
    concat!("Size of: ", stringify!(SHSeq))
  );
  assert_eq!(
    ::core::mem::align_of::<SHSeq>(),
    4usize,
    concat!("Alignment of ", stringify!(SHSeq))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSeq>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSeq),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSeq>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSeq),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSeq>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSeq),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for SHSeq {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHTableIterator = [::std::os::raw::c_char; 64usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHTable {
  pub opaque: *mut ::core::ffi::c_void,
  pub api: *mut SHTableInterface,
}
#[test]
fn bindgen_test_layout_SHTable() {
  assert_eq!(
    ::core::mem::size_of::<SHTable>(),
    8usize,
    concat!("Size of: ", stringify!(SHTable))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTable>(),
    4usize,
    concat!("Alignment of ", stringify!(SHTable))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTable>())).opaque as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTable),
      "::",
      stringify!(opaque)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTable>())).api as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTable),
      "::",
      stringify!(api)
    )
  );
}
impl Default for SHTable {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHSetIterator = [::std::os::raw::c_char; 64usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHSetnterface {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHSet {
  pub opaque: *mut ::core::ffi::c_void,
  pub api: *mut SHSetInterface,
}
#[test]
fn bindgen_test_layout_SHSet() {
  assert_eq!(
    ::core::mem::size_of::<SHSet>(),
    8usize,
    concat!("Size of: ", stringify!(SHSet))
  );
  assert_eq!(
    ::core::mem::align_of::<SHSet>(),
    4usize,
    concat!("Alignment of ", stringify!(SHSet))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSet>())).opaque as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSet),
      "::",
      stringify!(opaque)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSet>())).api as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSet),
      "::",
      stringify!(api)
    )
  );
}
impl Default for SHSet {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHWire {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHWireRefOpaque {
  _unused: [u8; 0],
}
pub type SHWireRef = *mut SHWireRefOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHContext {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHMesh {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHMeshRefOpaque {
  _unused: [u8; 0],
}
pub type SHMeshRef = *mut SHMeshRefOpaque;
pub type ShardPtr = *mut Shard;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shards {
  pub elements: *mut ShardPtr,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_Shards() {
  assert_eq!(
    ::core::mem::size_of::<Shards>(),
    12usize,
    concat!("Size of: ", stringify!(Shards))
  );
  assert_eq!(
    ::core::mem::align_of::<Shards>(),
    4usize,
    concat!("Alignment of ", stringify!(Shards))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shards>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(Shards),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shards>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(Shards),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shards>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(Shards),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for Shards {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHTypesInfo {
  pub elements: *mut SHTypeInfo,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_SHTypesInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHTypesInfo>(),
    12usize,
    concat!("Size of: ", stringify!(SHTypesInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypesInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SHTypesInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypesInfo>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypesInfo),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypesInfo>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypesInfo),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypesInfo>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypesInfo),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for SHTypesInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHParametersInfo {
  pub elements: *mut SHParameterInfo,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_SHParametersInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHParametersInfo>(),
    12usize,
    concat!("Size of: ", stringify!(SHParametersInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHParametersInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SHParametersInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHParametersInfo>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHParametersInfo),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHParametersInfo>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHParametersInfo),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHParametersInfo>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHParametersInfo),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for SHParametersInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHExposedTypesInfo {
  pub elements: *mut SHExposedTypeInfo,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_SHExposedTypesInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHExposedTypesInfo>(),
    12usize,
    concat!("Size of: ", stringify!(SHExposedTypesInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHExposedTypesInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SHExposedTypesInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypesInfo>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypesInfo),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypesInfo>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypesInfo),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypesInfo>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypesInfo),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for SHExposedTypesInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHPointer = *mut ::core::ffi::c_void;
pub type SHInt = i64;
pub type SHFloat = f64;
pub type SHBool = bool;
pub type SHEnum = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHEnums {
  pub elements: *mut SHEnum,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_SHEnums() {
  assert_eq!(
    ::core::mem::size_of::<SHEnums>(),
    12usize,
    concat!("Size of: ", stringify!(SHEnums))
  );
  assert_eq!(
    ::core::mem::align_of::<SHEnums>(),
    4usize,
    concat!("Alignment of ", stringify!(SHEnums))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHEnums>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHEnums),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHEnums>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHEnums),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHEnums>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHEnums),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for SHEnums {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHString = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHStrings {
  pub elements: *mut SHString,
  pub len: u32,
  pub cap: u32,
}
#[test]
fn bindgen_test_layout_SHStrings() {
  assert_eq!(
    ::core::mem::size_of::<SHStrings>(),
    12usize,
    concat!("Size of: ", stringify!(SHStrings))
  );
  assert_eq!(
    ::core::mem::align_of::<SHStrings>(),
    4usize,
    concat!("Alignment of ", stringify!(SHStrings))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHStrings>())).elements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHStrings),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHStrings>())).len as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHStrings),
      "::",
      stringify!(len)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHStrings>())).cap as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHStrings),
      "::",
      stringify!(cap)
    )
  );
}
impl Default for SHStrings {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHOptionalString {
  pub string: SHString,
  pub crc: u32,
}
#[test]
fn bindgen_test_layout__SHOptionalString() {
  assert_eq!(
    ::core::mem::size_of::<_SHOptionalString>(),
    8usize,
    concat!("Size of: ", stringify!(_SHOptionalString))
  );
  assert_eq!(
    ::core::mem::align_of::<_SHOptionalString>(),
    4usize,
    concat!("Alignment of ", stringify!(_SHOptionalString))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHOptionalString>())).string as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHOptionalString),
      "::",
      stringify!(string)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHOptionalString>())).crc as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHOptionalString),
      "::",
      stringify!(crc)
    )
  );
}
impl Default for _SHOptionalString {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHOptionalString = _SHOptionalString;
pub type SHInt2 = [i64; 2usize];
pub type SHInt3 = [i32; 4usize];
pub type SHInt4 = [i32; 4usize];
pub type SHInt8 = [i16; 8usize];
pub type SHInt16 = [i8; 16usize];
pub type SHFloat2 = [f64; 2usize];
pub type SHFloat3 = [f32; 4usize];
pub type SHFloat4 = [f32; 4usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHColor {
  pub r: u8,
  pub g: u8,
  pub b: u8,
  pub a: u8,
}
#[test]
fn bindgen_test_layout_SHColor() {
  assert_eq!(
    ::core::mem::size_of::<SHColor>(),
    4usize,
    concat!("Size of: ", stringify!(SHColor))
  );
  assert_eq!(
    ::core::mem::align_of::<SHColor>(),
    1usize,
    concat!("Alignment of ", stringify!(SHColor))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHColor>())).r as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHColor),
      "::",
      stringify!(r)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHColor>())).g as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SHColor),
      "::",
      stringify!(g)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHColor>())).b as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SHColor),
      "::",
      stringify!(b)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHColor>())).a as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SHColor),
      "::",
      stringify!(a)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHImage {
  pub width: u16,
  pub height: u16,
  pub channels: u8,
  pub flags: u8,
  pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_SHImage() {
  assert_eq!(
    ::core::mem::size_of::<SHImage>(),
    12usize,
    concat!("Size of: ", stringify!(SHImage))
  );
  assert_eq!(
    ::core::mem::align_of::<SHImage>(),
    4usize,
    concat!("Alignment of ", stringify!(SHImage))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHImage>())).width as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHImage),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHImage>())).height as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SHImage),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHImage>())).channels as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHImage),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHImage>())).flags as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(SHImage),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHImage>())).data as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHImage),
      "::",
      stringify!(data)
    )
  );
}
impl Default for SHImage {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHAudio {
  pub sampleRate: u32,
  pub nsamples: u16,
  pub channels: u16,
  pub samples: *mut f32,
}
#[test]
fn bindgen_test_layout_SHAudio() {
  assert_eq!(
    ::core::mem::size_of::<SHAudio>(),
    12usize,
    concat!("Size of: ", stringify!(SHAudio))
  );
  assert_eq!(
    ::core::mem::align_of::<SHAudio>(),
    4usize,
    concat!("Alignment of ", stringify!(SHAudio))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHAudio>())).sampleRate as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHAudio),
      "::",
      stringify!(sampleRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHAudio>())).nsamples as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHAudio),
      "::",
      stringify!(nsamples)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHAudio>())).channels as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SHAudio),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHAudio>())).samples as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHAudio),
      "::",
      stringify!(samples)
    )
  );
}
impl Default for SHAudio {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHTableGetIterator =
  ::core::option::Option<unsafe extern "C" fn(table: SHTable, outIter: *mut SHTableIterator)>;
pub type SHTableNext = ::core::option::Option<
  unsafe extern "C" fn(
    table: SHTable,
    inIter: *mut SHTableIterator,
    outKey: *mut SHString,
    outValue: *mut SHVar,
  ) -> SHBool,
>;
pub type SHTableSize = ::core::option::Option<unsafe extern "C" fn(table: SHTable) -> size_t>;
pub type SHTableContains =
  ::core::option::Option<unsafe extern "C" fn(table: SHTable, key: SHString) -> SHBool>;
pub type SHTableAt =
  ::core::option::Option<unsafe extern "C" fn(table: SHTable, key: SHString) -> *mut SHVar>;
pub type SHTableRemove =
  ::core::option::Option<unsafe extern "C" fn(table: SHTable, key: SHString)>;
pub type SHTableClear = ::core::option::Option<unsafe extern "C" fn(table: SHTable)>;
pub type SHTableFree = ::core::option::Option<unsafe extern "C" fn(table: SHTable)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHTableInterface {
  pub tableGetIterator: SHTableGetIterator,
  pub tableNext: SHTableNext,
  pub tableSize: SHTableSize,
  pub tableContains: SHTableContains,
  pub tableAt: SHTableAt,
  pub tableRemove: SHTableRemove,
  pub tableClear: SHTableClear,
  pub tableFree: SHTableFree,
}
#[test]
fn bindgen_test_layout_SHTableInterface() {
  assert_eq!(
    ::core::mem::size_of::<SHTableInterface>(),
    32usize,
    concat!("Size of: ", stringify!(SHTableInterface))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTableInterface>(),
    4usize,
    concat!("Alignment of ", stringify!(SHTableInterface))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableGetIterator as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableGetIterator)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableNext as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableNext)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableContains as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableContains)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableAt as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableAt)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableRemove as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableRemove)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableClear as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableClear)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTableInterface>())).tableFree as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTableInterface),
      "::",
      stringify!(tableFree)
    )
  );
}
pub type SHSetGetIterator =
  ::core::option::Option<unsafe extern "C" fn(set: SHSet, outIter: *mut SHSetIterator)>;
pub type SHSetNext = ::core::option::Option<
  unsafe extern "C" fn(set: SHSet, inIter: *mut SHSetIterator, outValue: *mut SHVar) -> SHBool,
>;
pub type SHSetSize = ::core::option::Option<unsafe extern "C" fn(table: SHSet) -> size_t>;
pub type SHSetContains =
  ::core::option::Option<unsafe extern "C" fn(table: SHSet, value: SHVar) -> SHBool>;
pub type SHSetInclude =
  ::core::option::Option<unsafe extern "C" fn(table: SHSet, value: SHVar) -> SHBool>;
pub type SHSetExclude =
  ::core::option::Option<unsafe extern "C" fn(table: SHSet, value: SHVar) -> SHBool>;
pub type SHSetClear = ::core::option::Option<unsafe extern "C" fn(table: SHSet)>;
pub type SHSetFree = ::core::option::Option<unsafe extern "C" fn(table: SHSet)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHSetInterface {
  pub setGetIterator: SHSetGetIterator,
  pub setNext: SHSetNext,
  pub setSize: SHSetSize,
  pub setContains: SHSetContains,
  pub setInclude: SHSetInclude,
  pub setExclude: SHSetExclude,
  pub setClear: SHSetClear,
  pub setFree: SHSetFree,
}
#[test]
fn bindgen_test_layout_SHSetInterface() {
  assert_eq!(
    ::core::mem::size_of::<SHSetInterface>(),
    32usize,
    concat!("Size of: ", stringify!(SHSetInterface))
  );
  assert_eq!(
    ::core::mem::align_of::<SHSetInterface>(),
    4usize,
    concat!("Alignment of ", stringify!(SHSetInterface))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setGetIterator as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setGetIterator)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setNext as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setNext)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setContains as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setContains)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setInclude as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setInclude)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setExclude as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setExclude)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setClear as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setClear)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHSetInterface>())).setFree as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SHSetInterface),
      "::",
      stringify!(setFree)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHTypeInfo {
  pub basicType: SHType,
  pub details: SHTypeInfo_Details,
  pub fixedSize: u32,
  pub innerType: SHType,
  pub recursiveSelf: SHBool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHTypeInfo_Details {
  pub object: SHTypeInfo_Details_Object,
  pub enumeration: SHTypeInfo_Details_Enum,
  pub seqTypes: SHTypesInfo,
  pub setTypes: SHTypesInfo,
  pub table: SHTypeInfo_Details_Table,
  pub contextVarTypes: SHTypesInfo,
  pub path: SHTypeInfo_Details_Path,
  pub integers: SHTypeInfo_Details_Integers,
  pub real: SHTypeInfo_Details_Real,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHTypeInfo_Details_Object {
  pub vendorId: i32,
  pub typeId: i32,
}
#[test]
fn bindgen_test_layout_SHTypeInfo_Details_Object() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo_Details_Object>(),
    8usize,
    concat!("Size of: ", stringify!(SHTypeInfo_Details_Object))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo_Details_Object>(),
    4usize,
    concat!("Alignment of ", stringify!(SHTypeInfo_Details_Object))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Object>())).vendorId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Object),
      "::",
      stringify!(vendorId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Object>())).typeId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Object),
      "::",
      stringify!(typeId)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHTypeInfo_Details_Enum {
  pub vendorId: i32,
  pub typeId: i32,
}
#[test]
fn bindgen_test_layout_SHTypeInfo_Details_Enum() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo_Details_Enum>(),
    8usize,
    concat!("Size of: ", stringify!(SHTypeInfo_Details_Enum))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo_Details_Enum>(),
    4usize,
    concat!("Alignment of ", stringify!(SHTypeInfo_Details_Enum))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Enum>())).vendorId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Enum),
      "::",
      stringify!(vendorId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Enum>())).typeId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Enum),
      "::",
      stringify!(typeId)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHTypeInfo_Details_Table {
  pub keys: SHStrings,
  pub types: SHTypesInfo,
}
#[test]
fn bindgen_test_layout_SHTypeInfo_Details_Table() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo_Details_Table>(),
    24usize,
    concat!("Size of: ", stringify!(SHTypeInfo_Details_Table))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo_Details_Table>(),
    4usize,
    concat!("Alignment of ", stringify!(SHTypeInfo_Details_Table))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Table>())).keys as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Table),
      "::",
      stringify!(keys)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Table>())).types as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Table),
      "::",
      stringify!(types)
    )
  );
}
impl Default for SHTypeInfo_Details_Table {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHTypeInfo_Details_Path {
  pub extensions: SHStrings,
  pub isFile: SHBool,
  pub existing: SHBool,
  pub relative: SHBool,
}
#[test]
fn bindgen_test_layout_SHTypeInfo_Details_Path() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo_Details_Path>(),
    16usize,
    concat!("Size of: ", stringify!(SHTypeInfo_Details_Path))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo_Details_Path>(),
    4usize,
    concat!("Alignment of ", stringify!(SHTypeInfo_Details_Path))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Path>())).extensions as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Path),
      "::",
      stringify!(extensions)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Path>())).isFile as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Path),
      "::",
      stringify!(isFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Path>())).existing as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Path),
      "::",
      stringify!(existing)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Path>())).relative as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Path),
      "::",
      stringify!(relative)
    )
  );
}
impl Default for SHTypeInfo_Details_Path {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHTypeInfo_Details_Integers {
  pub min: i64,
  pub max: i64,
  pub valid: SHBool,
}
#[test]
fn bindgen_test_layout_SHTypeInfo_Details_Integers() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo_Details_Integers>(),
    24usize,
    concat!("Size of: ", stringify!(SHTypeInfo_Details_Integers))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo_Details_Integers>(),
    8usize,
    concat!("Alignment of ", stringify!(SHTypeInfo_Details_Integers))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Integers>())).min as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Integers),
      "::",
      stringify!(min)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Integers>())).max as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Integers),
      "::",
      stringify!(max)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Integers>())).valid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Integers),
      "::",
      stringify!(valid)
    )
  );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHTypeInfo_Details_Real {
  pub min: f64,
  pub max: f64,
  pub valid: SHBool,
}
#[test]
fn bindgen_test_layout_SHTypeInfo_Details_Real() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo_Details_Real>(),
    24usize,
    concat!("Size of: ", stringify!(SHTypeInfo_Details_Real))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo_Details_Real>(),
    8usize,
    concat!("Alignment of ", stringify!(SHTypeInfo_Details_Real))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Real>())).min as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Real),
      "::",
      stringify!(min)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Real>())).max as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Real),
      "::",
      stringify!(max)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details_Real>())).valid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details_Real),
      "::",
      stringify!(valid)
    )
  );
}
#[test]
fn bindgen_test_layout_SHTypeInfo_Details() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo_Details>(),
    24usize,
    concat!("Size of: ", stringify!(SHTypeInfo_Details))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo_Details>(),
    8usize,
    concat!("Alignment of ", stringify!(SHTypeInfo_Details))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).object as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(object)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).enumeration as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(enumeration)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).seqTypes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(seqTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).setTypes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(setTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).table as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(table)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).contextVarTypes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(contextVarTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).path as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(path)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).integers as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(integers)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo_Details>())).real as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo_Details),
      "::",
      stringify!(real)
    )
  );
}
impl Default for SHTypeInfo_Details {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[test]
fn bindgen_test_layout_SHTypeInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHTypeInfo>(),
    40usize,
    concat!("Size of: ", stringify!(SHTypeInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHTypeInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(SHTypeInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo>())).basicType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo),
      "::",
      stringify!(basicType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo>())).details as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo),
      "::",
      stringify!(details)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo>())).fixedSize as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo),
      "::",
      stringify!(fixedSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo>())).innerType as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo),
      "::",
      stringify!(innerType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHTypeInfo>())).recursiveSelf as *const _ as usize },
    37usize,
    concat!(
      "Offset of field: ",
      stringify!(SHTypeInfo),
      "::",
      stringify!(recursiveSelf)
    )
  );
}
impl Default for SHTypeInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHObjectSerializer = ::core::option::Option<
  unsafe extern "C" fn(
    arg1: SHPointer,
    outData: *mut *mut u8,
    outLen: *mut size_t,
    customHandle: *mut SHPointer,
  ) -> SHBool,
>;
pub type SHObjectSerializerFree =
  ::core::option::Option<unsafe extern "C" fn(customHandle: SHPointer)>;
pub type SHObjectDeserializer =
  ::core::option::Option<unsafe extern "C" fn(data: *mut u8, len: size_t) -> SHPointer>;
pub type SHObjectReference = ::core::option::Option<unsafe extern "C" fn(arg1: SHPointer)>;
pub type SHObjectRelease = ::core::option::Option<unsafe extern "C" fn(arg1: SHPointer)>;
pub type SHObjectHash = ::core::option::Option<unsafe extern "C" fn(arg1: SHPointer) -> u64>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHObjectInfo {
  pub name: SHString,
  pub serialize: SHObjectSerializer,
  pub free: SHObjectSerializerFree,
  pub deserialize: SHObjectDeserializer,
  pub reference: SHObjectReference,
  pub release: SHObjectRelease,
  pub hash: SHObjectHash,
}
#[test]
fn bindgen_test_layout_SHObjectInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHObjectInfo>(),
    28usize,
    concat!("Size of: ", stringify!(SHObjectInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHObjectInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SHObjectInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHObjectInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHObjectInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHObjectInfo>())).serialize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHObjectInfo),
      "::",
      stringify!(serialize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHObjectInfo>())).free as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHObjectInfo),
      "::",
      stringify!(free)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHObjectInfo>())).deserialize as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHObjectInfo),
      "::",
      stringify!(deserialize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHObjectInfo>())).reference as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHObjectInfo),
      "::",
      stringify!(reference)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHObjectInfo>())).release as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SHObjectInfo),
      "::",
      stringify!(release)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHObjectInfo>())).hash as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SHObjectInfo),
      "::",
      stringify!(hash)
    )
  );
}
impl Default for SHObjectInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHEnumInfo {
  pub name: SHString,
  pub labels: SHStrings,
  pub values: SHEnums,
}
#[test]
fn bindgen_test_layout_SHEnumInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHEnumInfo>(),
    28usize,
    concat!("Size of: ", stringify!(SHEnumInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHEnumInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SHEnumInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHEnumInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHEnumInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHEnumInfo>())).labels as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHEnumInfo),
      "::",
      stringify!(labels)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHEnumInfo>())).values as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHEnumInfo),
      "::",
      stringify!(values)
    )
  );
}
impl Default for SHEnumInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHParameterInfo {
  pub name: SHString,
  pub help: SHOptionalString,
  pub valueTypes: SHTypesInfo,
}
#[test]
fn bindgen_test_layout_SHParameterInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHParameterInfo>(),
    24usize,
    concat!("Size of: ", stringify!(SHParameterInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHParameterInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SHParameterInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHParameterInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHParameterInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHParameterInfo>())).help as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHParameterInfo),
      "::",
      stringify!(help)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHParameterInfo>())).valueTypes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHParameterInfo),
      "::",
      stringify!(valueTypes)
    )
  );
}
impl Default for SHParameterInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHExposedTypeInfo {
  pub name: SHString,
  pub help: SHOptionalString,
  pub exposedType: SHTypeInfo,
  pub isMutable: SHBool,
  pub isProtected: SHBool,
  pub isTableEntry: SHBool,
  pub global: SHBool,
  pub scope: *mut SHWire,
}
#[test]
fn bindgen_test_layout_SHExposedTypeInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHExposedTypeInfo>(),
    64usize,
    concat!("Size of: ", stringify!(SHExposedTypeInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHExposedTypeInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(SHExposedTypeInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).help as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(help)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).exposedType as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(exposedType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).isMutable as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(isMutable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).isProtected as *const _ as usize },
    57usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(isProtected)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).isTableEntry as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(isTableEntry)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).global as *const _ as usize },
    59usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(global)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHExposedTypeInfo>())).scope as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SHExposedTypeInfo),
      "::",
      stringify!(scope)
    )
  );
}
impl Default for SHExposedTypeInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHFlow {
  pub wire: *mut SHWire,
}
#[test]
fn bindgen_test_layout_SHFlow() {
  assert_eq!(
    ::core::mem::size_of::<SHFlow>(),
    4usize,
    concat!("Size of: ", stringify!(SHFlow))
  );
  assert_eq!(
    ::core::mem::align_of::<SHFlow>(),
    4usize,
    concat!("Alignment of ", stringify!(SHFlow))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHFlow>())).wire as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHFlow),
      "::",
      stringify!(wire)
    )
  );
}
impl Default for SHFlow {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct SHVarPayload {
  pub __bindgen_anon_1: SHVarPayload__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union SHVarPayload__bindgen_ty_1 {
  pub boolValue: SHBool,
  pub __bindgen_anon_1: SHVarPayload__bindgen_ty_1__bindgen_ty_1,
  pub intValue: SHInt,
  pub int2Value: SHInt2,
  pub int3Value: SHInt3,
  pub int4Value: SHInt4,
  pub int8Value: SHInt8,
  pub int16Value: SHInt16,
  pub floatValue: SHFloat,
  pub float2Value: SHFloat2,
  pub float3Value: SHFloat3,
  pub float4Value: SHFloat4,
  pub seqValue: SHSeq,
  pub tableValue: SHTable,
  pub setValue: SHSet,
  pub __bindgen_anon_2: SHVarPayload__bindgen_ty_1__bindgen_ty_2,
  pub colorValue: SHColor,
  pub imageValue: SHImage,
  pub audioValue: SHAudio,
  pub wireValue: SHWireRef,
  pub shardValue: ShardPtr,
  pub __bindgen_anon_3: SHVarPayload__bindgen_ty_1__bindgen_ty_3,
  pub __bindgen_anon_4: SHVarPayload__bindgen_ty_1__bindgen_ty_4,
  pub arrayValue: SHPayloadArray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHVarPayload__bindgen_ty_1__bindgen_ty_1 {
  pub objectValue: SHPointer,
  pub objectVendorId: i32,
  pub objectTypeId: i32,
}
#[test]
fn bindgen_test_layout_SHVarPayload__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_1>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_1>())).objectValue as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(objectValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_1>())).objectVendorId
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(objectVendorId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_1>())).objectTypeId as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(objectTypeId)
    )
  );
}
impl Default for SHVarPayload__bindgen_ty_1__bindgen_ty_1 {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHVarPayload__bindgen_ty_1__bindgen_ty_2 {
  pub stringValue: SHString,
  pub stringLen: u32,
  pub stringCapacity: u32,
}
#[test]
fn bindgen_test_layout_SHVarPayload__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::core::mem::size_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_2>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_2>())).stringValue as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(stringValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_2>())).stringLen as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(stringLen)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_2>())).stringCapacity
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(stringCapacity)
    )
  );
}
impl Default for SHVarPayload__bindgen_ty_1__bindgen_ty_2 {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SHVarPayload__bindgen_ty_1__bindgen_ty_3 {
  pub enumValue: SHEnum,
  pub enumVendorId: i32,
  pub enumTypeId: i32,
}
#[test]
fn bindgen_test_layout_SHVarPayload__bindgen_ty_1__bindgen_ty_3() {
  assert_eq!(
    ::core::mem::size_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_3>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_3>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_3>())).enumValue as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(enumValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_3>())).enumVendorId as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(enumVendorId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_3>())).enumTypeId as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_3),
      "::",
      stringify!(enumTypeId)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHVarPayload__bindgen_ty_1__bindgen_ty_4 {
  pub bytesValue: *mut u8,
  pub bytesSize: u32,
  pub bytesCapacity: u32,
}
#[test]
fn bindgen_test_layout_SHVarPayload__bindgen_ty_1__bindgen_ty_4() {
  assert_eq!(
    ::core::mem::size_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_4>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_4)
    )
  );
  assert_eq!(
    ::core::mem::align_of::<SHVarPayload__bindgen_ty_1__bindgen_ty_4>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_4>())).bytesValue as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(bytesValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_4>())).bytesSize as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(bytesSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1__bindgen_ty_4>())).bytesCapacity
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1__bindgen_ty_4),
      "::",
      stringify!(bytesCapacity)
    )
  );
}
impl Default for SHVarPayload__bindgen_ty_1__bindgen_ty_4 {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[test]
fn bindgen_test_layout_SHVarPayload__bindgen_ty_1() {
  assert_eq!(
    ::core::mem::size_of::<SHVarPayload__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(SHVarPayload__bindgen_ty_1))
  );
  assert_eq!(
    ::core::mem::align_of::<SHVarPayload__bindgen_ty_1>(),
    16usize,
    concat!("Alignment of ", stringify!(SHVarPayload__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).boolValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(boolValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).intValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(intValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).int2Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(int2Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).int3Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(int3Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).int4Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(int4Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).int8Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(int8Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).int16Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(int16Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).floatValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(floatValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).float2Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(float2Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).float3Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(float3Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).float4Value as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(float4Value)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).seqValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(seqValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).tableValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(tableValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).setValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(setValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).colorValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(colorValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).imageValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(imageValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).audioValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(audioValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).wireValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(wireValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).shardValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(shardValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::core::ptr::null::<SHVarPayload__bindgen_ty_1>())).arrayValue as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVarPayload__bindgen_ty_1),
      "::",
      stringify!(arrayValue)
    )
  );
}
impl Default for SHVarPayload__bindgen_ty_1 {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[test]
fn bindgen_test_layout_SHVarPayload() {
  assert_eq!(
    ::core::mem::size_of::<SHVarPayload>(),
    16usize,
    concat!("Size of: ", stringify!(SHVarPayload))
  );
  assert_eq!(
    ::core::mem::align_of::<SHVarPayload>(),
    16usize,
    concat!("Alignment of ", stringify!(SHVarPayload))
  );
}
impl Default for SHVarPayload {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct SHVar {
  pub payload: SHVarPayload,
  pub valueType: SHType,
  pub innerType: SHType,
  pub flags: u16,
  pub refcount: u32,
  pub objectInfo: *mut SHObjectInfo,
  pub _cpu32bits_padding: u32,
}
#[test]
fn bindgen_test_layout_SHVar() {
  assert_eq!(
    ::core::mem::size_of::<SHVar>(),
    32usize,
    concat!("Size of: ", stringify!(SHVar))
  );
  assert_eq!(
    ::core::mem::align_of::<SHVar>(),
    16usize,
    concat!("Alignment of ", stringify!(SHVar))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHVar>())).payload as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVar),
      "::",
      stringify!(payload)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHVar>())).valueType as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVar),
      "::",
      stringify!(valueType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHVar>())).innerType as *const _ as usize },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVar),
      "::",
      stringify!(innerType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHVar>())).flags as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVar),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHVar>())).refcount as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVar),
      "::",
      stringify!(refcount)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHVar>())).objectInfo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVar),
      "::",
      stringify!(objectInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHVar>()))._cpu32bits_padding as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SHVar),
      "::",
      stringify!(_cpu32bits_padding)
    )
  );
}
impl Default for SHVar {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub const SHRunWireOutputState_Running: SHRunWireOutputState = 0;
pub const SHRunWireOutputState_Restarted: SHRunWireOutputState = 1;
pub const SHRunWireOutputState_Stopped: SHRunWireOutputState = 2;
pub const SHRunWireOutputState_Failed: SHRunWireOutputState = 3;
pub type SHRunWireOutputState = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct SHRunWireOutput {
  pub output: SHVar,
  pub state: SHRunWireOutputState,
}
#[test]
fn bindgen_test_layout_SHRunWireOutput() {
  assert_eq!(
    ::core::mem::size_of::<SHRunWireOutput>(),
    48usize,
    concat!("Size of: ", stringify!(SHRunWireOutput))
  );
  assert_eq!(
    ::core::mem::align_of::<SHRunWireOutput>(),
    16usize,
    concat!("Alignment of ", stringify!(SHRunWireOutput))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHRunWireOutput>())).output as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHRunWireOutput),
      "::",
      stringify!(output)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHRunWireOutput>())).state as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SHRunWireOutput),
      "::",
      stringify!(state)
    )
  );
}
impl Default for SHRunWireOutput {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct SHComposeResult {
  pub outputType: SHTypeInfo,
  pub failed: SHBool,
  pub __bindgen_padding_0: [u64; 0usize],
  pub failureMessage: SHVar,
  pub exposedInfo: SHExposedTypesInfo,
  pub requiredInfo: SHExposedTypesInfo,
  pub flowStopper: bool,
}
#[test]
fn bindgen_test_layout_SHComposeResult() {
  assert_eq!(
    ::core::mem::size_of::<SHComposeResult>(),
    112usize,
    concat!("Size of: ", stringify!(SHComposeResult))
  );
  assert_eq!(
    ::core::mem::align_of::<SHComposeResult>(),
    16usize,
    concat!("Alignment of ", stringify!(SHComposeResult))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHComposeResult>())).outputType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHComposeResult),
      "::",
      stringify!(outputType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHComposeResult>())).failed as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SHComposeResult),
      "::",
      stringify!(failed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHComposeResult>())).failureMessage as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SHComposeResult),
      "::",
      stringify!(failureMessage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHComposeResult>())).exposedInfo as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SHComposeResult),
      "::",
      stringify!(exposedInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHComposeResult>())).requiredInfo as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(SHComposeResult),
      "::",
      stringify!(requiredInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHComposeResult>())).flowStopper as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(SHComposeResult),
      "::",
      stringify!(flowStopper)
    )
  );
}
impl Default for SHComposeResult {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHComposeError = ::core::option::Option<
  unsafe extern "C" fn(
    privateContext: *mut ::core::ffi::c_void,
    errorText: SHString,
    warningOnly: SHBool,
  ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHInstanceData {
  pub shard: *mut Shard,
  pub wire: *mut SHWire,
  pub inputType: SHTypeInfo,
  pub shared: SHExposedTypesInfo,
  pub onWorkerThread: bool,
  pub outputTypes: SHTypesInfo,
  pub reportError: SHComposeError,
  pub privateContext: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_SHInstanceData() {
  assert_eq!(
    ::core::mem::size_of::<SHInstanceData>(),
    88usize,
    concat!("Size of: ", stringify!(SHInstanceData))
  );
  assert_eq!(
    ::core::mem::align_of::<SHInstanceData>(),
    8usize,
    concat!("Alignment of ", stringify!(SHInstanceData))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).shard as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(shard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).wire as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(wire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).inputType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(inputType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).shared as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(shared)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).onWorkerThread as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(onWorkerThread)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).outputTypes as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(outputTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).reportError as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(reportError)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHInstanceData>())).privateContext as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(SHInstanceData),
      "::",
      stringify!(privateContext)
    )
  );
}
impl Default for SHInstanceData {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHShardConstructor = ::core::option::Option<unsafe extern "C" fn() -> *mut Shard>;
pub type SHCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type SHNameProc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHString>;
pub type SHHashProc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> u32>;
pub type SHHelpProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHOptionalString>;
pub type SHPropertiesProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> *const SHTable>;
pub type SHSetupProc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard)>;
pub type SHDestroyProc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard)>;
pub type SHInputTypesProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHTypesInfo>;
pub type SHOutputTypesProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHTypesInfo>;
pub type SHExposedVariablesProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHExposedTypesInfo>;
pub type SHRequiredVariablesProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHExposedTypesInfo>;
pub type SHParametersProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHParametersInfo>;
pub type SHSetParamProc = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut Shard, arg2: ::std::os::raw::c_int, arg3: *const SHVar),
>;
pub type SHGetParamProc = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut Shard, arg2: ::std::os::raw::c_int) -> SHVar,
>;
pub type SHComposeProc = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut Shard, data: SHInstanceData) -> SHTypeInfo,
>;
pub type SHComposedProc = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut Shard, wire: *const SHWire, data: *const SHComposeResult),
>;
pub type SHActivateProc = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut Shard, arg2: *mut SHContext, arg3: *const SHVar) -> SHVar,
>;
pub type SHCleanupProc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard)>;
pub type SHWarmupProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard, arg2: *mut SHContext)>;
pub type SHNextFrameProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard, arg2: *mut SHContext)>;
pub type SHMutateProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard, options: SHTable)>;
pub type SHCrossoverProc = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut Shard, state0: *const SHVar, state1: *const SHVar),
>;
pub type SHGetStateProc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard) -> SHVar>;
pub type SHSetStateProc =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard, state: *const SHVar)>;
pub type SHResetStateProc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shard)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shard {
  pub inlineShardId: SHInlineShards,
  pub owned: SHBool,
  pub name: SHNameProc,
  pub hash: SHHashProc,
  pub help: SHHelpProc,
  pub inputHelp: SHHelpProc,
  pub outputHelp: SHHelpProc,
  pub properties: SHPropertiesProc,
  pub setup: SHSetupProc,
  pub destroy: SHDestroyProc,
  pub inputTypes: SHInputTypesProc,
  pub outputTypes: SHOutputTypesProc,
  pub exposedVariables: SHExposedVariablesProc,
  pub requiredVariables: SHRequiredVariablesProc,
  pub compose: SHComposeProc,
  pub composed: SHComposedProc,
  pub parameters: SHParametersProc,
  pub setParam: SHSetParamProc,
  pub getParam: SHGetParamProc,
  pub warmup: SHWarmupProc,
  pub activate: SHActivateProc,
  pub cleanup: SHCleanupProc,
  pub nextFrame: SHNextFrameProc,
  pub mutate: SHMutateProc,
  pub crossover: SHCrossoverProc,
  pub getState: SHGetStateProc,
  pub setState: SHSetStateProc,
  pub resetState: SHResetStateProc,
}
#[test]
fn bindgen_test_layout_Shard() {
  assert_eq!(
    ::core::mem::size_of::<Shard>(),
    112usize,
    concat!("Size of: ", stringify!(Shard))
  );
  assert_eq!(
    ::core::mem::align_of::<Shard>(),
    4usize,
    concat!("Alignment of ", stringify!(Shard))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).inlineShardId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(inlineShardId)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).owned as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(owned)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).hash as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(hash)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).help as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(help)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).inputHelp as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(inputHelp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).outputHelp as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(outputHelp)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).properties as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(properties)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).setup as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(setup)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).destroy as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(destroy)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).inputTypes as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(inputTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).outputTypes as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(outputTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).exposedVariables as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(exposedVariables)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).requiredVariables as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(requiredVariables)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).compose as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(compose)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).composed as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(composed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).parameters as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(parameters)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).setParam as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(setParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).getParam as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(getParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).warmup as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(warmup)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).activate as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(activate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).cleanup as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(cleanup)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).nextFrame as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(nextFrame)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).mutate as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(mutate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).crossover as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(crossover)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).getState as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(getState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).setState as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(setState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<Shard>())).resetState as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(Shard),
      "::",
      stringify!(resetState)
    )
  );
}
impl Default for Shard {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHWireProviderUpdate {
  pub error: SHString,
  pub wire: *mut SHWire,
}
#[test]
fn bindgen_test_layout_SHWireProviderUpdate() {
  assert_eq!(
    ::core::mem::size_of::<SHWireProviderUpdate>(),
    8usize,
    concat!("Size of: ", stringify!(SHWireProviderUpdate))
  );
  assert_eq!(
    ::core::mem::align_of::<SHWireProviderUpdate>(),
    4usize,
    concat!("Alignment of ", stringify!(SHWireProviderUpdate))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProviderUpdate>())).error as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProviderUpdate),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProviderUpdate>())).wire as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProviderUpdate),
      "::",
      stringify!(wire)
    )
  );
}
impl Default for SHWireProviderUpdate {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHProviderReset =
  ::core::option::Option<unsafe extern "C" fn(provider: *mut SHWireProvider)>;
pub type SHProviderReady =
  ::core::option::Option<unsafe extern "C" fn(provider: *mut SHWireProvider) -> SHBool>;
pub type SHProviderSetup = ::core::option::Option<
  unsafe extern "C" fn(provider: *mut SHWireProvider, path: SHString, data: SHInstanceData),
>;
pub type SHProviderUpdated =
  ::core::option::Option<unsafe extern "C" fn(provider: *mut SHWireProvider) -> SHBool>;
pub type SHProviderAcquire = ::core::option::Option<
  unsafe extern "C" fn(provider: *mut SHWireProvider) -> SHWireProviderUpdate,
>;
pub type SHProviderReleaseWire =
  ::core::option::Option<unsafe extern "C" fn(provider: *mut SHWireProvider, wire: *mut SHWire)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHWireProvider {
  pub reset: SHProviderReset,
  pub ready: SHProviderReady,
  pub setup: SHProviderSetup,
  pub updated: SHProviderUpdated,
  pub acquire: SHProviderAcquire,
  pub release: SHProviderReleaseWire,
  pub userData: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_SHWireProvider() {
  assert_eq!(
    ::core::mem::size_of::<SHWireProvider>(),
    28usize,
    concat!("Size of: ", stringify!(SHWireProvider))
  );
  assert_eq!(
    ::core::mem::align_of::<SHWireProvider>(),
    4usize,
    concat!("Alignment of ", stringify!(SHWireProvider))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProvider>())).reset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProvider),
      "::",
      stringify!(reset)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProvider>())).ready as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProvider),
      "::",
      stringify!(ready)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProvider>())).setup as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProvider),
      "::",
      stringify!(setup)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProvider>())).updated as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProvider),
      "::",
      stringify!(updated)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProvider>())).acquire as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProvider),
      "::",
      stringify!(acquire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProvider>())).release as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProvider),
      "::",
      stringify!(release)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireProvider>())).userData as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireProvider),
      "::",
      stringify!(userData)
    )
  );
}
impl Default for SHWireProvider {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHValidationCallback = ::core::option::Option<
  unsafe extern "C" fn(
    errorShard: *const Shard,
    errorTxt: SHString,
    nonfatalWarning: SHBool,
    userData: *mut ::core::ffi::c_void,
  ),
>;
pub type SHRegisterShard =
  ::core::option::Option<unsafe extern "C" fn(fullName: SHString, constructor: SHShardConstructor)>;
pub type SHRegisterObjectType =
  ::core::option::Option<unsafe extern "C" fn(vendorId: i32, typeId: i32, info: SHObjectInfo)>;
pub type SHRegisterEnumType =
  ::core::option::Option<unsafe extern "C" fn(vendorId: i32, typeId: i32, info: SHEnumInfo)>;
pub type SHRegisterRunLoopCallback =
  ::core::option::Option<unsafe extern "C" fn(eventName: SHString, callback: SHCallback)>;
pub type SHRegisterExitCallback =
  ::core::option::Option<unsafe extern "C" fn(eventName: SHString, callback: SHCallback)>;
pub type SHUnregisterRunLoopCallback =
  ::core::option::Option<unsafe extern "C" fn(eventName: SHString)>;
pub type SHUnregisterExitCallback =
  ::core::option::Option<unsafe extern "C" fn(eventName: SHString)>;
pub type SHReferenceVariable = ::core::option::Option<
  unsafe extern "C" fn(context: *mut SHContext, name: SHString) -> *mut SHVar,
>;
pub type SHReferenceWireVariable =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, name: SHString) -> *mut SHVar>;
pub type SHSetExternalVariable =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, name: SHString, pVar: *mut SHVar)>;
pub type SHRemoveExternalVariable =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, name: SHString)>;
pub type SHAllocExternalVariable =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, name: SHString) -> *mut SHVar>;
pub type SHFreeExternalVariable =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, name: SHString)>;
pub type SHReleaseVariable = ::core::option::Option<unsafe extern "C" fn(variable: *mut SHVar)>;
pub type SHAbortWire =
  ::core::option::Option<unsafe extern "C" fn(context: *mut SHContext, errorText: SHString)>;
pub type SHSuspend = ::core::option::Option<
  unsafe extern "C" fn(context: *mut SHContext, seconds: f64) -> SHWireState,
>;
pub type SHGetState =
  ::core::option::Option<unsafe extern "C" fn(context: *mut SHContext) -> SHWireState>;
pub type SHCloneVar =
  ::core::option::Option<unsafe extern "C" fn(dst: *mut SHVar, src: *const SHVar)>;
pub type SHDestroyVar = ::core::option::Option<unsafe extern "C" fn(var: *mut SHVar)>;
pub type SHValidateSetParam = ::core::option::Option<
  unsafe extern "C" fn(
    shard: *mut Shard,
    index: ::std::os::raw::c_int,
    param: *const SHVar,
    callback: SHValidationCallback,
    userData: *mut ::core::ffi::c_void,
  ) -> SHBool,
>;
pub type SHComposeShards = ::core::option::Option<
  unsafe extern "C" fn(
    shards: Shards,
    callback: SHValidationCallback,
    userData: *mut ::core::ffi::c_void,
    data: SHInstanceData,
  ) -> SHComposeResult,
>;
pub type SHRunShards = ::core::option::Option<
  unsafe extern "C" fn(
    shards: Shards,
    context: *mut SHContext,
    input: *const SHVar,
    output: *mut SHVar,
  ) -> SHWireState,
>;
pub type SHRunShardsHashed = ::core::option::Option<
  unsafe extern "C" fn(
    shards: Shards,
    context: *mut SHContext,
    input: *const SHVar,
    output: *mut SHVar,
    outHash: *mut SHVar,
  ) -> SHWireState,
>;
pub type SHLog = ::core::option::Option<unsafe extern "C" fn(msg: SHString)>;
pub type SHLogLevel =
  ::core::option::Option<unsafe extern "C" fn(level: ::std::os::raw::c_int, msg: SHString)>;
pub type SHCreateShard =
  ::core::option::Option<unsafe extern "C" fn(name: SHString) -> *mut Shard>;
pub type SHCreateWire = ::core::option::Option<unsafe extern "C" fn() -> SHWireRef>;
pub type SHSetWireName =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, name: SHString)>;
pub type SHSetWireLooped =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, looped: SHBool)>;
pub type SHSetWireUnsafe =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, unsafe_: SHBool)>;
pub type SHAddShard =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, shard: ShardPtr)>;
pub type SHRemShard =
  ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef, shard: ShardPtr)>;
pub type SHDestroyWire = ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef)>;
pub type SHStopWire = ::core::option::Option<unsafe extern "C" fn(wire: SHWireRef) -> SHVar>;
pub type SHComposeWire = ::core::option::Option<
  unsafe extern "C" fn(
    wire: SHWireRef,
    callback: SHValidationCallback,
    userData: *mut ::core::ffi::c_void,
    data: SHInstanceData,
  ) -> SHComposeResult,
>;
pub type SHRunWire = ::core::option::Option<
  unsafe extern "C" fn(
    wire: SHWireRef,
    context: *mut SHContext,
    input: *const SHVar,
  ) -> SHRunWireOutput,
>;
pub type SHGetGlobalWire =
  ::core::option::Option<unsafe extern "C" fn(name: SHString) -> SHWireRef>;
pub type SHSetGlobalWire =
  ::core::option::Option<unsafe extern "C" fn(name: SHString, wire: SHWireRef)>;
pub type SHUnsetGlobalWire = ::core::option::Option<unsafe extern "C" fn(name: SHString)>;
pub type SHCreateMesh = ::core::option::Option<unsafe extern "C" fn() -> SHMeshRef>;
pub type SHDestroyMesh = ::core::option::Option<unsafe extern "C" fn(mesh: SHMeshRef)>;
pub type SHSchedule =
  ::core::option::Option<unsafe extern "C" fn(mesh: SHMeshRef, wire: SHWireRef)>;
pub type SHTick = ::core::option::Option<unsafe extern "C" fn(mesh: SHMeshRef) -> SHBool>;
pub type SHSleep = ::core::option::Option<unsafe extern "C" fn(seconds: f64, runCallbacks: SHBool)>;
pub type SHSeqFree = ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHSeq)>;
pub type SHSeqPush =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHSeq, arg2: *const SHVar)>;
pub type SHSeqInsert =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHSeq, arg2: u32, arg3: *const SHVar)>;
pub type SHSeqPop = ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHSeq) -> SHVar>;
pub type SHSeqResize = ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHSeq, arg2: u32)>;
pub type SHSeqFastDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHSeq, arg2: u32)>;
pub type SHSeqSlowDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHSeq, arg2: u32)>;
pub type SHTypesInfoFree = ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHTypesInfo)>;
pub type SHTypesInfoPush =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHTypesInfo, arg2: *const SHTypeInfo)>;
pub type SHTypesInfoInsert = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut SHTypesInfo, arg2: u32, arg3: *const SHTypeInfo),
>;
pub type SHTypesInfoPop =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHTypesInfo) -> SHTypeInfo>;
pub type SHTypesInfoResize =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHTypesInfo, arg2: u32)>;
pub type SHTypesInfoFastDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHTypesInfo, arg2: u32)>;
pub type SHTypesInfoSlowDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHTypesInfo, arg2: u32)>;
pub type SHParametersInfoFree =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHParametersInfo)>;
pub type SHParametersInfoPush = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut SHParametersInfo, arg2: *const SHParameterInfo),
>;
pub type SHParametersInfoInsert = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut SHParametersInfo, arg2: u32, arg3: *const SHParameterInfo),
>;
pub type SHParametersInfoPop =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHParametersInfo) -> SHParameterInfo>;
pub type SHParametersInfoResize =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHParametersInfo, arg2: u32)>;
pub type SHParametersInfoFastDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHParametersInfo, arg2: u32)>;
pub type SHParametersInfoSlowDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHParametersInfo, arg2: u32)>;
pub type ShardsFree = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shards)>;
pub type ShardsPush =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shards, arg2: *const ShardPtr)>;
pub type ShardsInsert = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut Shards, arg2: u32, arg3: *const ShardPtr),
>;
pub type ShardsPop = ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shards) -> ShardPtr>;
pub type ShardsResize =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shards, arg2: u32)>;
pub type ShardsFastDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shards, arg2: u32)>;
pub type ShardsSlowDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut Shards, arg2: u32)>;
pub type SHExposedTypesInfoFree =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHExposedTypesInfo)>;
pub type SHExposedTypesInfoPush = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut SHExposedTypesInfo, arg2: *const SHExposedTypeInfo),
>;
pub type SHExposedTypesInfoInsert = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut SHExposedTypesInfo, arg2: u32, arg3: *const SHExposedTypeInfo),
>;
pub type SHExposedTypesInfoPop =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHExposedTypesInfo) -> SHExposedTypeInfo>;
pub type SHExposedTypesInfoResize =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHExposedTypesInfo, arg2: u32)>;
pub type SHExposedTypesInfoFastDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHExposedTypesInfo, arg2: u32)>;
pub type SHExposedTypesInfoSlowDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHExposedTypesInfo, arg2: u32)>;
pub type SHEnumsFree = ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHEnums)>;
pub type SHEnumsPush =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHEnums, arg2: *const SHEnum)>;
pub type SHEnumsInsert =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHEnums, arg2: u32, arg3: *const SHEnum)>;
pub type SHEnumsPop = ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHEnums) -> SHEnum>;
pub type SHEnumsResize =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHEnums, arg2: u32)>;
pub type SHEnumsFastDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHEnums, arg2: u32)>;
pub type SHEnumsSlowDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHEnums, arg2: u32)>;
pub type SHStringsFree = ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHStrings)>;
pub type SHStringsPush =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHStrings, arg2: *const SHString)>;
pub type SHStringsInsert = ::core::option::Option<
  unsafe extern "C" fn(arg1: *mut SHStrings, arg2: u32, arg3: *const SHString),
>;
pub type SHStringsPop =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHStrings) -> SHString>;
pub type SHStringsResize =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHStrings, arg2: u32)>;
pub type SHStringsFastDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHStrings, arg2: u32)>;
pub type SHStringsSlowDelete =
  ::core::option::Option<unsafe extern "C" fn(arg1: *mut SHStrings, arg2: u32)>;
pub type SHTableNew = ::core::option::Option<unsafe extern "C" fn() -> SHTable>;
pub type SHSetNew = ::core::option::Option<unsafe extern "C" fn() -> SHSet>;
pub type SHGetRootPath = ::core::option::Option<unsafe extern "C" fn() -> SHString>;
pub type SHSetRootPath = ::core::option::Option<unsafe extern "C" fn(arg1: SHString)>;
pub type SHAsyncActivateProc = ::core::option::Option<
  unsafe extern "C" fn(context: *mut SHContext, userData: *mut ::core::ffi::c_void) -> SHVar,
>;
pub type SHAsyncCancelProc = ::core::option::Option<
  unsafe extern "C" fn(context: *mut SHContext, userData: *mut ::core::ffi::c_void),
>;
pub type SHRunAsyncActivate = ::core::option::Option<
  unsafe extern "C" fn(
    context: *mut SHContext,
    userData: *mut ::core::ffi::c_void,
    call: SHAsyncActivateProc,
    cancel_call: SHAsyncCancelProc,
  ) -> SHVar,
>;
pub type SHGetShards = ::core::option::Option<unsafe extern "C" fn() -> SHStrings>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHWireInfo {
  pub name: SHString,
  pub looped: SHBool,
  pub unsafe_: SHBool,
  pub wire: *const SHWire,
  pub shards: Shards,
  pub isRunning: SHBool,
  pub failed: SHBool,
  pub failureMessage: SHString,
  pub finalOutput: *mut SHVar,
}
#[test]
fn bindgen_test_layout_SHWireInfo() {
  assert_eq!(
    ::core::mem::size_of::<SHWireInfo>(),
    36usize,
    concat!("Size of: ", stringify!(SHWireInfo))
  );
  assert_eq!(
    ::core::mem::align_of::<SHWireInfo>(),
    4usize,
    concat!("Alignment of ", stringify!(SHWireInfo))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).looped as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(looped)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).unsafe_ as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(unsafe_)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).wire as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(wire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).shards as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(shards)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).isRunning as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(isRunning)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).failed as *const _ as usize },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(failed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).failureMessage as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(failureMessage)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<SHWireInfo>())).finalOutput as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SHWireInfo),
      "::",
      stringify!(finalOutput)
    )
  );
}
impl Default for SHWireInfo {
  fn default() -> Self {
    let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
    unsafe {
      ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
      s.assume_init()
    }
  }
}
pub type SHGetWireInfo =
  ::core::option::Option<unsafe extern "C" fn(wireref: SHWireRef) -> SHWireInfo>;
pub type SHReadCachedString =
  ::core::option::Option<unsafe extern "C" fn(id: u32) -> SHOptionalString>;
pub type SHWriteCachedString = ::core::option::Option<
  unsafe extern "C" fn(id: u32, str_: *const ::std::os::raw::c_char) -> SHOptionalString,
>;
pub type SHIsEqualVar =
  ::core::option::Option<unsafe extern "C" fn(v1: *const SHVar, v2: *const SHVar) -> SHBool>;
pub type SHIsEqualType = ::core::option::Option<
  unsafe extern "C" fn(t1: *const SHTypeInfo, t2: *const SHTypeInfo) -> SHBool,
>;
pub type SHDeriveTypeInfo = ::core::option::Option<
  unsafe extern "C" fn(v: *const SHVar, data: *const SHInstanceData) -> SHTypeInfo,
>;
pub type SHFreeDerivedTypeInfo = ::core::option::Option<unsafe extern "C" fn(t: *mut SHTypeInfo)>;
pub type SHAlloc =
  ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut ::core::ffi::c_void>;
pub type SHFree = ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SHCore {
  pub alloc: SHAlloc,
  pub free: SHFree,
  pub tableNew: SHTableNew,
  pub setNew: SHSetNew,
  pub composeShards: SHComposeShards,
  pub runShards: SHRunShards,
  pub runShards2: SHRunShards,
  pub runShardsHashed: SHRunShardsHashed,
  pub runShardsHashed2: SHRunShardsHashed,
  pub log: SHLog,
  pub logLevel: SHLogLevel,
  pub createShard: SHCreateShard,
  pub validateSetParam: SHValidateSetParam,
  pub createWire: SHCreateWire,
  pub setWireName: SHSetWireName,
  pub setWireLooped: SHSetWireLooped,
  pub setWireUnsafe: SHSetWireUnsafe,
  pub addShard: SHAddShard,
  pub removeShard: SHRemShard,
  pub destroyWire: SHDestroyWire,
  pub stopWire: SHStopWire,
  pub composeWire: SHComposeWire,
  pub runWire: SHRunWire,
  pub getWireInfo: SHGetWireInfo,
  pub getGlobalWire: SHGetGlobalWire,
  pub setGlobalWire: SHSetGlobalWire,
  pub unsetGlobalWire: SHUnsetGlobalWire,
  pub createMesh: SHCreateMesh,
  pub destroyMesh: SHDestroyMesh,
  pub schedule: SHSchedule,
  pub unschedule: SHSchedule,
  pub tick: SHTick,
  pub sleep: SHSleep,
  pub getRootPath: SHGetRootPath,
  pub setRootPath: SHSetRootPath,
  pub asyncActivate: SHRunAsyncActivate,
  pub getShards: SHGetShards,
  pub registerShard: SHRegisterShard,
  pub registerObjectType: SHRegisterObjectType,
  pub registerEnumType: SHRegisterEnumType,
  pub registerRunLoopCallback: SHRegisterRunLoopCallback,
  pub unregisterRunLoopCallback: SHUnregisterRunLoopCallback,
  pub registerExitCallback: SHRegisterExitCallback,
  pub unregisterExitCallback: SHUnregisterExitCallback,
  pub referenceVariable: SHReferenceVariable,
  pub referenceWireVariable: SHReferenceWireVariable,
  pub releaseVariable: SHReleaseVariable,
  pub setExternalVariable: SHSetExternalVariable,
  pub removeExternalVariable: SHRemoveExternalVariable,
  pub allocExternalVariable: SHAllocExternalVariable,
  pub freeExternalVariable: SHFreeExternalVariable,
  pub suspend: SHSuspend,
  pub getState: SHGetState,
  pub abortWire: SHAbortWire,
  pub cloneVar: SHCloneVar,
  pub destroyVar: SHDestroyVar,
  pub readCachedString: SHReadCachedString,
  pub writeCachedString: SHWriteCachedString,
  pub isEqualVar: SHIsEqualVar,
  pub isEqualType: SHIsEqualType,
  pub deriveTypeInfo: SHDeriveTypeInfo,
  pub freeDerivedTypeInfo: SHFreeDerivedTypeInfo,
  pub seqFree: SHSeqFree,
  pub seqPush: SHSeqPush,
  pub seqInsert: SHSeqInsert,
  pub seqPop: SHSeqPop,
  pub seqResize: SHSeqResize,
  pub seqFastDelete: SHSeqFastDelete,
  pub seqSlowDelete: SHSeqSlowDelete,
  pub typesFree: SHTypesInfoFree,
  pub typesPush: SHTypesInfoPush,
  pub typesInsert: SHTypesInfoInsert,
  pub typesPop: SHTypesInfoPop,
  pub typesResize: SHTypesInfoResize,
  pub typesFastDelete: SHTypesInfoFastDelete,
  pub typesSlowDelete: SHTypesInfoSlowDelete,
  pub paramsFree: SHParametersInfoFree,
  pub paramsPush: SHParametersInfoPush,
  pub paramsInsert: SHParametersInfoInsert,
  pub paramsPop: SHParametersInfoPop,
  pub paramsResize: SHParametersInfoResize,
  pub paramsFastDelete: SHParametersInfoFastDelete,
  pub paramsSlowDelete: SHParametersInfoSlowDelete,
  pub shardsFree: ShardsFree,
  pub shardsPush: ShardsPush,
  pub shardsInsert: ShardsInsert,
  pub shardsPop: ShardsPop,
  pub shardsResize: ShardsResize,
  pub shardsFastDelete: ShardsFastDelete,
  pub shardsSlowDelete: ShardsSlowDelete,
  pub expTypesFree: SHExposedTypesInfoFree,
  pub expTypesPush: SHExposedTypesInfoPush,
  pub expTypesInsert: SHExposedTypesInfoInsert,
  pub expTypesPop: SHExposedTypesInfoPop,
  pub expTypesResize: SHExposedTypesInfoResize,
  pub expTypesFastDelete: SHExposedTypesInfoFastDelete,
  pub expTypesSlowDelete: SHExposedTypesInfoSlowDelete,
  pub enumsFree: SHEnumsFree,
  pub enumsPush: SHEnumsPush,
  pub enumsInsert: SHEnumsInsert,
  pub enumsPop: SHEnumsPop,
  pub enumsResize: SHEnumsResize,
  pub enumsFastDelete: SHEnumsFastDelete,
  pub enumsSlowDelete: SHEnumsSlowDelete,
  pub stringsFree: SHStringsFree,
  pub stringsPush: SHStringsPush,
  pub stringsInsert: SHStringsInsert,
  pub stringsPop: SHStringsPop,
  pub stringsResize: SHStringsResize,
  pub stringsFastDelete: SHStringsFastDelete,
  pub stringsSlowDelete: SHStringsSlowDelete,
}
#[test]
fn bindgen_test_layout__SHCore() {
  assert_eq!(
    ::core::mem::size_of::<_SHCore>(),
    444usize,
    concat!("Size of: ", stringify!(_SHCore))
  );
  assert_eq!(
    ::core::mem::align_of::<_SHCore>(),
    4usize,
    concat!("Alignment of ", stringify!(_SHCore))
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).alloc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(alloc)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).free as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(free)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).tableNew as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(tableNew)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).setNew as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(setNew)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).composeShards as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(composeShards)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).runShards as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(runShards)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).runShards2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(runShards2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).runShardsHashed as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(runShardsHashed)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).runShardsHashed2 as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(runShardsHashed2)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).log as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(log)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).logLevel as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(logLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).createShard as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(createShard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).validateSetParam as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(validateSetParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).createWire as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(createWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).setWireName as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(setWireName)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).setWireLooped as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(setWireLooped)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).setWireUnsafe as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(setWireUnsafe)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).addShard as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(addShard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).removeShard as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(removeShard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).destroyWire as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(destroyWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stopWire as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stopWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).composeWire as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(composeWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).runWire as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(runWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).getWireInfo as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(getWireInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).getGlobalWire as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(getGlobalWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).setGlobalWire as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(setGlobalWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).unsetGlobalWire as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(unsetGlobalWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).createMesh as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(createSHMesh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).destroyMesh as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(destroySHMesh)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).schedule as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(schedule)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).unschedule as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(unschedule)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).tick as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(tick)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).sleep as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(sleep)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).getRootPath as *const _ as usize },
    132usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(getRootPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).setRootPath as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(setRootPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).asyncActivate as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(asyncActivate)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).getShards as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(getShards)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).registerShard as *const _ as usize },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(registerShard)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).registerObjectType as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(registerObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).registerEnumType as *const _ as usize },
    156usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(registerEnumType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).registerRunLoopCallback as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(registerRunLoopCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).unregisterRunLoopCallback as *const _ as usize },
    164usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(unregisterRunLoopCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).registerExitCallback as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(registerExitCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).unregisterExitCallback as *const _ as usize },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(unregisterExitCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).referenceVariable as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(referenceVariable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).referenceWireVariable as *const _ as usize },
    180usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(referenceWireVariable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).releaseVariable as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(releaseVariable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).setExternalVariable as *const _ as usize },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(setExternalVariable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).removeExternalVariable as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(removeExternalVariable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).allocExternalVariable as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(allocExternalVariable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).freeExternalVariable as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(freeExternalVariable)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).suspend as *const _ as usize },
    204usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(suspend)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).getState as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(getState)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).abortWire as *const _ as usize },
    212usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(abortWire)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).cloneVar as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(cloneVar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).destroyVar as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(destroyVar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).readCachedString as *const _ as usize },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(readCachedString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).writeCachedString as *const _ as usize },
    228usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(writeCachedString)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).isEqualVar as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(isEqualVar)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).isEqualType as *const _ as usize },
    236usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(isEqualType)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).deriveTypeInfo as *const _ as usize },
    240usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(deriveTypeInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).freeDerivedTypeInfo as *const _ as usize },
    244usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(freeDerivedTypeInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).seqFree as *const _ as usize },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(seqFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).seqPush as *const _ as usize },
    252usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(seqPush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).seqInsert as *const _ as usize },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(seqInsert)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).seqPop as *const _ as usize },
    260usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(seqPop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).seqResize as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(seqResize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).seqFastDelete as *const _ as usize },
    268usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(seqFastDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).seqSlowDelete as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(seqSlowDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).typesFree as *const _ as usize },
    276usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(typesFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).typesPush as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(typesPush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).typesInsert as *const _ as usize },
    284usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(typesInsert)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).typesPop as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(typesPop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).typesResize as *const _ as usize },
    292usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(typesResize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).typesFastDelete as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(typesFastDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).typesSlowDelete as *const _ as usize },
    300usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(typesSlowDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).paramsFree as *const _ as usize },
    304usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(paramsFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).paramsPush as *const _ as usize },
    308usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(paramsPush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).paramsInsert as *const _ as usize },
    312usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(paramsInsert)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).paramsPop as *const _ as usize },
    316usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(paramsPop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).paramsResize as *const _ as usize },
    320usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(paramsResize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).paramsFastDelete as *const _ as usize },
    324usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(paramsFastDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).paramsSlowDelete as *const _ as usize },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(paramsSlowDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).shardsFree as *const _ as usize },
    332usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(shardsFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).shardsPush as *const _ as usize },
    336usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(shardsPush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).shardsInsert as *const _ as usize },
    340usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(shardsInsert)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).shardsPop as *const _ as usize },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(shardsPop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).shardsResize as *const _ as usize },
    348usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(shardsResize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).shardsFastDelete as *const _ as usize },
    352usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(shardsFastDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).shardsSlowDelete as *const _ as usize },
    356usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(shardsSlowDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).expTypesFree as *const _ as usize },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(expTypesFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).expTypesPush as *const _ as usize },
    364usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(expTypesPush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).expTypesInsert as *const _ as usize },
    368usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(expTypesInsert)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).expTypesPop as *const _ as usize },
    372usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(expTypesPop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).expTypesResize as *const _ as usize },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(expTypesResize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).expTypesFastDelete as *const _ as usize },
    380usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(expTypesFastDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).expTypesSlowDelete as *const _ as usize },
    384usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(expTypesSlowDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).enumsFree as *const _ as usize },
    388usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(enumsFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).enumsPush as *const _ as usize },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(enumsPush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).enumsInsert as *const _ as usize },
    396usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(enumsInsert)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).enumsPop as *const _ as usize },
    400usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(enumsPop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).enumsResize as *const _ as usize },
    404usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(enumsResize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).enumsFastDelete as *const _ as usize },
    408usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(enumsFastDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).enumsSlowDelete as *const _ as usize },
    412usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(enumsSlowDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stringsFree as *const _ as usize },
    416usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stringsFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stringsPush as *const _ as usize },
    420usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stringsPush)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stringsInsert as *const _ as usize },
    424usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stringsInsert)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stringsPop as *const _ as usize },
    428usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stringsPop)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stringsResize as *const _ as usize },
    432usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stringsResize)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stringsFastDelete as *const _ as usize },
    436usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stringsFastDelete)
    )
  );
  assert_eq!(
    unsafe { &(*(::core::ptr::null::<_SHCore>())).stringsSlowDelete as *const _ as usize },
    440usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCore),
      "::",
      stringify!(stringsSlowDelete)
    )
  );
}
pub type SHCore = _SHCore;
pub type SHShardsInterface =
  ::core::option::Option<unsafe extern "C" fn(abi_version: u32) -> *mut SHCore>;
extern "C" {
  pub fn shardsInterface(abi_version: u32) -> *mut SHCore;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lconv {
  pub _address: u8,
}
